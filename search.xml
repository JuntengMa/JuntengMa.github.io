<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Http各版本特性及其区别</title>
      <link href="2021/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E7%89%88%E6%9C%AC%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7/"/>
      <url>2021/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E7%89%88%E6%9C%AC%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP各版本特性及区别"><a href="#HTTP各版本特性及区别" class="headerlink" title="HTTP各版本特性及区别"></a>HTTP各版本特性及区别</h3><a id="more"></a><p>本文参考:<br><a href="https://juejin.im/post/6844903923136856078">https://juejin.im/post/6844903923136856078</a><br><a href="https://segmentfault.com/a/1190000019891825">https://segmentfault.com/a/1190000019891825</a></p><p>HTTP 是基于 TCP/IP 协议的一个应用层协议，是现代互联网的一个基础协议。规定了客户端与服务端之间的通信格式以及所占用的服务端口80(HTTPS是443)。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>HTTP 协议从开始立项到现在一共经历了 4 个版本:</p><pre><code>HTTP 0.9 -&gt; HTTP 1.0 -&gt; HTTP 1.1 -&gt; HTTP 2</code></pre><h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h4><p>HTTP 0.9 是一个最古老的版本</p><p><strong>只支持GET请求方式</strong>：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息<br>没有请求头概念：所以不能在请求中指定版本号，<strong>服务端也只具有返回 HTML字符串的能力</strong><br><strong>服务端相响应之后，立即关闭TCP连接</strong></p><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h4><p>随着 HTTP 1.0 的发布，这个版本:</p><p>请求方式<strong>新增了POST，DELETE，PUT，HEADER等方式</strong><br>增添了<strong>请求头</strong>和<strong>响应头</strong>的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)<br>扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输<br>在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。</p><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p>一个简单请求的头信息</p><pre><code>GET / HTTP/1.0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */*</code></pre><p>浏览器控制台reponse headers<br><img src="https://s1.ax1x.com/2020/10/30/BtJAlF.png"></p><p>可以看到在请求方法之后有 请求资源的位置 + 请求协议版本，之后是一些客户端的信息配置</p><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p>一个简单响应的头信息(v1.0)</p><pre><code>HTTP/1.0 200 OKContent-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMT// 这是一个空行...数据内容</code></pre><p>浏览器控制台request headers<br><img src="https://s1.ax1x.com/2020/10/30/BtJfhV.png"></p><p>服务端的响应头第一个就是 请求协议版本，后面紧跟着是这次请求的状态码、以及状态码的描述，之后的内容是一些关于返回内容的描述。</p><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p>在 HTTP 1.0 的时候，任何的资源都可以被传输，传输的格式呢也是多种多样的，客户端在收到响应体的内容的时候就是根据这个 Content-Type 去进行解析的。所以<strong>服务端返回时候</strong>必须带着这个字段。<br><img src="https://s1.ax1x.com/2020/10/30/BtYKBj.png"><br>一些常见的 Content-Type 可以参考 对照表。 这些 Content-Type 有一个总称叫做<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a></p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>无状态：服务器不跟踪不记录请求过的状态</li><li><strong>无连接</strong>：<strong>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接）</strong></li></ul><h6 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h6><p>对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录</p><h6 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h6><p>无连接导致的性能缺陷有两种：</p><ul><li><strong>无法复用连接</strong><br>每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低</li><li><strong>队头阻塞</strong><br>HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</li></ul><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h4><p>  HTTP 1.1 是在 1.0 发布之后的半年就推出了，完善了 1.0 版本。目前也还有很多的互联网项目基于 HTTP 1.1 在向外提供服务。</p><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><p>长连接：新增Connection字段，可以设置keep-alive值保持连接不断开<br>管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回<br>缓存处理：新增字段cache-control<br>断点传输</p><h6 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h6><p>HTTP 1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据.</p><p>B站首页，就有keep-alive，因为他们也有IM的成分在里面。需要大量复用TCP连接～<br><img src="https://s1.ax1x.com/2020/10/30/Btt4L4.png"></p><h6 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h6><p>基于长连接的基础，我们先看没有管道化请求响应：</p><p>tcp没有断开，用的同一个通道</p><pre><code>--&gt; 请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3</code></pre><p>管道化的请求响应：</p><pre><code>--&gt; 请求1 --&gt; 请求2 --&gt; 请求3 --&gt; 响应1 --&gt; 响应2 --&gt; 响应3</code></pre><p>即使服务器先准备好响应2,也是按照请求顺序先返回响应1</p><p>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p><h6 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理:"></a>缓存处理:</h6><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。 通过设置字段cache-control来控制缓存。</p><p><strong>怎么解决解决队头阻塞的问题?</strong></p><blockquote><p>实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个TCP的会话。<br>也就是说，上图我们看到的并行，其实是不同的TCP连接上的HTTP请求和响应。这也就是我们所熟悉的浏览器对同域下并行加载6~8个资源的限制。而这，才是真正的并行！</p></blockquote><p><strong>浏览器同域名请求的最大并发数限制</strong></p><blockquote><p>当我们在浏览网页的时候，对浏览速度有一个重要的影响因素，就是浏览器的并发数量。并发数量简单通俗的讲就是，当浏览器网页的时候同时工作的进行数量。</p></blockquote><ul><li><p>HTTP客户端一般对同一个服务器的并发连接个数都是有限制的。<br>实际上，浏览器确实使用并行连接，但它们将并行连接的总数限制为少量（<strong>通常为四个</strong>）。服务器可以自由地关闭来自特定客户端的过多连接。</p></li><li><p>一些主流浏览器对HTTP 1.1和HTTP 1.0的最大并发连接数目，可以参考如下表格：</p></li></ul><p><img src="https://s1.ax1x.com/2020/10/30/BtcGjA.png"></p><h6 id="断点传输"><a href="#断点传输" class="headerlink" title="断点传输"></a>断点传输</h6><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p><h5 id="Http-1-1的致命缺点："><a href="#Http-1-1的致命缺点：" class="headerlink" title="Http 1.1的致命缺点："></a>Http 1.1的致命缺点：</h5><p>1.明文传输<br>2.其实还是没有解决无状态连接的<br>3.当有多个请求同时被挂起的时候,就会拥塞请求通道，导致后面请求无法发送<br>4.臃肿的消息首部:HTTP/1.1能压缩请求内容,但是消息首部不能压缩;在现今请求中,消息首部占请求绝大部分(甚至是全部)也较为常见.</p><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h4><h5 id="特性-2"><a href="#特性-2" class="headerlink" title="特性:"></a>特性:</h5><h6 id="二进制帧封装"><a href="#二进制帧封装" class="headerlink" title="二进制帧封装:"></a>二进制帧封装:</h6><p>HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率</p><h6 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用:"></a>多路复用:</h6><blockquote><p>所有的请求都是通过一个 TCP 连接并发完成。<br>HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。</p><p>同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。</p><p>即：HTTP2.0对于同一域名下所有请求都是基于流的，不管对于同一域名访问多少文件，也只建立一路连接。优先级高的流会被优先发送。图片请求的优先级要低于 CSS 和 SCRIPT，这个设计可以确保重要的东西可以被优先加载完</p></blockquote><h6 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩:"></a>头部压缩:</h6><p>由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源，</p><p>HTTPS 和 HTTP</p><ul><li>HTTPS 协议需要申请证书</li><li>HTTP 和 HTTPS 使用端口不一样，前者是80，后者是443</li><li>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li><li>HTTPS 可以有效的防止运营商劫持</li></ul>]]></content>
      
      
      <categories>
          
          <category> Http&amp;Https </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http</title>
      <link href="2021/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%99%A8%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/"/>
      <url>2021/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%99%A8%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>HTTPS的一些知识</p><a id="more"></a><h3 id="1-什么是HTTP协议"><a href="#1-什么是HTTP协议" class="headerlink" title="1/什么是HTTP协议"></a>1/什么是HTTP协议</h3><ul><li>HTTP协议是超文本传输协议的简称,规定了服务端和客户端(前后端)通信方式以及占用的接口</li><li>HTTP协议是一个局域TCP/IP通信协议来传输数据的</li></ul><h3 id="2-HTTP协议的特性"><a href="#2-HTTP协议的特性" class="headerlink" title="2/HTTP协议的特性"></a>2/HTTP协议的特性</h3><ul><li>HTTP协议支持客户端/服务端模式,也是一种请求/响应模式的协议</li><li>简单快速,客户端向服务器请求服务时,只需要提供请求方法和URL.常用的有 GET,PSOT,DELETE,HEAD等</li><li>无连接:HTTP协议规定浏览器和服务端只能保持短暂的链接,浏览器的每次请求都需要与服务器建立一个TCP链接,服务器处理完成后立即断开TCP链接</li><li>无状态:无状态是指服务器不跟踪也不记录请求过的状态,后续如果需要前面的信息,必须重传.</li><li>但是可以借助cookie和session记住来做身份认证和状态记录</li></ul><h3 id="3-HTTP报文组成"><a href="#3-HTTP报文组成" class="headerlink" title="3/HTTP报文组成"></a>3/HTTP报文组成</h3><h4 id="请求报问"><a href="#请求报问" class="headerlink" title="请求报问"></a>请求报问</h4><ul><li>请求行</li><li>请求头(Request Header)</li><li>请求正文</li></ul><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul><li>状态行</li><li>响应头(Response Header)</li><li>响应正文</li></ul><h3 id="4-常见请求方法"><a href="#4-常见请求方法" class="headerlink" title="4/常见请求方法"></a>4/常见请求方法</h3><ul><li>GET</li><li>HEAD:类似GET请求,但是返回的响应中没有具体内容,用于获取报头</li><li>POST</li><li>PUT:从客户端向服务器传送的数据取代指定的文档的内容</li><li>DELETE:请求服务器删除指定页面</li></ul><h3 id="5-响应状态码"><a href="#5-响应状态码" class="headerlink" title="5/响应状态码"></a>5/响应状态码</h3><p>状态码分类：</p><ul><li>1XX- 信息型，服务器收到请求，需要请求者继续操作。</li><li>2XX- 成功型，请求成功收到，理解并处理。</li><li>3XX - 重定向，需要进一步的操作以完成请求。</li><li>4XX - 客户端错误，请求包含语法错误或无法完成请求。</li><li>5XX - 服务器错误，服务器在处理请求的过程中发生了错误。</li></ul><h3 id="6-常见状态码"><a href="#6-常见状态码" class="headerlink" title="6/常见状态码"></a>6/常见状态码</h3><ul><li>200:请求成功</li><li>204:无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>301:永久重定向，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302:临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>304:未修改。所请求的资源未修改，服务器不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>400:客户端请求的语法错误，服务器无法理解</li><li>401:请求要求用户的身份认证</li><li>403:服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404:服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>422:请求格式正确，但是由于含有语义错误，无法响应。</li><li>500:服务器内部错误，无法完成请求</li></ul>]]></content>
      
      
      <categories>
          
          <category> Http&amp;Https </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Https及其加密原理</title>
      <link href="2021/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https/"/>
      <url>2021/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https/</url>
      
        <content type="html"><![CDATA[<p>Https协议及其加密原理</p><a id="more"></a><h2 id="1-http-协议存在的一些问题"><a href="#1-http-协议存在的一些问题" class="headerlink" title="1/http 协议存在的一些问题"></a>1/http 协议存在的一些问题</h2><ul><li>http报文明文发送,可能会被第三方窃听</li><li>http报文可能会被第三方截取之后修改通信内容,接收方没有办法发现报文内容的修改</li><li>http还存在认证问题,第三方可以冒充他人参与通信</li></ul><h2 id="2-Https简介"><a href="#2-Https简介" class="headerlink" title="2/Https简介"></a>2/Https简介</h2><ul><li>HTTPS指的是超文本传输安全协议,HTTPS是基于HTTTP协议的,不过它会使用TLS/SSL来对数据进行加密,即Http+TLS/SSL</li><li>使用TLS和SSL协议,所有的信息都是加密的,第三方没有办法窃听,并且他提供了一种校验机制,信息一旦被篡改,通信双方立刻就会发现</li><li>它还配备了身份证书,防止身份被冒充的情况出现</li></ul><h2 id="3-SSL加密方式"><a href="#3-SSL加密方式" class="headerlink" title="3/SSL加密方式"></a>3/SSL加密方式</h2><ul><li><p>对称加密</p><p><img src="https://s1.ax1x.com/2020/11/10/Bqe2dS.png"></p><pre><code>对称加密即客户端和服务端同时约定同一种秘钥,客户端发送信息给服务端使用该秘钥加密,服务端收到信息后在用秘钥解密,整个流程类似下面这个例子:期末考试,小明找小红希望数学考试的时候小红可以帮他,两个人考试前约定了一把秘钥:小红把所有的答案都加上250;小红把答案通过秘钥加密: 15 + 250 = 265 --&gt; 偷偷的丢给小明小明通过秘钥解密: 265- 250 = 15 ---&gt; 小明得到正确答案</code></pre><ul><li>对称加密加密效率高速度快</li><li>但是该加密方式存在一些漏洞,假如别人获取到了加密方式,然后再用该方案来解密,那数据信息岂不是还是可以被截取修改,因此出现了非对称加密的方案</li></ul></li><li><p>非对称加密</p><p>非对称加密就是有两把密钥，公钥和私钥。私钥自己藏着，不告诉任何人；而公钥可以公开给别人。</p><p><img src="https://s1.ax1x.com/2020/11/10/Bqe7LV.png"></p><pre><code>非对称加密即通信双方各自有一个秘钥和公钥,公钥用来对信息进行加密,私钥用来对信息进行解密;通信的时候, 公钥是随着信息一起发送给对方的,即公钥是公开的, 但是私钥是不会公开的假如A发送信息给B:- A把自己发送的信息连同公钥(加密方式)一起发送给B,- B方收到信息和公钥的时候,把返回的信息通过A的公钥对信息进行加密- 返回信息给A的同时把自己的公钥和密文一起发送给A- A收到B的加密信息之后,再通过自己的私钥对信息进行解密,如果还需要和B进行通信,再用B的公钥加密即可</code></pre><ul><li>非对称加密相对于对称加密安全度是高了一点,但是如果拦截方把数据拦截下来,将自己的数据用拦截下来的公钥加密后返回给发送方,放松方并不能识别出来是不是目标通信对象发来的信息,因此还需要<strong>数字签名</strong>来作保障</li></ul></li></ul><h2 id="4-数字签名"><a href="#4-数字签名" class="headerlink" title="4/数字签名"></a>4/数字签名</h2><p>数字签名是附加在报文上面的特殊加密校验码.可以防止报文被篡改,如果恶意攻击在传输过程中篡改了报文,那么校验的时候就不再匹配,因此可以确认报文被篡改;</p><p><strong>数字签名加密过程:</strong></p><ul><li>发送端将报文通过算法（比如通过HASH函数）提取为定长的摘要；</li><li>发送端将摘要应用签名算法，以私有密钥作为参数生成一个签名；</li><li>计算得出签名后，将签名附加在报文末端发送给接收方；</li><li>接收端收到报文后，对签名进行检查。接收端通过公开密钥解码签名。然后比对报文生成的摘要是否与签名一致便可判断报文是否被篡改。</li></ul><p><strong>数字证书:</strong></p><p>数字证书是由权威机构给某网站颁发的一种认可凭证。它主要包含一些认证信息，比如：对象的名称（服务器、组织、个人等）、过期时间、证书颁发者、来自证书发布者的数字签名。</p><p><img src="https://s1.ax1x.com/2020/11/10/BqM3Bq.png"></p><p>上面的图片就是<a href="http://www.google.com的证书./">www.google.com的证书。</a></p><p>我们可以看到在上面讲到数字签名的时候，似乎就可以保证报文的安全了。为什么还需要数字证书呢？这个设想一下这个场景：比如某人A把发送到浏览器的公有密钥进行了替换，同时A在给浏览器发送报文时使用自己的私有密钥对报文进行数字签名，那么浏览器就不能确认报文是否来自于真实服务器。这个时候就可以使用数字证书进行验证，因为数字证书中保存了真实服务器的信息。</p><h2 id="5-HTTPS的工作流程"><a href="#5-HTTPS的工作流程" class="headerlink" title="5/HTTPS的工作流程"></a>5/HTTPS的工作流程</h2><p><strong>建立安全传输</strong><br>在TCP连接建立完成以后，在HTTPS协议中，客户端和服务端会初始化SSL层，也就是安全层。</p><p><strong>SSL握手</strong><br>在发送报文之前，客户端和服务端会进行一次SSL握手，在这个过程中主要完成以下工作：</p><ul><li><p>交换协议版本号；</p></li><li><p>选择一个两端都了解的密码；</p></li><li><p>对两端的身份进行认证；</p></li><li><p>生成临时会话密钥，以便加密信道（建立完安全通道后，传输报文时使用对称加密）；</p></li></ul><p>在SSL会进行很多工作，处理交换一些必要的信息之外，还会对身份进行认证。</p><p>这里的认证是通过数字证书进行的，在客户端获取证书后，会采用相应的算法对服务端的身份信息进行验证：</p><ul><li><p>日期检测：客户端会检查证书的有效期是否合法；</p></li><li><p>签名颁布者可信度检测：浏览器会附带一个签名颁发机构的授信列表，如果浏览器收到了位置的颁发机构签发的证书，那么它会显示一条警告信息；</p></li><li><p>签名检测：客户端对签名使用签名颁发机构的公开密钥，然后将其与校验码比较，以便验证证书是否合法；</p></li><li><p>站点身份检测：客户端验证数字证书中的域名是否与服务端的域名匹配；</p></li></ul><p>身份认证完成后，客户端与服务端进行密码协商，确定本次连接采用哪种加密算法进行通信。</p><p><strong>开始通信</strong><br>SSL握手完成后，就完成建立了HTTPS通道，客户端与服务端就会根据协商的加密算法进行通信。</p><p>整个HTTPS的工作流程可以总结如下：</p><p><img src="https://s1.ax1x.com/2020/11/10/BqM7Uf.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6/总结"></a>6/总结</h2><p>相较于HTTP协议，HTTPS确保了报文的机密性以及完整性。HTTPS确保这些的依赖就是SSL/TSL协议，SSL/TSL安全协议搭配数字证书保证了报文在传输过程中的绝对安全。</p>]]></content>
      
      
      <categories>
          
          <category> Http&amp;Https </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="2021/04/07/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95/"/>
      <url>2021/04/07/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>复习做的几个算法练习题/…</p><a id="more"></a><p>一、不借助临时变量，进行两个整数的交换</p><pre><code>let a = 1, b = 2;[a, b] = [b, a]console.log(a, b);</code></pre><p>二、字符串查找：请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。<br>🌰:</p><pre><code>a=&#39;34&#39;;b=&#39;1234567&#39;; // 返回 2a=&#39;35&#39;;b=&#39;1234567&#39;; // 返回 -1a=&#39;355&#39;;b=&#39;12354355&#39;; // 返回 5isContain(a,b);</code></pre><p>三、统计一个字符串出现最多的字母：给出一段英文连续的英文字符窜，找出重复出现次数最多的字母。<br>🌰:</p><pre><code>输入 ： afjghdfraaaasdenas输出 ： a</code></pre><pre><code>function hasMost(str) &#123;  let counts = &#123;&#125;  for (let item of str) &#123;    counts[`$&#123;item&#125;`] = 0    for (let j of str) &#123;      if (j === item) &#123;        counts[`$&#123;item&#125;`] = counts[`$&#123;item&#125;`] + 1;      &#125;    &#125;  &#125;  getMax(counts)&#125;function getMax(counts) &#123;  let maxValue = 0  let maxItem = &#39;&#39;  for (let item in counts) &#123;    if (counts[item] &gt; maxValue) &#123;      maxValue = counts[item]      maxItem = item    &#125;  &#125;  console.log(maxItem, maxValue)&#125;</code></pre><p>四、找出下列正数组的最大差值<br>🌰:</p><pre><code>输入 [10,5,11,7,8,9]输出 6</code></pre><pre><code>function getDifferenceValue(arr) &#123;  let maxNum = null, minNum = null  arr.forEach(item =&gt; &#123;    !maxNum ? maxNum = item : !minNum ? minNum = item : null    item &gt; maxNum      ? maxNum = item      : item &lt; minNum        ? minNum = item        : minNum  &#125;)  console.log(maxNum, minNum)  console.log(maxNum - minNum)&#125;</code></pre><p>五、斐波那契数列：1、1、2、3、5、8、13、21。输入n，输出数列中第n位数的值。<br>🌰:</p><pre><code>function getValue(num) &#123;  if (num &lt; 2) &#123;    return 1  &#125; else &#123;    return (getValue(num - 1) + getValue(num - 2))  &#125;&#125;</code></pre><p>六、用js实现二分查找：二分查找的前提是有序数组</p><pre><code>🌰:将要查找的值每次与中间值比较，大于中间值，则在右边进行相同的查找，小于中间值则在左边进行比较查找，找到返回索引值，没找到返回-1。</code></pre><p>var missingNumber = function (nums) {<br>  let left = 0, right = nums.length - 1;<br>  while (left &lt;= right) {<br>    let mid = Math.floor((left + right) / 2);<br>    if (mid === nums[mid]) {<br>      left = mid + 1;<br>    } else if (mid &lt; nums[mid]) {<br>      right = mid - 1;<br>    }<br>  }<br>  return left;<br>};</p><p>```<br>七、数组去重</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="2021/04/07/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%89%91%E6%8C%87offer/"/>
      <url>2021/04/07/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<p>[1/二维数组中的查找](#1/ 二维数组中的查找)</p><p>[2/ 替换空格](#2/ 替换空格)</p><h4 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1/ 二维数组中的查找"></a>1/ 二维数组中的查找</h4><blockquote><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>demo:</p><ul><li><p>输入</p><pre><code>7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code></pre></li><li><p>输出</p><pre><code>true</code></pre></li></ul></blockquote><pre><code>function Find(target, array) &#123;  for(let i=0;i&lt;array.length;i++)&#123;    if(array[i].indexOf(target)!==-1)&#123;      return true    &#125;  &#125;  return false&#125;</code></pre><h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2/ 替换空格"></a>2/ 替换空格</h4><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><pre><code>function replaceSpace(str)&#123;  return str.replace(/ /g,&#39;%20&#39;)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器同源策略</title>
      <link href="2021/04/07/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
      <url>2021/04/07/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>关于同源策略的一点总结~</p><a id="more"></a><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h5 id="01、什么是同源策略"><a href="#01、什么是同源策略" class="headerlink" title="01、什么是同源策略"></a>01、什么是同源策略</h5><blockquote><p>同源策略是浏览器安全的基石</p><p>同源：</p><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul><p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。</p><p>它的同源情况如下：</p><ul><li><code>http://www.example.com/dir2/other.html</code>：同源</li><li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li><li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li><li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li></ul></blockquote><h5 id="02、同源策略目的"><a href="#02、同源策略目的" class="headerlink" title="02、同源策略目的"></a>02、同源策略目的</h5><blockquote><p>同源策略目的，是为了保证用户信息安全，防止恶意网站窃取数据</p></blockquote><h5 id="03、同源策略限制范围"><a href="#03、同源策略限制范围" class="headerlink" title="03、同源策略限制范围"></a>03、同源策略限制范围</h5><blockquote><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM无法获得</li><li>AJAX请求不能发送</li></ul></blockquote><h5 id="04、规避同源策略方案"><a href="#04、规避同源策略方案" class="headerlink" title="04、规避同源策略方案"></a>04、规避同源策略方案</h5><blockquote><ul><li>JSONP</li><li>WebSocket</li><li>CORS</li></ul></blockquote><h5 id="05、JSONP"><a href="#05、JSONP" class="headerlink" title="05、JSONP"></a>05、JSONP</h5><blockquote><ul><li><p>什么是JSONP<br>JSONP是服务器与客户端跨原通信的常用方案。最大特点就是简单适用，老式浏览器全部支持，服务器改造小</p></li><li><p>原理</p><p>网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，该方法不受同源策略限制，服务器收到请求之后，将数据放在指定的名字回调函数中传回来</p></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同源策略 </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack配置</title>
      <link href="2021/04/07/%E5%B7%A5%E5%85%B7/webpack/"/>
      <url>2021/04/07/%E5%B7%A5%E5%85%B7/webpack/</url>
      
        <content type="html"><![CDATA[<p>webpack基本配置</p><a id="more"></a><h3 id="1-什么是-webpack"><a href="#1-什么是-webpack" class="headerlink" title="1. 什么是 webpack"></a>1. 什么是 webpack</h3><blockquote><p>webpack 是一个现代 javaScript 应用程序的静态模块打包器, 分析项目结构，处理模块化依赖，转换成为浏览器 可运行的代码。</p></blockquote><h3 id="2-webpack-用来做什么"><a href="#2-webpack-用来做什么" class="headerlink" title="2. webpack 用来做什么"></a>2. webpack 用来做什么</h3><blockquote><ul><li>代码转换: TypeScript 编译成 JavaScript、SCSS,LESS 编译成 CSS。</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li></ul></blockquote><h3 id="3-webpack安装"><a href="#3-webpack安装" class="headerlink" title="3.webpack安装"></a>3.webpack安装</h3><pre><code>//全局安装webpack及webpack-cli模块yarn global add webpack webpack--cli//本地安装项目模块（一般本地安装，防止本地和全局版本不一致）yarn add webpack webpack-cli -dev(-D)//打包命令npx webpack</code></pre><h3 id="4-插件"><a href="#4-插件" class="headerlink" title="4.插件"></a>4.插件</h3><h4 id="1-webpack-dev-server"><a href="#1-webpack-dev-server" class="headerlink" title="1. webpack-dev-server"></a>1. webpack-dev-server</h4><pre><code class="node">devServer: &#123;//这里做开发服务器配置    port: 3000,    contentBase: path.join(__dirname, &#39;dist&#39;),//_dirname：表示在当前目录    compress: true,//启动gzip压缩&#125;</code></pre><h4 id="2-HtmlWebpackPlugin"><a href="#2-HtmlWebpackPlugin" class="headerlink" title="2.  HtmlWebpackPlugin"></a>2.  HtmlWebpackPlugin</h4><pre><code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);new HtmlWebpackPlugin(&#123;  template: &#39;./src/index.html&#39;,  filename: &#39;index.html&#39;,  minify: &#123;//用于对文件进行压缩    removeAttributeQuotes: true,// 移除属性的引号    collapseWhitespace: true,    removeComments: true,    removeRedundantAttributes: true,    removeScriptTypeAttributes: true,    removeStyleLinkTypeAttributes: true,    useShortDoctype: true  &#125;,  hash: true&#125;)</code></pre><h4 id="3-热更新"><a href="#3-热更新" class="headerlink" title="3.  热更新"></a>3.  热更新</h4><pre><code>new webpack.HotModuleReplacementPlugin(),</code></pre><h4 id="4-打包分析插件"><a href="#4-打包分析插件" class="headerlink" title="4. 打包分析插件"></a>4. 打包分析插件</h4><pre><code>const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;module.exports = &#123;  plugins: [    new BundleAnalyzerPlugin()  ]&#125;//安装， 然后重启一下server， 然后就可以在http://127.0.0.1:8888/ 看到这个分析了。</code></pre><h4 id="5-开启进度条"><a href="#5-开启进度条" class="headerlink" title="5.  开启进度条"></a>5.  开启进度条</h4><pre><code>const ProgressBarPlugin = require(&#39;progress-bar-webpack-plugin&#39;);new ProgressBarPlugin(),</code></pre><h4 id="6-打包时长测试"><a href="#6-打包时长测试" class="headerlink" title="6. 打包时长测试"></a>6. 打包时长测试</h4><pre><code>const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);const smp = new SpeedMeasurePlugin();const webpackConfig = smp.wrap(&#123;  plugins: [    new MyPlugin(),    new MyOtherPlugin()  ]&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JsonServer</title>
      <link href="2021/04/07/%E5%B7%A5%E5%85%B7/Json-server/"/>
      <url>2021/04/07/%E5%B7%A5%E5%85%B7/Json-server/</url>
      
        <content type="html"><![CDATA[<h1 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h1><p>json-server 是什么？如何使用？</p><blockquote><p>json-server 是一个 npm 管理的包，可以提供前端提供mock的功能。</p></blockquote><a id="more"></a><h2 id="json-server-的使用"><a href="#json-server-的使用" class="headerlink" title="json-server 的使用"></a>json-server 的使用</h2><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1/安装"></a>1/安装</h4><p>全局安装:</p><pre><code>- yarn global add json-server- npm install -g json-server </code></pre><h4 id="2-提供一个json数据的文件"><a href="#2-提供一个json数据的文件" class="headerlink" title="2.提供一个json数据的文件"></a>2.提供一个json数据的文件</h4><h4 id="3-使用json-server命令开启一个端口服务"><a href="#3-使用json-server命令开启一个端口服务" class="headerlink" title="3.使用json-server命令开启一个端口服务"></a>3.使用json-server命令开启一个端口服务</h4><pre><code>json-server --watch --port 3000 test.json</code></pre><h4 id="4-接口的使用"><a href="#4-接口的使用" class="headerlink" title="4.接口的使用:"></a>4.接口的使用:</h4><blockquote><ol><li>列表</li></ol></blockquote><blockquote><ol start="2"><li>详情</li></ol></blockquote><blockquote><ol start="3"><li>分页</li></ol></blockquote><blockquote><ol start="4"><li>排序</li></ol></blockquote><blockquote><ol start="5"><li>全局查询<br>需要使用第三方接口调试工具的(postman)</li></ol></blockquote><blockquote><ol start="6"><li>提供 增加（post）、</li></ol></blockquote><blockquote><ol start="7"><li>删除(delete)、</li></ol></blockquote><blockquote><ol start="8"><li>更新(put)</li></ol></blockquote><p>我们常见的接口：都是 get 或者 post 请求一个 url 地址即可。<br>json-server 除了常见的 get 或者 post ，还提供了诸如 put 、delete 这样的HTTP请求方式，<strong>对于这种使用 http请求方式 + 请求url地址 形成的 api ，我们一般叫做 RESTFul 风格的api</strong>, <em>RESTFul 风格的api底层遵循的是 REST 架构这种协议。</em></p><p>倒叙:<a href="http://localhost:3000/news?sort=id&amp;order=desc">http://localhost:3000/news?sort=id&amp;order=desc</a> </p>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JsonServer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己比较常用的一些git命令</title>
      <link href="2021/04/07/%E5%B7%A5%E5%85%B7/Git%E5%91%BD%E4%BB%A4/"/>
      <url>2021/04/07/%E5%B7%A5%E5%85%B7/Git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="GIT-常用命令"><a href="#GIT-常用命令" class="headerlink" title="GIT 常用命令"></a>GIT 常用命令</h1><a id="more"></a><h2 id="01-Git-全局设置"><a href="#01-Git-全局设置" class="headerlink" title="01 - Git 全局设置"></a>01 - Git 全局设置</h2><pre><code>- git config --global user.name &quot;xxx&quot; 配置用户名- git config --global user.email &quot;xxx@xxx.com&quot; 配置用户邮箱</code></pre><h2 id="02-创建新版本库"><a href="#02-创建新版本库" class="headerlink" title="02 - 创建新版本库"></a>02 - 创建新版本库</h2><pre><code>git clone git@github.com:userName/repositoriesName.gitcd testtouch README.mdgit add README.mdgit commit -m &quot;add README&quot;git push -u origin master</code></pre><h2 id="02-链接远程仓库-已存在的文件夹"><a href="#02-链接远程仓库-已存在的文件夹" class="headerlink" title="02 - 链接远程仓库(已存在的文件夹)"></a>02 - 链接远程仓库(已存在的文件夹)</h2><pre><code>cd existing_foldergit initgit remote add origin git@github.com:userName/repositoriesName.gitgit add .git commit -m &quot;Initial commit&quot;git push -u origin master</code></pre><h2 id="03-已存在的-Git-版本库"><a href="#03-已存在的-Git-版本库" class="headerlink" title="03 - 已存在的 Git 版本库"></a>03 - 已存在的 Git 版本库</h2><pre><code>cd existing_repogit remote rename origin old-origingit remote add origin git@github.com:userName/repositoriesName.gigit push -u origin --allgit push -u origin --tags</code></pre><h2 id="04-开发完毕将要上传代码仓库"><a href="#04-开发完毕将要上传代码仓库" class="headerlink" title="04 - 开发完毕将要上传代码仓库"></a>04 - 开发完毕将要上传代码仓库</h2><pre><code>git add .  增加当前子目录下所有更改过的文件至indexgit commit -m &quot;xxx&quot; 提交git push 推送改动到远端git tag -a v0.0.1 -m &quot;这是一个tag备注信息&quot;  //新建tag及备注git push --tag //将tag推送到远程仓库git tag -ln //查看tag及其备注信息</code></pre><h2 id="05-新建分支"><a href="#05-新建分支" class="headerlink" title="05 - 新建分支"></a>05 - 新建分支</h2><pre><code>git branch &lt;分支名&gt; 创建新分支git checkout &lt;分支名&gt; 切换到该分支git push 如果是新建分支，push的时候需要跟远端仓库关联，一般会提示 git push --set-upstream 你的分支名 ， 复制提示信息并执行</code></pre><h2 id="05-合并分支"><a href="#05-合并分支" class="headerlink" title="05 - 合并分支"></a>05 - 合并分支</h2><pre><code>git pull origin master 多人协作，以防master已更新，本地代码版本没有更新，先同步一下master代码，以防产生合并冲突git checkout master 先切换到主分支再合并git merge &lt;需要合并到master上的分支名&gt; 合并某一个分支到该分支</code></pre><h2 id="06-删除本地，远程分支"><a href="#06-删除本地，远程分支" class="headerlink" title="06 - 删除本地，远程分支"></a>06 - 删除本地，远程分支</h2><pre><code>- git branch -d &lt;分支名&gt; 删除本地某一分支- git push origin --delete &lt;分支名&gt; 删除远端分支</code></pre><h2 id="07-版本回退"><a href="#07-版本回退" class="headerlink" title="07 - 版本回退"></a>07 - 版本回退</h2><pre><code>- git log 查看提交历史和commit 标记- git reset --hard &lt;commit 后面的字符串&gt; 将代码回退到某一版本- git push -f 远端仓库版本高于本地版本，需要强制推送上去</code></pre><h2 id="08-取消所有本地修改"><a href="#08-取消所有本地修改" class="headerlink" title="08 - 取消所有本地修改"></a>08 - 取消所有本地修改</h2><pre><code>git checkout .</code></pre><h2 id="09-查看修改"><a href="#09-查看修改" class="headerlink" title="09 - 查看修改"></a>09 - 查看修改</h2><pre><code>git show &lt;commit日志&gt;  显示详细更改</code></pre><h2 id="10-查看某一文件所有修改历史"><a href="#10-查看某一文件所有修改历史" class="headerlink" title="10 - 查看某一文件所有修改历史"></a>10 - 查看某一文件所有修改历史</h2><pre><code> git log --pretty=on 相对路径/绝对路径 git show &lt;commit日志&gt;</code></pre><h2 id="11-生成-ssh-key"><a href="#11-生成-ssh-key" class="headerlink" title="11 - 生成 ssh key"></a>11 - 生成 ssh key</h2><pre><code>ssh-keygen -t rsa -C &#39;yourEmail@xxx.com&#39;</code></pre><h2 id="12-其他命令"><a href="#12-其他命令" class="headerlink" title="12 - 其他命令"></a>12 - 其他命令</h2><pre><code>git tag  查看taggit tag -v 0.0.1 -m &quot;测试tag&quot;git push --tag  (git push 不会将tag推送到远程，需要用到该命令)git pull 从当前分支远端拉取代码git pull origin &lt;分支名&gt; 拉取某一分支的代码并合并到当前分支git branch 显示远程仓库分支git branch -a 显示所有分支git branch -v 查看分支及其最新一次提交记录git branch --merged 显示所有已合并到当前分支的分支git branch --no-merged 显示所有未合并到当前分支的分支git push origin master 推送到主分支git pull origin &lt;分支名&gt; 拉取远程分支合并到当前分支git log 显示提交日志git diff 显示所有变更git diff HEAD^ 显示与上个版本的差异git rm xxx 除某文件</code></pre>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript学习</title>
      <link href="2021/04/07/TypeScript/TypeScript/"/>
      <url>2021/04/07/TypeScript/TypeScript/</url>
      
        <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS攻击</title>
      <link href="2021/04/07/Safe/XSS%E6%94%BB%E5%87%BB/"/>
      <url>2021/04/07/Safe/XSS%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<p>前端知识回顾之 - XSS攻击</p><a id="more"></a><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><h4 id="1-什么是xss攻击"><a href="#1-什么是xss攻击" class="headerlink" title="1.什么是xss攻击"></a>1.什么是xss攻击</h4><ul><li>xss攻击即跨站脚本攻击,是一种恶意代码注入攻击,攻击者通过在网站上面注入恶意代码,使之在浏览器上面运行,从而获取用户的敏感信息如cookie等</li><li>xss的本质是因为网站没有对恶意代码进行过滤, 与正常代码混在一起,但是浏览器不能识别代码哪些可信哪些不可信,从而导致了恶意代码的执行.</li></ul><h4 id="2-XSS攻击分类"><a href="#2-XSS攻击分类" class="headerlink" title="2.XSS攻击分类"></a>2.XSS攻击分类</h4><ul><li><p>存储型</p><blockquote><p>存储型XSS攻击是将恶意代码提交到网站服务器中,当用户请求数据的时候,服务器将恶意代码拼接到HTML里面后返回,导致恶意代码的执行</p></blockquote></li><li><p>反射型</p><blockquote><p>反射型指的是某些通过url参数获取数据的网站,攻击者构建特殊的url,当服务器收到请求之后,从url中获取数据,并将其拼接为html后返回,从而导致了恶意代码的执行</p></blockquote></li><li><p>DOM型</p><blockquote><p>DOM型XSS攻击指的是攻击者构建了特殊的URL,当用户打开了网站之后,js脚本从url中获取数据,从而导致了恶意代码的执行</p></blockquote></li></ul><h4 id="3-如何预防XSS攻击"><a href="#3-如何预防XSS攻击" class="headerlink" title="3.如何预防XSS攻击"></a>3.如何预防XSS攻击</h4><p>​    预防XSS攻击主要有两个方案</p><ul><li><p>恶意代码提交的时候(不可靠)</p><blockquote><p>当数据即将存入数据库的时候进行转义,但是数据库的数据可能在多个地方使用,有些地方不需要转义,由于我们无法判断这些数据最后的使用场景,所以该方法是<strong>不可靠的</strong></p></blockquote></li><li><p>浏览器执行之前</p><blockquote><ul><li>使用纯前端的方式,不用服务器拼接HTML返回    </li><li>对需要插入的HTML进行充分的转义</li></ul></blockquote></li><li><p>对于DOM性XSS攻击还有以下几种方式</p><blockquote><ul><li>CSP,CSP本质是简历一个白名单,告诉浏览器哪些外部资源是可以加载和执行,从而防止恶意代码的注入攻击</li><li>对敏感信息进行保护,比如cookie使用http-only,禁止脚本获取cookie</li><li>使用验证码,防止脚本伪装用户进行操作</li></ul></blockquote></li></ul><h4 id="4-什么是CSP"><a href="#4-什么是CSP" class="headerlink" title="4.什么是CSP"></a>4.什么是CSP</h4><p>​    CSP指的是内容安全侧策略</p><p>​    他的本质是建立一个白名单,告诉浏览器哪些外部资源可以加在和执行.</p><p>​    <strong>开启SCP方式:</strong></p><ul><li>一种是设置 HTTP 首部中的 <code>Content-Security-Policy</code></li><li>一种是设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ul><p>详细资料可以参考： <a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF攻击</title>
      <link href="2021/04/07/Safe/CSRF%E6%94%BB%E5%87%BB/"/>
      <url>2021/04/07/Safe/CSRF%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h4 id="01-什么是CSRF攻击"><a href="#01-什么是CSRF攻击" class="headerlink" title="01/ 什么是CSRF攻击?"></a>01/ 什么是CSRF攻击?</h4><p>CSRF攻击指的是跨站请求伪造,攻击者诱导用户进入第三方网站,然后该网站向被攻击者网站发送跨站请求.</p><p>如果用户在被攻击者网站中保存了登录状态,攻击者就可以利用这个状态,绕过后台验证,冒充用户向服务器执行一些操作;</p><h4 id="02-CSRF攻击分类"><a href="#02-CSRF攻击分类" class="headerlink" title="02/ CSRF攻击分类"></a>02/ CSRF攻击分类</h4><ul><li>GET请求的CSRF攻击, 通常用img标签构建请求,用户打开网站的时候,自动发送请求</li><li>POST请求CSRF攻击,比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单</li><li>链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li></ul><h4 id="03-防御方法"><a href="#03-防御方法" class="headerlink" title="03/ 防御方法"></a>03/ 防御方法</h4><ul><li>第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</li><li>第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</li><li>第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li><li>第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li><li>验证码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客内容重新整理中~~~</title>
      <link href="2021/04/07/React/%E8%87%AA%E5%AE%9A%E4%B9%89webpack%E9%85%8D%E7%BD%AE/"/>
      <url>2021/04/07/React/%E8%87%AA%E5%AE%9A%E4%B9%89webpack%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>好久没有写博客了，现在回头来看发现写的很烂，最近这段时间开始重新整理一下~</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React学习</title>
      <link href="2021/04/07/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>2021/04/07/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="React基础知识汇总"><a href="#React基础知识汇总" class="headerlink" title="React基础知识汇总"></a>React基础知识汇总</h4><p>[TOC]</p><a id="more"></a><h4 id="01-生命周期"><a href="#01-生命周期" class="headerlink" title="01 / 生命周期"></a>01 / 生命周期</h4><p><strong>react15生命周期</strong><img src="https://s1.ax1x.com/2020/11/10/BLFB1P.png"></p><p>React的生命周期就是组件从初始化到卸载到全过程，可以分为以下几个阶段</p><ul><li>初始化阶段(<ul><li><strong>constructor()</strong>, </li><li><strong>componentWillMount</strong>(),</li><li><strong>render</strong>(), </li><li><strong>componentDidMount</strong>()</li></ul></li><li>更新阶段<ul><li><strong>componentWillReceiveProps</strong>(),</li><li><strong>shouldComponentUpdate</strong>(), </li><li><strong>componentWillUpdate</strong>(), </li><li><strong>render</strong>(), </li><li><strong>componentDidUpdate</strong>()</li></ul></li><li>卸载阶段<ul><li><strong>componentWillUnmont</strong>()</li></ul></li></ul><p>这里需要注意的是更新阶段，componentWillReceiveProps是由父组件触发的更新，只要父组件更新，子组件的该生命周期就会被执行，跟props无关。同是，shouldComponentUpdate可以用来做性能优化</p><p><strong>react16生命周期</strong></p><p><img src="https://s1.ax1x.com/2020/11/10/BLkabF.png"></p><p>在React16的生命周期中，去掉了曾经的<strong>componentWillMount</strong>和<strong>componentWillUpdate</strong>，使用<strong>getDerivedStateFromProps</strong>代替这两个方法。同时在更新阶段的render方法和componentDidUpdate之间，新增了一个<strong>getSnapshotBeforeUpdate</strong>方法。接下来就来详细了解一下React这么做的原理以及这些新增生命周期的具体使用</p><p><strong>react15和react16的区别</strong></p><ul><li><h6 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLu3c9.png"></p><ul><li><p><code>-</code>    componentWillMount()</p></li><li><p><code>+</code>    getDerivedStateFromProps()</p><ol><li><p>getDerivedStateFromProps() 主要用于替换 componentWillReceiveProps() 的</p></li><li><p>getDerivedStateFromProps是一个静态方法 , 需要使用static声明</p></li><li><p>getDerivedStateFromProps 接收两个参数, 父组件传递过来的props和自身state</p></li><li><p>必须返回一个对象格式的返回值，否则控制台会被警告</p></li><li><p>该返回值会被用来更新现有state(并不会覆盖原有State，只做定向更新，如果原来State中没有该属性，则新增)，如果没有需要更新的时候，请记得返回一个null</p><pre><code>static getDerivedStateFromProps(props,state)&#123;  return newState&#125;</code></pre></li></ol></li></ul></li><li><h6 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLMPMj.png"></p><ul><li><code>-</code>componentWillReceiveProps()</li><li><code>+</code>getDerivedStateFormProps()</li><li><code>-</code>componentWillupdate()</li><li><code>+</code>getSnapshotBetforeupdate()</li></ul></li></ul><p>React16中也去掉了componentWillUpdate方法，新增了getSnapshotBeforeUpdate方法，这个方法在render方法之后，componentDidUpdate之前被执行，即真实DOM更新之前（获取更新前的真实DOM和更新前后的State&amp;props信息）。该方法需要一个返回值，作为componentDidUpdate的第三个参数。</p><ul><li><h6 id="componentWillReceiveProps-和getDerivedStateFormProps-区别"><a href="#componentWillReceiveProps-和getDerivedStateFormProps-区别" class="headerlink" title="componentWillReceiveProps()和getDerivedStateFormProps()区别"></a>componentWillReceiveProps()和getDerivedStateFormProps()区别</h6></li></ul><table><thead><tr><th>getDerivedStateFormProps( props , state )</th><th>componentWillReceiveProps( nextPorps )</th></tr></thead><tbody><tr><td>使用static 声明: <code>static getDerivedStateFormProps( props , state )&#123;&#125;</code></td><td>直接声明: <code>componentWillReceiveProps( nextPorps )&#123;&#125;</code></td></tr><tr><td><strong>在组件挂载阶段即可执行,父组件更新执行</strong></td><td><strong>只在父组件更新的时候执行</strong></td></tr><tr><td>接收两个参数:  props  ,  state</td><td>接收一个参数( nextPorps )</td></tr><tr><td><strong>必须返回一个对象格式的返回值 或 null</strong></td><td><strong>可以直接更新state状态</strong></td></tr></tbody></table><p><strong>demo:</strong></p><pre><code>  static getDerivedStateFromProps(props, state) &#123;    if (props.age !== state.age) &#123;      return &#123; age: props.age &#125;      // 类似setStae      // this.setState(&#123;      //   age: props.age      // &#125;);    &#125;    return null  &#125;</code></pre><pre><code>  componentWillReceiveProps(nextporps) &#123;    if (nextporps.age !== this.state.age) &#123;      this.setState(&#123;        age: nextporps.age       &#125;);    &#125;  &#125;</code></pre><h4 id="02-Virtual-Dom"><a href="#02-Virtual-Dom" class="headerlink" title="02 / Virtual Dom"></a>02 / Virtual Dom</h4><ul><li><p>什么是Virtual Dom?</p><ul><li>在原生的<code>JavaScript</code>程序中，我们直接对<code>DOM</code>进行创建和更改，而<code>DOM</code>元素通过我们监听的事件和我们的应用程序进行通讯。</li><li><code>React</code>会先将你的代码转换成一个<code>JavaScript</code>对象，然后这个<code>JavaScript</code>对象再转换成真实<code>DOM</code>。这个<code>JavaScript</code>对象就是所谓的虚拟<code>DOM</code>。</li><li>当我们需要创建或更新元素时，<code>React</code>首先会让这个<code>VitrualDom</code>对象进行创建和更改，然后再将<code>VitrualDom</code>对象渲染成真实<code>DOM</code>；</li><li>当我们需要对<code>DOM</code>进行事件监听时，首先对<code>VitrualDom</code>进行事件监听，<code>VitrualDom</code>会代理原生的<code>DOM</code>事件从而做出响应。</li></ul></li><li><p>为什么使用虚拟dom?</p><ul><li><p>可以提高开发效率</p><pre><code>使用JavaScript，我们在编写应用程序时的关注点在于如何更新DOM。使用React，你只需要告诉React你想让视图处于什么状态，React则通过VitrualDom确保DOM与该状态相匹配。你不必自己去完成属性操作、事件处理、DOM更新，React会替你完成这一切。这让我们更关注我们的业务逻辑而非DOM操作，这一点即可大大提升我们的开发效率。</code></pre></li><li><p>性能提升?(有一些矛盾)</p><pre><code>- 直接说虚拟DOM可以提升性能这种说法是很片面的,直接操作dom非常耗费性能这一点毋庸置疑,但是react同样也无法避免操作dom-    如果是首次渲染,virtualDom不具有任何优势,甚至要进行更多的计算和耗费更多的内存- virtualDOm优势在于diff算法和批量处理策略,在react页面更新之前,已经提前计算好了如何更新和渲染dom,减少重绘回流,因此可以理解为提升了性能</code></pre></li><li><p>跨浏览器兼容</p><pre><code>virtualDom自己实现了一套事件机制,模拟了事件捕获和冒泡的过程,采用了事件代理和批量更新的方法,可以抹平各浏览器事件处理不兼容的问题</code></pre></li></ul></li><li><p>React组件的渲染流程</p><ul><li><p>使用<code>React.createElement</code>或<code>JSX</code>编写<code>React</code>组件，<code>Babel</code>帮助我们把所有的<code>JSX </code>代码最后都会转换成<code>React.createElement(...) </code>格式</p><ul><li><p>JSX编写</p><pre><code>class Hello extends Component &#123;  render() &#123;    return &lt;div&gt;Hello ConardLi&lt;/div&gt;;  &#125;&#125;</code></pre></li><li><p><code>React.createElement</code>编写</p><pre><code>class Hello extends Component &#123;  render() &#123;    return React.createElement(&#39;div&#39;, null, `Hello ConardLi`);  &#125;&#125;</code></pre></li><li><p><code>Babel</code>转化demo</p><pre><code>&lt;div&gt;  &lt;img src=&quot;avatar.png&quot; className=&quot;profile&quot; /&gt;  &lt;Hello /&gt;&lt;/div&gt;;</code></pre><pre><code>React.createElement(&quot;div&quot;, null,     React.createElement(&quot;img&quot;, &#123;      src: &quot;avatar.png&quot;,      className: &quot;profile&quot;    &#125;),     React.createElement(Hello, null));</code></pre></li></ul></li><li><p><code>createElement</code>函数对<code>key</code>和<code>ref</code>等特殊的<code>props</code>进行处理，并获取<code>defaultProps</code>对默认<code>props</code>进行赋值，并且对传入的孩子节点进行处理，最终构造成一个<code>ReactElement</code>对象（所谓的虚拟<code>DOM</code>）。</p></li><li><p><code>ReactDOM.render</code>将生成好的虚拟<code>DOM</code>渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实<code>DOM</code>。</p></li></ul></li></ul><p>​    </p><ul><li><p>virtualDom的组成</p><p>即<code>ReactElement</code>element对象，我们的组件最终会被渲染成下面的结构</p><ul><li><code>type</code>：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或<code>class</code>）</li><li><code>key</code>：组件的唯一标识，用于<code>Diff</code>算法</li><li><code>ref</code>：用于访问原生<code>dom</code>节点</li><li><code>props</code>：传入组件的<code>props</code>，<code>chidren</code>是<code>props</code>中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点）</li><li><code>owner</code>：当前正在构建的<code>Component</code>所属的<code>Component</code></li><li><code>self</code>：（非生产环境）指定当前位于哪个组件实例</li><li><code>_source</code>：（非生产环境）指定调试代码来自的文件(<code>fileName</code>)和代码行数(<code>lineNumber</code>)</li></ul><p>例如;</p><pre><code>&lt;div class=&quot;title&quot;&gt;      &lt;span&gt;Hello ConardLi&lt;/span&gt;      &lt;ul&gt;        &lt;li&gt;苹果&lt;/li&gt;        &lt;li&gt;橘子&lt;/li&gt;      &lt;/ul&gt;&lt;/div&gt;</code></pre><pre><code>const VitrualDom = &#123;  type: &#39;div&#39;,  props: &#123; class: &#39;title&#39; &#125;,  children: [    &#123;      type: &#39;span&#39;,      children: &#39;Hello ConardLi&#39;    &#125;,    &#123;      type: &#39;ul&#39;,      children: [        &#123; type: &#39;li&#39;, children: &#39;苹果&#39; &#125;,        &#123; type: &#39;li&#39;, children: &#39;橘子&#39; &#125;      ]    &#125;  ]&#125;</code></pre></li></ul><h4 id="03-diff算法"><a href="#03-diff算法" class="headerlink" title="03 / diff算法"></a>03 / diff算法</h4><ul><li>DIFF算法是DOM更新的一种算法,指页面被更新时,程序用哪种策略更新DOM</li><li>作用是用来计算出 <strong>Virtual DOM</strong> 中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面。</li></ul><p>DIFF算法策略:</p><ul><li><p>Tree Diff    对树每一层进行遍历，找出不同</p><p><img src="https://s3.ax1x.com/2020/11/17/DVYzW9.png"></p></li><li><p>Component Diff  是数据层面的差异比较</p></li><li><p>Element Diff  真实DOM渲染，结构差异的比较</p><ul><li>Diff提供三种DOM操作：<strong>删除</strong>、<strong>移动</strong>、<strong>插入</strong>。</li></ul></li></ul><p><img src="https://s3.ax1x.com/2020/11/17/DVYozn.png"></p><h4 id="04-fiber架构"><a href="#04-fiber架构" class="headerlink" title="04 / fiber架构"></a>04 / fiber架构</h4><blockquote><p>fiber架构是React16对核心算法的一次重构</p><p>Fiber使原本同步渲染变为异步</p></blockquote><p><strong>4.1 React历史算法的风险</strong></p><blockquote><p>React16之前,组件每次更新都会触发React去构建一棵新的虚拟DOM树,通过与上一次虚拟DOM的diff对比,实现DOM的定更新</p><p>该过程是是一个递归的过程,调用栈非常深,只有最低层的返回了,才能逐层返回.</p><p>这个过程漫长且不可打断,同步一旦开始,就会牢牢抓住线程,直到递归完成,这个过程浏览器除了渲染不会再做其他事情,无法处理用户</p><p>交互状态,页面可能会卡死</p></blockquote><p><strong>4.2 Fiber是怎样处理渲染的？</strong></p><blockquote><p>Fiber 会将一个大的更新任务拆解为许多个小任务。</p><p>每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。</p><p>在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”</p></blockquote><p><strong>4.3 说回生命周期</strong></p><p>在最开始给出生命周期图的时候，细心的同学会发现，在下面这张图的左边，React又将生命周期划分了如下三个阶段</p><p><img src="https://s1.ax1x.com/2020/11/10/BL0HNF.png"></p><ul><li>render：纯净且没有副作用，可能会被暂停或者终止，重新启动</li><li>Pre-commit阶段：可以读取DOM</li><li>commit阶段：可以使用DOM，运行副作用，安排更新</li></ul><p><strong>4.4为什么会这样分呢？</strong></p><blockquote><p>总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。</p><p>为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，再狂的框架也不敢在用户眼皮子底下胡乱更改视图，所以这个过程必须用同步渲染来求稳。</p></blockquote><p><strong>4.5废除的生命周期跟Fiber之间的联系</strong></p><pre><code>在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。这就导致 render 阶段的生命周期都是有可能被重复执行的。带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：componentWillMount；componentWillUpdate；componentWillReceiveProps。这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。</code></pre><h4 id="05-React数据传递方案"><a href="#05-React数据传递方案" class="headerlink" title="05 / React数据传递方案"></a>05 / React数据传递方案</h4><ul><li>组件传值</li><li>context</li><li>redux</li></ul><h4 id="06-setState之后发生什么"><a href="#06-setState之后发生什么" class="headerlink" title="06 / setState之后发生什么?"></a>06 / setState之后发生什么?</h4><p>一、React中setState后发生了什么</p><blockquote><p>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程(Reconciliation)。</p><p>经过调和过程，React 会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个Ul界面。</p><p>在React得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变,这就保证了按需更新，而不是全部重新渲染。</p></blockquote><p>二、setState 为什么默认是异步</p><blockquote><p>假如所有setState是同步的，意味着每执行一次setState时 (有可能一个同步代码中， 多次setState) 都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异 步，则可以把一一个同步代码中的多个setState合并成- -次组件更新。</p></blockquote><p>三、setState什么时候是同步</p><blockquote><p>在setTimeout或者原生事件中，setState是同步的。</p></blockquote><h4 id="7-componentWillUpdate可以直接修改state的值吗？"><a href="#7-componentWillUpdate可以直接修改state的值吗？" class="headerlink" title="7 / componentWillUpdate可以直接修改state的值吗？"></a>7 / componentWillUpdate可以直接修改state的值吗？</h4><blockquote><p>react组件在每次需要重新渲染时候都会调用<code>componentWillUpdate()</code>,</p><p>例如，我们调用 <code>this.setState()</code>时候</p><p>在这个函数中我们之所以不调用<code>this.setState()</code>是因为该方法会触发另一个<code>componentWillUpdate()</code>,如果我们<code>componentWillUpdate()</code>中触发状态更改,我们将以无限循环结束.</p></blockquote><h4 id="8-使用Hooks要遵守哪些原则？"><a href="#8-使用Hooks要遵守哪些原则？" class="headerlink" title="8 / 使用Hooks要遵守哪些原则？"></a>8 / 使用Hooks要遵守哪些原则？</h4><blockquote><ol><li>只在最顶层使用 Hook, 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</li><li>只在 React 函数中调用 Hook, 不要在普通的 JavaScript 函数中调用 Hook。</li><li>可以：<br>✅ 在 React 的函数组件中调用 Hook<br>✅ 在自定义 Hook 中调用其他 Hook</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React生命周期函数</title>
      <link href="2021/04/07/React/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>2021/04/07/React/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​    温故而知新<del>~</del></p><p>​    越基础,越重要哦~</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/06/Bf52x1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React父组件调用子组件</title>
      <link href="2021/04/07/React/React-%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6/"/>
      <url>2021/04/07/React/React-%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>React父组件调用子组件方案</p><a id="more"></a><h2 id="方案一：-ref控制"><a href="#方案一：-ref控制" class="headerlink" title="方案一： ref控制"></a>方案一： ref控制</h2><h4 id="Parent-Component-Parent-tsx"><a href="#Parent-Component-Parent-tsx" class="headerlink" title="Parent Component ( Parent.tsx )"></a>Parent Component ( Parent.tsx )</h4><pre><code>import * as React from &#39;react&#39;;import &#123; ChildA &#125; from &#39;./ChildA&#39;;//多个子组件时可以先定义如下组件：class Childrens extends React.Component&lt;any, any&gt; &#123;  _childA: any;  _childB: any;  _childC: any;&#125;export class Parent extends Childrens &#123;  //调用子组件方式：  get_childA_sum = () =&gt; &#123;    this._childA.sum(1, 2)  &#125;  render() &#123;    const children = &#123;      on_childA_ref: ref =&gt; &#123;        this._childA = ref;      &#125;,      on_childB_ref: ref =&gt; &#123;        this._childB = ref;      &#125;,      on_childC_ref: ref =&gt; &#123;        this._childC = ref;      &#125;,    &#125;    return (      &lt;div&gt;        &lt;button onClick=&#123;() =&gt; this.get_childA_sum()&#125;&gt; SumA &lt;/button&gt;        &lt;ChildA _childA=&#123;children.on_childA_ref&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h4 id="Children-Component-ChildA-tsx"><a href="#Children-Component-ChildA-tsx" class="headerlink" title="Children Component  (ChildA.tsx)"></a>Children Component  (ChildA.tsx)</h4><pre><code>import * as React from &#39;react&#39;;interface ChildAProps &#123;  _childA:Function;&#125;export class ChildA extends React.Component&lt;ChildAProps, any&gt; &#123;  componentDidMount() &#123;        this.props._childA(this)    &#125;  sum = (a , b) =&gt; &#123;    alert(a+b)  &#125;  render()&#123;    return(      &lt;div&gt;        组件A      &lt;/div&gt;    )  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-富文本框(braft-editor)</title>
      <link href="2021/04/07/React/React-richText/"/>
      <url>2021/04/07/React/React-richText/</url>
      
        <content type="html"><![CDATA[<h2 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h2><a id="more"></a><p><a href="https://www.yuque.com/braft-editor/be/gz44tn#wx1vkv">https://www.yuque.com/braft-editor/be/gz44tn#wx1vkv</a></p><pre><code>import React, &#123; Component &#125; from &#39;react&#39;;// 引入编辑器组件import BraftEditor from &#39;braft-editor&#39;;// 引入编辑器样式import &#39;braft-editor/dist/index.css&#39;;import &#123; UploadFn &#125; from &#39;./UploadFn&#39;;export class RichText extends Component &#123;    constructor() &#123;        super();        this.state = &#123;            editorState: BraftEditor.createEditorState(null),        &#125;;        RichText.submitContent = this.submitContent.bind(this);    &#125;    async componentDidMount() &#123;        // 假设此处从服务端获取html格式的编辑器内容        let htmlContent = this.props.htmlContent || null;        // 使用BraftEditor.createEditorState将html字符串转换为编辑器需要的editorStat        this.setState(&#123;            editorState: BraftEditor.createEditorState(htmlContent),        &#125;);    &#125;    componentWillReceiveProps(nextProps) &#123;        if (nextProps.htmlContent !== this.state.htmlContent) &#123;            this.setState(&#123;                editorState: BraftEditor.createEditorState(nextProps.htmlContent),            &#125;);        &#125;    &#125;    submitContent = async () =&gt; &#123;        // 在编辑器获得焦点时按下ctrl+s会执行此方法        // 编辑器内容提交到服务端之前，可直接调用editorState.toHTML()来获取HTML格式的内容        const htmlContent = this.state.editorState.toHTML();        return htmlContent;    &#125;;    handleEditorChange = editorState =&gt; &#123;        this.setState(&#123; editorState &#125;);    &#125;;    render() &#123;        return (            &lt;BraftEditor                value=&#123;this.state.editorState&#125;                onChange=&#123;this.handleEditorChange&#125;                onSave=&#123;this.submitContent&#125;                onBlur=&#123;() =&gt; &#123;                    const htmlContent = this.state.editorState.toHTML();                &#125;&#125;                // excludeControls=&#123;[&#39;options&#39;]&#125;                media=&#123;&#123; uploadFn: UploadFn &#125;&#125;            /&gt;        );    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Hook学习</title>
      <link href="2021/04/07/React/React-hooks/"/>
      <url>2021/04/07/React/React-hooks/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直都知道Hook这个新技术,但是工作过程中几乎没有用到,最近刚好有时间来学习一下<del>~</del></p></blockquote><a id="more"></a><h3 id="01-什么是Hook"><a href="#01-什么是Hook" class="headerlink" title="01/什么是Hook?"></a>01/什么是Hook?</h3><p>Hook是react16.8新增特性,可以在不编写class的情况下使用state以及其他React特性</p><h3 id="02-什么是Hook"><a href="#02-什么是Hook" class="headerlink" title="02/什么是Hook?"></a>02/什么是Hook?</h3><ul><li>Hook顾名思义是钩子的意思,它可以使函数组件中可以勾入React-State以及生命周期特性等等.</li><li>Hook不能在class组件中使用</li></ul><h3 id="03-Hook内置组件"><a href="#03-Hook内置组件" class="headerlink" title="03/Hook内置组件"></a>03/Hook内置组件</h3><ul><li><p><strong>useState</strong>    (用于操控state)</p><ul><li><p><strong>使用:</strong></p><pre><code>const [stateName , stateChangeFun] = useState(初始值)</code></pre><pre><code>const [count , setCount] = useState(0)&lt;Button onClick=&#123;()=&gt;setCount(count++)&#125;&gt;Click&lt;/Button&gt;    </code></pre></li></ul></li><li><p><strong>useEffect</strong></p><p>Effect Hook 可以让我们在react中执行副作用操作</p><p><code>useEffect</code> 的第二个参数，有三种情况</p><ol><li>什么都不传，组件每次 <code>render</code> 之后 <code>useEffect</code> 都会调用，相当于 <code>componentDidMount</code> 和 <code>componentDidUpdate</code></li></ol></li></ul><ol start="2"><li>传入一个空数组 [], 只会调用一次，相当于 <code>componentDidMount</code> 和 <code>componentWillUnmount</code><ol start="3"><li>传入一个数组，其中包括变量，只有这些变量变动时，<code>useEffect</code> 才会执行</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React中使用Echats</title>
      <link href="2021/04/07/React/React-echart/"/>
      <url>2021/04/07/React/React-echart/</url>
      
        <content type="html"><![CDATA[<p>React中使用Echats记录</p><a id="more"></a><h4 id="1-安装echats"><a href="#1-安装echats" class="headerlink" title="1.安装echats"></a>1.安装echats</h4><pre><code>npm install echarts --savenpm install --save echarts-for-react</code></pre><h4 id="2-引入所需模块"><a href="#2-引入所需模块" class="headerlink" title="2.引入所需模块"></a>2.引入所需模块</h4><pre><code class="javascript">// 引入 ECharts 主模块var echarts = require(&#39;echarts/lib/echarts&#39;);// 引入柱状图require(&#39;echarts/lib/chart/bar&#39;);// 引入提示框和标题组件require(&#39;echarts/lib/component/tooltip&#39;);require(&#39;echarts/lib/component/title&#39;);</code></pre><h4 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h4><pre><code class="javascript">showTrend() &#123;        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById(&#39;trend&#39;));        //柱状图点击事件        myChart.on(&#39;click&#39;, params =&gt; &#123;        &#125;);              // 绘制图表        myChart.setOption(&#123;            title: &#123; text: &#39;近十五日趋势&#39; &#125;,            color: [&#39;#3398DB&#39;],            tooltip: &#123;                trigger: &#39;axis&#39;,                axisPointer: &#123;                    type: &#39;shadow&#39;,                &#125;,            &#125;,            grid: &#123;                left: &#39;3%&#39;,                right: &#39;4%&#39;,                bottom: &#39;3%&#39;,                containLabel: true,            &#125;,            xAxis: &#123;                type: &#39;category&#39;,                data: this.state.trendDate,                axisTick: &#123;                    alignWithLabel: true,                &#125;,            &#125;,            yAxis: [&#123; type: &#39;value&#39; &#125;],            series: [                &#123;                    name: &#39;告警总数&#39;,                    type: &#39;bar&#39;,                    barWidth: &#39;60%&#39;,                    data: this.state.trendData,                &#125;,            ],        &#125;);    &#125;</code></pre><h4 id="4-DOM部分"><a href="#4-DOM部分" class="headerlink" title="4.DOM部分"></a>4.DOM部分</h4><pre><code class="html">&lt;div id=&quot;trend&quot; style=&#123;&#123; height: 300 &#125;&#125;&gt;&lt;/div&gt;</code></pre><h4 id="5-效果图"><a href="#5-效果图" class="headerlink" title="5.效果图"></a>5.效果图</h4><p><img src="https://cdn.jsdelivr.net/gh/JuntengMa/Images@1.1/blog/echats.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盒模型,BFC</title>
      <link href="2021/04/07/Css/Css%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/04/07/Css/Css%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>   关于盒模型的一些总结</p></blockquote><a id="more"></a><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><h5 id="标准盒模型-box-sizing-content-box"><a href="#标准盒模型-box-sizing-content-box" class="headerlink" title="标准盒模型(box-sizing:content-box)"></a>标准盒模型(box-sizing:content-box)</h5><pre><code>width = content width;height = content height;</code></pre><h5 id="怪异盒模型-box-sizing-border-box"><a href="#怪异盒模型-box-sizing-border-box" class="headerlink" title="怪异盒模型(box-sizing:border-box)"></a>怪异盒模型(box-sizing:border-box)</h5><pre><code>width = content width + padding + border;height = content height + padding + border;</code></pre><h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><h5 id="01-什么是BFC"><a href="#01-什么是BFC" class="headerlink" title="01/什么是BFC?"></a>01/什么是BFC?</h5><p>块级格式化上下文</p><p>BFC是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><h5 id="02-建立BFC"><a href="#02-建立BFC" class="headerlink" title="02/建立BFC"></a>02/建立BFC</h5><ul><li>浮动</li><li>绝对定位</li><li>行内块元素</li><li>表格单元</li><li>弹性盒</li><li>overflow不为visible</li></ul><h5 id="03-BFC应用场景"><a href="#03-BFC应用场景" class="headerlink" title="03/BFC应用场景"></a>03/BFC应用场景</h5><ul><li>清除浮动</li><li>阻止元素被浮动元素覆盖</li><li>实现两列自适应布局</li></ul>]]></content>
      
      
      <categories>
          
          <category> Css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 盒模型 </tag>
            
            <tag> BFC </tag>
            
            <tag> Css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSONP跨域请求及其原理</title>
      <link href="2021/04/07/Ajax/JsonP/"/>
      <url>2021/04/07/Ajax/JsonP/</url>
      
        <content type="html"><![CDATA[<p>JSONP及其原理</p><a id="more"></a><h5 id="1、JSONP的产生"><a href="#1、JSONP的产生" class="headerlink" title="1、JSONP的产生"></a>1、JSONP的产生</h5><p><strong>背景:</strong></p><ul><li><p>因为浏览器同源策略限制,AJAX跨域请求不到信息</p></li><li><p>Web页面上面调用js文件不受是否跨域影响(类似的还有<code>&lt;script&gt;</code>,<code>&lt;IMG&gt;</code>,<code>&lt;iframe&gt;</code>)</p></li><li><p>于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、Web socket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；</p></li><li><p>恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被JS原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</p></li><li><p>客户端在对JSON文件调用成功之后,也就获得了自己所需要的数据,剩下的就是按自己的需求进行处理和展现了</p></li><li><p>为了方便客户使用数据,逐渐形成了一种非正式传输协议—JSONP.</p><blockquote><p>该协议允许用户传递一个callback参数给服务端,然后服务端返回数据时会将这个callback参数坐会函数名来包裹JSON数据,这样客户端就可以随意订制自己的函数来自动处理返回函数了</p></blockquote></li></ul><h5 id="2、JSONP弊端"><a href="#2、JSONP弊端" class="headerlink" title="2、JSONP弊端"></a>2、JSONP弊端</h5><ul><li>只能发送get请求</li><li>需要服务端配合</li></ul><h5 id="3、JSON流程"><a href="#3、JSON流程" class="headerlink" title="3、JSON流程"></a>3、JSON流程</h5><ul><li>先定义好全局函数</li><li>动态创建script标签</li><li>给服务器提供事先创建好的容器</li><li>服务器获取容器</li><li>将内容填充进容器</li></ul><h5 id="4、-代码实现-https-github-com-JuntengMa-JavaScript-tree-master-JsonP"><a href="#4、-代码实现-https-github-com-JuntengMa-JavaScript-tree-master-JsonP" class="headerlink" title="4、[代码实现]:https://github.com/JuntengMa/JavaScript/tree/master/JsonP"></a>4、[代码实现]:<a href="https://github.com/JuntengMa/JavaScript/tree/master/JsonP">https://github.com/JuntengMa/JavaScript/tree/master/JsonP</a></h5>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSONP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios二次封装</title>
      <link href="2021/04/07/Ajax/Axios/"/>
      <url>2021/04/07/Ajax/Axios/</url>
      
        <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="01-新建src-api文件夹"><a href="#01-新建src-api文件夹" class="headerlink" title="01-新建src/api文件夹"></a>01-新建src/api文件夹</h3><pre><code>api - ajax.js - index.js</code></pre><h3 id="02-新建axios-js文件"><a href="#02-新建axios-js文件" class="headerlink" title="02-新建axios.js文件"></a>02-新建axios.js文件</h3><pre><code class="js">import axios from &#39;axios&#39;//封装ajaxexport default function ajax(url=&#39;&#39;,params=&#123;&#125;,type=&#39;GET&#39;)&#123;  let promise;  type = type.toUpperCase()  return new Promise(((resolve, reject) =&gt; &#123;    //1.判断请求方式    if (type===&#39;GET&#39;)&#123;      //1.1拼接字符串      let str = &#39;&#39;;      Object.keys(params).forEach((value,index) =&gt; &#123;        if (index+1===Object.keys(params).length)&#123;          str+=value+&#39;=&#39;+params[value];        &#125;else&#123;          str+=value+&#39;=&#39;+params[value]+&#39;&amp;&#39;;        &#125;      &#125;);      //1.2完整路径      url+=&#39;?&#39;+str;      //1.3发送get请求      promise = axios.get(url);    &#125;else if(type===&#39;POST&#39;)&#123;      //1.3发送post请求      promise = axios.post(url,params);    &#125;    //2.返回请求结果    promise.then((response)=&gt;&#123;      resolve(response.data);    &#125;).catch((error)=&gt;&#123;      reject(error);    &#125;);  &#125;))&#125;</code></pre><h3 id="03-新建index-js文件"><a href="#03-新建index-js文件" class="headerlink" title="03-新建index.js文件"></a>03-新建index.js文件</h3><pre><code>import ajax from &#39;./ajax&#39;//发送请求export const getPhoneCode = (phone)=&gt;ajax(&#39;/api/getPhoneCode&#39;,&#123;phone&#125;);</code></pre><h3 id="04-api调用"><a href="#04-api调用" class="headerlink" title="04-api调用"></a>04-api调用</h3><pre><code>import &#123; xxxxx &#125; from &#39;api/index.js (文件路径)&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> Axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax</title>
      <link href="2021/04/07/Ajax/Ajax/"/>
      <url>2021/04/07/Ajax/Ajax/</url>
      
        <content type="html"><![CDATA[<p>AJAX复习一下~</p><a id="more"></a><h5 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h5><h5 id="01-ajax是什么"><a href="#01-ajax是什么" class="headerlink" title="01-ajax是什么"></a>01-ajax是什么</h5><blockquote><p>​    JavaScript执行异步网络请求</p></blockquote><h5 id="02-ajax原理"><a href="#02-ajax原理" class="headerlink" title="02-ajax原理"></a>02-ajax原理</h5><p><strong>现在浏览器AJAX主要依靠XMLHttpRequest对象实现</strong></p><p><img src="https://s1.ax1x.com/2020/11/10/BbxQdP.png"></p><h5 id="03-创建ajax"><a href="#03-创建ajax" class="headerlink" title="03 - 创建ajax"></a>03 - 创建ajax</h5><h6 id="1-创建Ajax核心对象XMLHttpRequest"><a href="#1-创建Ajax核心对象XMLHttpRequest" class="headerlink" title="1/创建Ajax核心对象XMLHttpRequest"></a>1/创建Ajax核心对象XMLHttpRequest</h6><pre><code>var xhr = null ;if(window.XMLHttpRequest)&#123;    xhr = new XMLHttpRequest()&#125;else&#123;    xhr = new ActiveXobject(&quot;Microsoft.XMLHTTP&quot;)&#125;</code></pre><h6 id="2-向服务器发送请求"><a href="#2-向服务器发送请求" class="headerlink" title="2/向服务器发送请求"></a>2/向服务器发送请求</h6><pre><code>xhr.open(method,url,async:boolean)xhr.send(string); //POST请求时候采用string参数,否则不需要带参数</code></pre><ul><li><strong>method</strong> : GET/POST</li><li>**url:**请求链接(位置)</li><li>**async:**是否异步</li></ul><pre><code>xhr.open(&quot;POST&quot;,&quot;test.html&quot;,true);  xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);  xhr.send(&quot;fname=Henry&amp;lname=Ford&quot;);  //post请求参数放在send里面，即请求体</code></pre><h6 id="3-服务器响应处理-区分同步-异步情况"><a href="#3-服务器响应处理-区分同步-异步情况" class="headerlink" title="3/服务器响应处理(区分同步/异步情况)"></a>3/服务器响应处理(区分同步/异步情况)</h6><ul><li>responseText:获得字符串形式的响应数据</li><li>ResponseXML:获得XML形式的响应数据</li></ul><p>👹同步处理数据</p><pre><code>1. xhr.open(&quot;GET&quot;,&quot;info.txt&quot;,false);  2. xhr.send();  3. document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText; //获取数据直接显示在页面上</code></pre><p>👺异步处理数据(要在请求状态改变事件中处理。)</p><pre><code>1. xhr.onreadystatechange=function()  &#123; 2.    if (xhr.readyState==4 &amp;&amp;xhr.status==200)  &#123; 3.       document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText;  4.      &#125;5.    &#125; </code></pre><h6 id="4-什么是readyState"><a href="#4-什么是readyState" class="headerlink" title="4/什么是readyState?"></a>4/什么是readyState?</h6><p>readyState是XMLHttpRequest对象的一个属性,用来表示当前XMLHttpRequest对象处于什么状态</p><ul><li>0 : 未初始化,尚未调用xhr.open()方法</li><li>1 : 启动,已经调用xhr.open放大,但是未send</li><li>2 : 发送,已经调用xhr.send方法,但是还没有收到响应</li><li>3 : 接收,已经接收到部分响应数据</li><li>4 : 完成,已经接收到全部响应数据,并且可以在客户端使用</li></ul><h6 id="05-GET和POST请求数据区别"><a href="#05-GET和POST请求数据区别" class="headerlink" title="05/GET和POST请求数据区别"></a>05/GET和POST请求数据区别</h6><ul><li>get请求,参数在url中显示,post请求放在send里面</li><li>get请求发送数据量小,Post请求发送数据量比较大</li><li>get请求安全性低,会被缓存,POST反之</li></ul><h5 id="04-AJAX代码"><a href="#04-AJAX代码" class="headerlink" title="04/AJAX代码"></a>04/AJAX代码</h5><pre><code>function verificationParams(requestInfo) &#123;    //地址不能为空    if (!requestInfo.url) &#123;        throw new Error(&#39;输入请求地址&#39;)    &#125;    //判断是异步是否合规    if (typeof requestInfo.async !== &#39;boolean&#39;) &#123;        throw new Error(&#39;async只接受boolean类型数据&#39;)    &#125;    //请求方式    if (!(requestInfo.type.toUpperCase() === &#39;GET&#39; || requestInfo.type.toUpperCase() === &#39;post&#39;)) &#123;        throw new Error(&#39;请求方式有误&#39;)    &#125;&#125;function ajax(params) &#123;    //默认参数对象    let requestInfo=&#123;        type: &#39;GET&#39;,//请求方式        url:&#39;&#39;,        data:&#39;&#39;,//请求参数        datatype:&#39;string&#39;, //数据类型        async:true,//异步还是同步        callBack:function()&#123;&#125; //处理函数        &#125;    for(let item in params)&#123;        requestInfo[item] = params[item]    &#125;    verificationParams(requestInfo)    const &#123; type, url, data, datatype, async, callBack &#125; = requestInfo    //数据类型转换    let str=&#39;&#39;    let dataType = Object.prototype.toString.call(data)    if (dataType===&#39;[object String]&#39;)&#123;        str = data.replace(/,/g,&#39;&amp;&#39;)    &#125; else if (dataType===&#39;[object Object]&#39;)&#123;        for(let attr in data)&#123;            str+=attr+&#39;=&#39;+data[attr]+&#39;&amp;&#39;        &#125;        str=str.slice(0,-1)    &#125;    let xhr = new XMLHttpRequest()    if(type.toUpperCase()===&#39;GET&#39;)&#123;        xhr.open(type.toUpperCase(),url+&#39;?&#39;+str,async)        xhr.send()    &#125;else&#123;        xhr.open(type.toUpperCase(),url,async)        xhr.setRequestHeader(&#39;content-type&#39;, &#39;application/x-www-form-urlencoded&#39;)        xhr.send(str)    &#125;    xhr.onload=function()&#123;        if(datatype===&#39;json&#39;)&#123;            callBack(eval(&#39;(&#39;+xhr.responseText+&#39;)&#39;))        &#125;else&#123;            callBack(xhr.responseText)        &#125;    &#125;&#125;function Ajax(params)&#123;    let promise=new Promise(function(resolve,reject)&#123;        ajax(&#123;            url:params.url,            type:params.type.toUpperCase() || &#39;GET&#39;,            data:params.data ||&#39;&#39;,            datatype:params.datatype || &#39;string&#39;,            async:params.async || true,            callBack:function(res)&#123;                resolve(res)            &#125;        &#125;)    &#125;)    return promise&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
            <tag> Axios </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
