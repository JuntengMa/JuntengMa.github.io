<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>博客内容重新整理中~~~</title>
    <url>/2020/11/23/React/%E8%87%AA%E5%AE%9A%E4%B9%89webpack%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>好久没有写博客了，现在回头来看发现写的很烂，最近这段时间开始重新整理一下~</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础知识综合</title>
    <url>/2020/11/01/JavaScript/01%20-%20JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<h4> 
整理一些js基础知识点和总结...
</h4>
</blockquote>
<p>[TOC]</p>
<a id="more"></a>

<h4 id="01-JS数据类型-6-1"><a href="#01-JS数据类型-6-1" class="headerlink" title="01 / JS数据类型(6+1)"></a>01 / JS数据类型(6+1)</h4><ul>
<li><p><strong>基本数据类型:</strong></p>
<pre><code>- null
- undefined
- number
- string
- boolean
- symbol:代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。</code></pre>
</li>
<li><p><strong>引用数据类型:</strong></p>
<p>引用数据类型指的是object类型,其他如Array,Date等数据类型都可以理解为Object的子类</p>
<pre><code>object =  [
   Array,
   Date,
   Math,
   ...
]</code></pre>
</li>
<li><p><strong>基本数据类型和引用数据类型区别:</strong></p>
<ul>
<li>基本数据类型在内存中占固定大小的空间,因此被保存在栈中</li>
<li>引用类型值是对象，保存在 <strong>堆内存</strong> 中。包含引用类型值的变量实际包含并非对象本身，而是指向该对象的指针。一个变量从另一个变量复制引用类型的值时，复制的也是指向该对象的指针。</li>
</ul>
</li>
</ul>
<h4 id="02-什么是堆-栈"><a href="#02-什么是堆-栈" class="headerlink" title="02 / 什么是堆/栈?"></a>02 / 什么是堆/栈?</h4><pre><code>堆栈概念存在于数据结构和操作系统内存中
- 在数据结构中:
  - 栈中的数据存取方式为先进后出
  - 堆是一个优先队列,按照优先级来进行排序的,优先级可以按照大小来规定
- 操作系统中 ,内存被分为栈区和堆区:
  - 栈区的内存由编译器自动分配释放,存放函数的参数值,局部变量值等
    - 堆内存一般由程序员释放,若没有手动释放则程序结束时由垃圾回收机制回收</code></pre>
<h4 id="03-什么是JavaSctipt垃圾回收机制"><a href="#03-什么是JavaSctipt垃圾回收机制" class="headerlink" title="03 / 什么是JavaSctipt垃圾回收机制?"></a>03 / 什么是JavaSctipt垃圾回收机制?</h4><ul>
<li><p><strong>为什么要垃圾回收?</strong></p>
<pre><code class="html">随着前端业务需求的不断增多，相比以前，我们会占用更多的内存。
但是内存并不是无限的，我们需要垃圾回收机制去处理那些我们不再需要的变量、对象 </code></pre>
</li>
<li><p><strong>垃圾回收机制的特点:</strong></p>
<p>垃圾回收机制会定期对那些我们不再使用的变量、对象所占用的内存释放     </p>
<pre><code>原理:
    + 找出那些不再使用的变量，然后释放其占用的内存。
    + 垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。</code></pre>
</li>
<li><p><strong>垃圾回收的方式有哪些?</strong></p>
<ul>
<li><p>标记清除</p>
<ul>
<li><p>当变量进入环境时,就将其标记为”进入环境”,此时”进入环境”的变量是不可以被回收的”</p>
</li>
<li><p>当变量离开环境时,就将其标记为”离开环境”,此时”离开环境”的变量可以被回收</p>
<pre><code>function func () &#123;
      const a = 1
    const b = 2
      // 函数执行时，a b 分别被标记 进入环境
&#125;

func() // 函数执行结束，a b 被标记 离开环境，被回收</code></pre>
</li>
</ul>
</li>
<li><p>引用计数</p>
<ul>
<li><p>统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收</p>
<pre><code>function func1 () &#123;
      const c = &#123;&#125; // 引用类型变量 c的引用计数为 0
      let d = c // c 被 d 引用 c的引用计数为 1
      let e = c // c 被 e 引用 c的引用计数为 2
      d = &#123;&#125; // d 不再引用c c的引用计数减为 1
      e = null // e 不再引用 c c的引用计数减为 0 将被回收
&#125;</code></pre>
</li>
<li><p>但是引用计数的方式，有一个相对明显的缺点——<strong>循环引用</strong></p>
<pre><code>function func5 () &#123;
      let f = &#123;&#125;
      let g = &#123;&#125;
      f.prop = g
      g.prop = f
      // 由于 f 和 g 互相引用，计数永远不可能为 0
&#125;</code></pre>
</li>
<li><p>像上面这种情况就需要<strong>手动将变量的内存释放</strong></p>
<pre><code>f.prop = null
g.prop = null</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>参考:<br>    <a href="https://juejin.im/post/6844903652331618312">&lt;&lt;javascript 垃圾回收机制&gt;&gt;</a><br>    <a href="https://juejin.im/post/6844903858972409869#heading-3">&lt;&lt;JavaScript 垃圾回收机制&gt;&gt;</a></p>
<h4 id="04-什么是循环引用"><a href="#04-什么是循环引用" class="headerlink" title="04 / 什么是循环引用 ?"></a>04 / 什么是循环引用 ?</h4><p>当对象 1 中的某个属性指向对象 2，对象 2 中的某个属性指向对象 1 就会出现循环引用(最简单的例子)</p>
<pre><code>  function circularReference() &#123;
      let obj1 = &#123; &#125;;
      let obj2 = &#123; &#125;;
      obj1.a = obj2;
      obj2.b = obj1;
  &#125;</code></pre>
<h4 id="05-内存泄露"><a href="#05-内存泄露" class="headerlink" title="05 / 内存泄露"></a>05 / 内存泄露</h4><ul>
<li><p>什么是内存泄露?</p>
<pre><code>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。
对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。
否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。
不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</code></pre>
</li>
<li><p>常见的内存泄露有哪些?</p>
<ul>
<li><p>全局变量(在非严格模式下当引用未声明的变量时，会在全局对象中创建一个新变量。)</p>
</li>
<li><p>被遗忘的定时器和回调函数</p>
</li>
<li><p>DOM引用</p>
</li>
<li><p>闭包</p>
</li>
</ul>
</li>
</ul>
<h4 id="06-JavaScript可执行上下文"><a href="#06-JavaScript可执行上下文" class="headerlink" title="06 /  JavaScript可执行上下文"></a>06 /  JavaScript可执行上下文</h4><p><a href="/2020/11/03/JavaScript/03%20-%20JavaScript-作用域&可执行上下文/" target="_blank">&lt;&lt;JavaScript可执行上下文&gt;&gt;</a></p>
<h4 id="07-JavaScript在浏览器中如何执行的"><a href="#07-JavaScript在浏览器中如何执行的" class="headerlink" title="07 /  JavaScript在浏览器中如何执行的"></a>07 /  JavaScript在浏览器中如何执行的</h4><p><a href="/2020/09/22/JavaScript/04%20-%20JavaScript-一段js代码在浏览器中是如何执行的/" target="_blank">&lt;&lt;JavaScript在浏览器中如何执行的&gt;&gt;</a></p>
<h4 id="08-从输入url到页面加载过程"><a href="#08-从输入url到页面加载过程" class="headerlink" title="08 /  从输入url到页面加载过程"></a>08 /  从输入url到页面加载过程</h4><p><a href="/2020/10/26/JavaScript/06%20-%20从输入url到页面加载过程/" target="_blank">&lt;&lt;从输入url到页面加载过程&gt;&gt;</a></p>
<h4 id="09-内部属性-class-是什么"><a href="#09-内部属性-class-是什么" class="headerlink" title="09 / 内部属性[[class]]是什么"></a>09 / 内部属性[[class]]是什么</h4><p>所有<code>typeof</code>返回值为 <code>object</code> 的对象（如数组）都包含一个内部属性 [[Class]],这个属性无法直接访问，一般通过以下代码查看</p>
<pre><code>Object.prototype.toString.call(Array)  //&quot;[object Function]&quot;</code></pre>
<h4 id="10-Js内置对象都有哪些"><a href="#10-Js内置对象都有哪些" class="headerlink" title="10 / Js内置对象都有哪些"></a>10 / Js内置对象都有哪些</h4><pre><code>js内置对象主要是只在程序执行前存在全局作用域里面的由js定义的一些全局属性,函数和用来实例化其他对象的构造函数对象.

一般我们经常用到的
全局函数变量值: NaN , undefined ,

全局函数: parseInt() , paeseFloat()

用来实例化的全局构造函数: Date , Object 等</code></pre>
<h4 id="11-原型原型链"><a href="#11-原型原型链" class="headerlink" title="11 / 原型原型链"></a>11 / 原型原型链</h4><pre><code>01/ 原型:
-    Js中我们使用构造函数来新建对象的
-    每个构造函数内部都有一个prototype属性,这个属性值是一个对象,包含了可以由该构造函数共享的实例和方法
- 我们使用构造函数新建一个对象后,这个对象内部有一个`__proto__`指针,可以指向构造函数prototype属性对应的值,es5中我们一般称他为对象的原型 浏览器可以通过`__proto__`值来获取,也可以用Object.getPrototypeOf()找到对象的原型

02/ 原型链:
- 当我们访问一个对象的属性时,如果这个对象里面不存在该属性的时候,那么就会到这个对象的原型对象中找这个属性,就这样一层层的找就构成了原型链,最后找到Object.proptotype,如果还没找到就会返回null.

03/ 获取原型的办法:
- `p.__proto__`
- `p.constructor.prototype`
- `Object.getPrototypeOf(p)`

04/ 原型可以做什么?
- 实现继承
- 共享我们的一些实例和方法</code></pre>
<p><a href="">&lt;&lt;JavaScript原型原型链&gt;&gt;</a></p>
<h4 id="12-闭包"><a href="#12-闭包" class="headerlink" title="12 / 闭包"></a>12 / 闭包</h4><pre><code>闭包是指内部函数可以访问其所在的外部函数中声明的参数和变量;

创建闭包最常用的方法是在一个函数内创建另外一个函数,创建的函数可以访问父级函数的局部变量;

闭包主要有两个用途:

1/ 使我们可以在函数外部访问到函数内部的变量,通过这个方法,我们可以在函数外部调用闭包函数,在函数外部访问到函数内部变量

2/ 使已经运行过的函数上下文的变量对象继续保存在内存中,不被垃圾回收机制释放内存,但是操作不当可能会造成内存泄露</code></pre>
<h4 id="13-继承"><a href="#13-继承" class="headerlink" title="13 / 继承"></a>13 / 继承</h4><pre><code>继承实现方式:
- 原型链继承
- 构造函数继承
- 组合继承(原型链+构造函数继承)
- 原型式继承
- 寄生式继承
- 寄生组合式继承</code></pre>
<p><a href="https://github.com/mqyqingfeng/Blog/issues/16">&lt;&lt;JavaScript深入之继承的多种方式和优缺点&gt;&gt;</a></p>
<h4 id="14-什么是-pure-function"><a href="#14-什么是-pure-function" class="headerlink" title="14 / 什么是 pure function"></a>14 / 什么是 pure function</h4><p>如果一个函数没有任何副作用（side-effects)，不会影响任何外部状态，对于任何一个相同的输入（参数），无论何时调用这个函数总是返回同样的结果，这个函数就是一个 pure function。</p>
<h4 id="15-重绘回流"><a href="#15-重绘回流" class="headerlink" title="15 / 重绘回流"></a>15 / 重绘回流</h4><p><strong>01/ 前置知识:</strong></p>
<ol>
<li><p>浏览器使用流式布局模型 (Flow Based Layout)。</p>
</li>
<li><p>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了<code>Render Tree</code>。</p>
</li>
<li><p>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</p>
</li>
<li><p>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一。 </p>
</li>
</ol>
<p><strong>02/ 什么是回流:</strong></p>
<p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>
<p><strong>02.1/ 会导致回流的操作：</strong></p>
<ul>
<li>页面首次渲染</li>
<li>浏览器窗口大小发生改变</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li>
<li>激活<code>CSS</code>伪类（例如：<code>:hover</code>）</li>
<li>查询某些属性或调用某些方法</li>
</ul>
<p><strong>02.2/ 一些常用且会导致回流的属性和方法：</strong></p>
<ul>
<li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li>
<li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li>
<li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li>
<li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
<li><code>scrollTo()</code></li>
</ul>
<p><strong>03/ 什么是重绘:</strong></p>
<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>
<ul>
<li><strong>回流比重绘的代价要更高。</strong></li>
<li>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</li>
</ul>
<p><strong>03.1/ 现代浏览器会对频繁的回流或重绘操作进行优化：</strong></p>
<ul>
<li><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p>
</li>
<li><p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p>
<pre><code>- clientWidth、clientHeight、clientTop、clientLeft

</code></pre>
</li>
</ul>
<ul>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
</ul>
<ul>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
</ul>
<ul>
<li>width、height</li>
</ul>
<ul>
<li>getComputedStyle()</li>
</ul>
<ul>
<li>getBoundingClientRect()<pre><code></code></pre>
</li>
</ul>
<p><strong>04/ 如何避免回流重绘?</strong></p>
<ul>
<li><p>CSS</p>
<ul>
<li>避免使用<code>table</code>布局。</li>
<li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li>
<li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li>
</ul>
</li>
<li><p>JavaScript</p>
<ul>
<li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li>
<li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li>
<li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
</li>
</ul>
<p><strong>05 /总结:</strong></p>
<p> <strong>回流必将引起重绘，重绘不一定会引起回流。</strong></p>
<p>参考:<a href="https://juejin.im/post/6844903569087266823">&lt;&lt;浏览器的回流与重绘 (Reflow &amp; Repaint)&gt;&gt;</a></p>
<h4 id="16-http缓存"><a href="#16-http缓存" class="headerlink" title="16 / http缓存"></a>16 / http缓存</h4><p>http缓存按我自己的理解:</p>
<blockquote>
<p>我更愿意叫做浏览器缓存,缓存主要发生在浏览器端,而http起到的作用是告诉浏览器是否使用缓存资源,是否进行缓存…</p>
</blockquote>
<p>01/ 为什么要缓存呢?</p>
<blockquote>
<p>用于性能提升,减少延迟,提高网页加载速度;同时,由于缓存文件可以重复利用,还可以减少带宽,降低网络负荷</p>
</blockquote>
<p>02/ 浏览器怎么才能缓存?</p>
<blockquote>
<p>http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。<br>可以控制浏览器是否使用缓存、缓存多久</p>
</blockquote>
<p>03/ 那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：</p>
<p><img src="https://s3.ax1x.com/2020/11/12/BzalAP.png"></p>
<p>第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分size有具体数值，然而还有一部分请求，比如图片、css和js等文件并没有显示文件大小，而是显示了 from dis cache 或者 from memory cache 字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。</p>
<p>04/ 浏览器缓存方式?<br>浏览器缓存分为两种:</p>
<ul>
<li>强制缓存</li>
<li>协商缓存</li>
</ul>
<p>05/ 浏览器缓存机制</p>
<blockquote>
<p>1\ 浏览器加载资源的时候,先根据资源的http header判断他是否命中强缓存,</p>
<pre><code>-    如果命中,浏览器就先从自己的缓存(先从内存中找,找不到再去磁盘中找)中读取资源,不会发送请求到服务器</code></pre>
<p>2\ 没有命中的时候,浏览器会发送一个请求给服务器,通过服务器端的另外的一些http header来验证这个资源是否命中协商缓存</p>
<ul>
<li>如果命中协商缓存,服务器会将这个请求返回,但是不会返回这个请求的数据,而是告诉客户端可以直接从缓存中加载资源,然后浏览器重新去缓存中读取数据</li>
</ul>
<p>3\强缓存和协商缓存相同点:</p>
<ul>
<li>命中都是从浏览器缓存中加载资源</li>
</ul>
<p>4\不同点</p>
<ul>
<li>强缓存不发请求到服务器</li>
<li>协商缓存会发请求给服务器</li>
</ul>
<p>05\协商缓存也没有命中的时候,浏览器直接去服务器获取数据</p>
</blockquote>
<p>06/ 判断缓存机制</p>
<p><img src="https://s3.ax1x.com/2020/11/12/BzB1bj.png"></p>
<p>参考:</p>
<ul>
<li><a href="https://juejin.im/post/6844903672556552205#heading-2">&lt;&lt;前端优化：浏览器缓存技术介绍&gt;&gt;</a></li>
<li><a href="https://juejin.im/post/6844903838768431118#heading-0">&lt;&lt;http面试必会的：强制缓存和协商缓存&gt;&gt;</a></li>
</ul>
<h4 id="17-SSR-BSR区别"><a href="#17-SSR-BSR区别" class="headerlink" title="17 / SSR/BSR区别"></a>17 / SSR/BSR区别</h4><ul>
<li><p>SSR:服务端渲染</p>
<p>对营销推广的要求比较高的产品,比如官网等</p>
<pre><code>- M+V发生在服务端,服务器压力较大
- 页面访问和显示速度更快(DOM比较少)
- 有利于SEO搜索引擎优化
- 前后端不分离,后端开发压力大
- 功能不能过于复杂,多用于功能交互都比较简单的产品</code></pre>
</li>
<li><p>BSR:客户端渲染</p>
<p>对营销推广要求没有那么搞的产品,例如后台管理系统</p>
<pre><code>- M+v过程发生在浏览器,浏览器压力较大
- 页面访问和加载速度没有服务端渲染快
- 不利于SEO优化
- 前后端分离,便于代码调试和维护
- 可以做更加复杂的产品</code></pre>
</li>
</ul>
<h4 id="18-SEO优化"><a href="#18-SEO优化" class="headerlink" title="18 / SEO优化"></a>18 / SEO优化</h4><p>………………</p>
<h4 id="19-MVC"><a href="#19-MVC" class="headerlink" title="19 / MVC"></a>19 / MVC</h4><p>MVC模式的意思是，软件可以分成三个部分。即Model模型、View视图、Controller控件器。</p>
<blockquote>
<ul>
<li><p>View：视图，为用户提供使用界面，与用户直接进行交互。</p>
</li>
<li><p>Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载Bean，一类称为业务处理Bean。所谓数据承载Bean是指实体类，专门承载业务数据的，如Student、User等。而业务处理Bean则是指Service或Dao对象，专门用于处理用户提交请求的。</p>
</li>
<li><p>Controller：控制器，用于将用户请求转发给相应的Model进行处理，并处理Model的计算结果向用户提供相应响应。</p>
</li>
</ul>
</blockquote>
<p>MVC架构程序的工作流程是这样的：</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAKqrd.png"></p>
<blockquote>
<p>（1）用户通过View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX请求等。</p>
<p>（2）服务端Controller控制器接收到请求后对请求进行解析，找到相应 的Model对用户请求进行处理。</p>
<p>（3）Model处理后，将处理结果再交给Controller。</p>
<p>（4）Controller在接到处理结果后，根据处理结果找到要作为向客户端发回的响应View页面。页面经渲染（数据填充）后，再发送给客户端。</p>
</blockquote>
<p>实际项目往往采用更灵活的方式</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAMGIx.png"></p>
<blockquote>
<p>\1. 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</p>
<p>\2. 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</p>
<p>\3. Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。</p>
</blockquote>
<p>参考: </p>
<p><a href="https://juejin.im/post/6844903479568252935">&lt;&lt;MVC 与三层架构&gt;&gt;</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">&lt;&lt;MVC，MVP 和 MVVM 的图示&gt;&gt;</a></p>
<h4 id="20-MVVM"><a href="#20-MVVM" class="headerlink" title="20 / MVVM"></a>20 / MVVM</h4><p><img src="https://s3.ax1x.com/2020/11/16/DAYfZF.png"></p>
<pre><code>1. 各部分之间的通信，都是双向的。

2. View 与 Model 不发生联系，都通过 ViewModule 传递。

3. View 非常薄，不部署任何业务逻辑，称为&quot;被动视图&quot;（Passive View），即没有任何主动性，而 ViewModule非常厚，所有逻辑都部署在那里。
4. 它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然</code></pre>
<h4 id="21-SPA单页应用-amp-多页应用"><a href="#21-SPA单页应用-amp-多页应用" class="headerlink" title="21/ SPA单页应用 &amp; 多页应用"></a>21/ SPA单页应用 &amp; 多页应用</h4><p><a href="https://www.jianshu.com/p/a02eb15d2d70">&lt;&lt;&gt;&gt;</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>自己比较常用的一些git命令</title>
    <url>/2020/09/22/%E5%B7%A5%E5%85%B7/Git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="GIT-常用命令"><a href="#GIT-常用命令" class="headerlink" title="GIT 常用命令"></a>GIT 常用命令</h1><a id="more"></a>

<h2 id="01-Git-全局设置"><a href="#01-Git-全局设置" class="headerlink" title="01 - Git 全局设置"></a>01 - Git 全局设置</h2><pre><code>- git config --global user.name &quot;xxx&quot; 配置用户名

- git config --global user.email &quot;xxx@xxx.com&quot; 配置用户邮箱
</code></pre>
<h2 id="02-创建新版本库"><a href="#02-创建新版本库" class="headerlink" title="02 - 创建新版本库"></a>02 - 创建新版本库</h2><pre><code>git clone git@github.com:userName/repositoriesName.git

cd test

touch README.md

git add README.md

git commit -m &quot;add README&quot;

git push -u origin master</code></pre>
<h2 id="02-链接远程仓库-已存在的文件夹"><a href="#02-链接远程仓库-已存在的文件夹" class="headerlink" title="02 - 链接远程仓库(已存在的文件夹)"></a>02 - 链接远程仓库(已存在的文件夹)</h2><pre><code>cd existing_folder

git init

git remote add origin git@github.com:userName/repositoriesName.git

git add .

git commit -m &quot;Initial commit&quot;

git push -u origin master
</code></pre>
<h2 id="03-已存在的-Git-版本库"><a href="#03-已存在的-Git-版本库" class="headerlink" title="03 - 已存在的 Git 版本库"></a>03 - 已存在的 Git 版本库</h2><pre><code>cd existing_repo

git remote rename origin old-origin

git remote add origin git@github.com:userName/repositoriesName.gi

git push -u origin --all

git push -u origin --tags
</code></pre>
<h2 id="04-开发完毕将要上传代码仓库"><a href="#04-开发完毕将要上传代码仓库" class="headerlink" title="04 - 开发完毕将要上传代码仓库"></a>04 - 开发完毕将要上传代码仓库</h2><pre><code>git add .  增加当前子目录下所有更改过的文件至index

git commit -m &quot;xxx&quot; 提交

git push 推送改动到远端

git tag -a v0.0.1 -m &quot;这是一个tag备注信息&quot;  //新建tag及备注

git push --tag //将tag推送到远程仓库

git tag -ln //查看tag及其备注信息</code></pre>
<h2 id="05-新建分支"><a href="#05-新建分支" class="headerlink" title="05 - 新建分支"></a>05 - 新建分支</h2><pre><code>git branch &lt;分支名&gt; 创建新分支

git checkout &lt;分支名&gt; 切换到该分支

git push 如果是新建分支，push的时候需要跟远端仓库关联，一般会提示 git push --set-upstream 你的分支名 ， 复制提示信息并执行</code></pre>
<h2 id="05-合并分支"><a href="#05-合并分支" class="headerlink" title="05 - 合并分支"></a>05 - 合并分支</h2><pre><code>git pull origin master 多人协作，以防master已更新，本地代码版本没有更新，先同步一下master代码，以防产生合并冲突

git checkout master 先切换到主分支再合并

git merge &lt;需要合并到master上的分支名&gt; 合并某一个分支到该分支
</code></pre>
<h2 id="06-删除本地，远程分支"><a href="#06-删除本地，远程分支" class="headerlink" title="06 - 删除本地，远程分支"></a>06 - 删除本地，远程分支</h2><pre><code>- git branch -d &lt;分支名&gt; 删除本地某一分支

- git push origin --delete &lt;分支名&gt; 删除远端分支</code></pre>
<h2 id="07-版本回退"><a href="#07-版本回退" class="headerlink" title="07 - 版本回退"></a>07 - 版本回退</h2><pre><code>- git log 查看提交历史和commit 标记

- git reset --hard &lt;commit 后面的字符串&gt; 将代码回退到某一版本

- git push -f 远端仓库版本高于本地版本，需要强制推送上去</code></pre>
<h2 id="08-取消所有本地修改"><a href="#08-取消所有本地修改" class="headerlink" title="08 - 取消所有本地修改"></a>08 - 取消所有本地修改</h2><pre><code>git checkout .</code></pre>
<h2 id="09-查看修改"><a href="#09-查看修改" class="headerlink" title="09 - 查看修改"></a>09 - 查看修改</h2><pre><code>git show &lt;commit日志&gt;  显示详细更改</code></pre>
<h2 id="10-查看某一文件所有修改历史"><a href="#10-查看某一文件所有修改历史" class="headerlink" title="10 - 查看某一文件所有修改历史"></a>10 - 查看某一文件所有修改历史</h2><pre><code> git log --pretty=on 相对路径/绝对路径

 git show &lt;commit日志&gt;</code></pre>
<h2 id="11-生成-ssh-key"><a href="#11-生成-ssh-key" class="headerlink" title="11 - 生成 ssh key"></a>11 - 生成 ssh key</h2><pre><code>ssh-keygen -t rsa -C &#39;yourEmail@xxx.com&#39;
</code></pre>
<h2 id="12-其他命令"><a href="#12-其他命令" class="headerlink" title="12 - 其他命令"></a>12 - 其他命令</h2><pre><code>git tag  查看tag

git tag -v 0.0.1 -m &quot;测试tag&quot;

git push --tag  (git push 不会将tag推送到远程，需要用到该命令)

git pull 从当前分支远端拉取代码

git pull origin &lt;分支名&gt; 拉取某一分支的代码并合并到当前分支

git branch 显示远程仓库分支

git branch -a 显示所有分支

git branch -v 查看分支及其最新一次提交记录

git branch --merged 显示所有已合并到当前分支的分支

git branch --no-merged 显示所有未合并到当前分支的分支

git push origin master 推送到主分支

git pull origin &lt;分支名&gt; 拉取远程分支合并到当前分支

git log 显示提交日志

git diff 显示所有变更

git diff HEAD^ 显示与上个版本的差异

git rm xxx 除某文件</code></pre>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh配置</title>
    <url>/2021/03/12/%E5%B7%A5%E5%85%B7/ssh%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="Git-配置多个-SSH-Key-方法"><a href="#Git-配置多个-SSH-Key-方法" class="headerlink" title="Git 配置多个 SSH-Key 方法"></a>Git 配置多个 SSH-Key 方法</h3><a id="more"></a>

<p>一般情况下，当有多个 git 账号，如果没有咧，都去尝试一下，例如：</p>
<ul>
<li>gitee 账号，国产 github，码云值得拥有</li>
<li>github 账号，全球最大同性交友网站</li>
<li>gitlab 账号，公司内部的工作开发，至少我所在开发组使用的这个</li>
</ul>
<p><strong>解决方案</strong></p>
<p>解决办法很简单，新建一个 config 文件就可以了。</p>
<h4 id="1、本地生成-SSH-Key"><a href="#1、本地生成-SSH-Key" class="headerlink" title="1、本地生成 SSH-Key"></a>1、本地生成 SSH-Key</h4><p>生成一个 gitee 用的 SSH-Key</p>
<pre><code>$ ssh-keygen -t rsa -C &#39;xxxxx@163.com&#39; -f ~/.ssh/gitee_id_rsa</code></pre>
<p>生成一个 github 用的 SSH-Key</p>
<pre><code>$ ssh-keygen -t rsa -C &#39;xxxxx@163.com&#39; -f ~/.ssh/github_id_rsa</code></pre>
<p>生成一个公司用 gitlab 的 SSH-Key</p>
<pre><code>$ ssh-keygen -t rsa -C &#39;xxxxx@company.com&#39; -f ~/.ssh/gitlab_id_rsa</code></pre>
<p>在默认文档中就会生成如下这些文件：</p>
<h4 id="2、git-平台设置中"><a href="#2、git-平台设置中" class="headerlink" title="2、git 平台设置中"></a>2、git 平台设置中</h4><p>将 .pub 文件中内容复制到相应的平台 SSH 设置中，例如：</p>
<p>gitee_id_rsa.pub 中的文件内容复制到码云的 SSH 公钥中。</p>
<h4 id="3、新建-config-文件"><a href="#3、新建-config-文件" class="headerlink" title="3、新建 config 文件"></a>3、新建 config 文件</h4><p>在 ~/.ssh 目录下新建一个 config 文件，添加如下内容：</p>
<pre><code># gitee

Host gitee.com
HostName gitee.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/gitee_id_rsa

# github

Host github.com
HostName github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/github_id_rsa

# gitlab

Host xxxx.com
HostName xxxx.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/gitlab_id_rsa
</code></pre>
<p>其中 Host 和 HostName 填写 git 服务器的域名，IdentityFile 指定私钥的路径。<br>实在不晓得 Host 和 HostName 怎么填的呢，譬如不知道公司内部的服务器域名，可以在 known_hosts 文件中查看。</p>
<h4 id="4、测试是否联通"><a href="#4、测试是否联通" class="headerlink" title="4、测试是否联通"></a>4、测试是否联通</h4><p>用 ssh 命令分别测试，@后面跟着的是域名</p>
<pre><code>$ ssh -T git@gitee.com
$ ssh -T git@github.com
$ ssh -T git@xxxx.com</code></pre>
<p>You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<p>当出现这句话的时候说明你已经配置完成啦</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Yarn / npm 对比</title>
    <url>/2020/09/02/%E5%B7%A5%E5%85%B7/yarn-npm%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<a id="more"></a>



<table>
<thead>
<tr>
<th align="left">作用</th>
<th align="left">npm</th>
<th align="center">Yarn</th>
</tr>
</thead>
<tbody><tr>
<td align="left">安装</td>
<td align="left">npm install(i)</td>
<td align="center">yarn</td>
</tr>
<tr>
<td align="left">卸载</td>
<td align="left">npm uninstall(un)</td>
<td align="center">yarn remove</td>
</tr>
<tr>
<td align="left">全局安装</td>
<td align="left">npm install xxx –global(-g)</td>
<td align="center">yarn global add xxx</td>
</tr>
<tr>
<td align="left">安装包</td>
<td align="left">npm install xxx –save(-S)</td>
<td align="center">yarn add xxx</td>
</tr>
<tr>
<td align="left">开发模式安装包</td>
<td align="left">npm install xxx –save-dev(-D)</td>
<td align="center">yarn add xxx –dev(-D)</td>
</tr>
<tr>
<td align="left">更新</td>
<td align="left">npm update –save</td>
<td align="center">yarn upgrade</td>
</tr>
<tr>
<td align="left">全局更新</td>
<td align="left">npm update –global</td>
<td align="center">yarn global upgrade</td>
</tr>
<tr>
<td align="left">卸载</td>
<td align="left">npm uninstall [–save/–save-dev]</td>
<td align="center">yarn remove xx</td>
</tr>
<tr>
<td align="left">清除缓存</td>
<td align="left">npm cache clean</td>
<td align="center">yarn cache clean</td>
</tr>
<tr>
<td align="left">重装</td>
<td align="left">rm -rf node_modules &amp;&amp; npm install</td>
<td align="center">yarn upgrade</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Npm</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转Gulp~~~</title>
    <url>/2021/01/18/%E5%B7%A5%E5%85%B7/gulp/</url>
    <content><![CDATA[<h3 id="01、-Gulp-是什么？"><a href="#01、-Gulp-是什么？" class="headerlink" title="01、 Gulp 是什么？"></a>01、 Gulp 是什么？</h3><p>Gulp 则一种前端工作流的工具，帮忙实现业务过程的自动化。</p>
<a id="more"></a>

<h3 id="02、Gulp-用来做什么？"><a href="#02、Gulp-用来做什么？" class="headerlink" title="02、Gulp 用来做什么？"></a>02、Gulp 用来做什么？</h3><p>前端构建工具，代码压缩等功能</p>
<h3 id="03、Gulp-Demo？"><a href="#03、Gulp-Demo？" class="headerlink" title="03、Gulp Demo？"></a>03、Gulp Demo？</h3><pre><code>const gulp = require(&#39;gulp&#39;);
const del = require(&#39;del&#39;);
const zip = require(&#39;gulp-zip&#39;);
const merge = require(&#39;merge2&#39;);
const appName = require(&#39;./package.json&#39;).name;
const appVersion = require(&#39;./package.json&#39;).version;

gulp.task(&#39;copy-public&#39;, function () &#123;
    return gulp.src(&#39;./public/**&#39;).pipe(gulp.dest(&#39;./build/static&#39;));
&#125;);

gulp.task(&#39;clear-prebuild&#39;, function () &#123;
    return del([
        &#39;./build/server/**&#39;,
        &#39;./build/static/**&#39;,
        &#39;./build/archive/**&#39;,
        &#39;./build/*.zip&#39;,
    ]);
&#125;);

gulp.task(&#39;move&#39;, function () &#123;
    // const buildId = fs.readFileSync(&#39;build/BUILD_ID&#39;, &#39;utf8&#39;);
    const archiveNodePath = &#39;build/archive/nodejs&#39;;
    const archiveCDNPath = &#39;build/archive/cdn&#39;;
    return merge(
        // CDN
        gulp
            .src([&#39;./build/static/**&#39;, &#39;!./build/static/**/*.map&#39;])
            .pipe(gulp.dest(`$&#123;archiveCDNPath&#125;/_next/static/`)),
        gulp.src([&#39;./public/**&#39;]).pipe(gulp.dest(`$&#123;archiveCDNPath&#125;/`)),
        // Node
        gulp.src([&#39;.npmrc&#39;]).pipe(gulp.dest(`$&#123;archiveNodePath&#125;`)),
        gulp
            .src([
                &#39;./**&#39;,
                &#39;!./node_modules&#123;,/**&#125;&#39;,
                &#39;!./build/static/**&#39;,
                &#39;!./build/cache/**&#39;,
                &#39;!./build/archive/**&#39;,
                &#39;!logs&#123;,/**&#125;&#39;,
                &#39;!docs&#123;,/**&#125;&#39;,
                &#39;!sourcemaps&#123;,/**&#125;&#39;,
                &#39;!config&#123;,/**&#125;&#39;,
                &#39;!gulpfile.js&#39;,
                &#39;!external&#123;,/**&#125;&#39;,
                &#39;!*.lock&#39;,
                &#39;!README.md&#39;,
                &#39;!CHANGELOG.md&#39;,
            ])
            .pipe(gulp.dest(`$&#123;archiveNodePath&#125;`))
    );
&#125;);

gulp.task(&#39;zip:cdn&#39;, function () &#123;
    return gulp
        .src(&#39;build/archive/cdn/**&#39;, &#123; base: &#39;./build/archive/cdn&#39;, dot: true &#125;)
        .pipe(zip(`$&#123;appName&#125;-archive-cdn.zip`))
        .pipe(gulp.dest(&#39;./build/archive&#39;));
&#125;);

gulp.task(&#39;zip:nodejs&#39;, function () &#123;
    return gulp
        .src(&#39;build/archive/nodejs/**&#39;, &#123;
            base: &#39;./build/archive/nodejs&#39;,
            dot: true,
        &#125;)
        .pipe(zip(`$&#123;appName&#125;-archive-nodejs.zip`))
        .pipe(gulp.dest(&#39;./build/archive&#39;));
&#125;);

gulp.task(&#39;ci&#39;, gulp.series([&#39;copy-public&#39;, &#39;move&#39;, &#39;zip:cdn&#39;, &#39;zip:nodejs&#39;]));

</code></pre>
]]></content>
      <categories>
        <category>Gulp</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT鉴权</title>
    <url>/2020/11/27/Safe/JWT%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<p>前端安全之 - JWT</p>
<a id="more"></a>

<h4 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT(JSON Web Token)"></a>JWT(JSON Web Token)</h4><h4 id="01-什么是JWT"><a href="#01-什么是JWT" class="headerlink" title="01/ 什么是JWT"></a>01/ 什么是JWT</h4><ul>
<li><p>JWT是JSON Web Token的缩写,是一种易用且无状态的鉴权方式</p>
</li>
<li><p>用于在各方之间以JSON对象安全传输信息。这些信息可以通过数字签名进行验证和信任。</p>
</li>
<li><p>简单来说就是server端把JSON数据经过加密做成Token,以授权给client端</p>
</li>
</ul>
<h4 id="02-栗子"><a href="#02-栗子" class="headerlink" title="02/ 栗子:"></a>02/ 栗子:</h4><p>当Client端登录完成以后，Server端要返回一个7天有效的token，那么对应的Python的样例代码会是这样的：<br>（<a href="https://link.zhihu.com/?target=https://github.com/jpadilla/pyjwt">使用了PyJWT包：pip install pyjwt</a>）</p>
<pre><code>import time

import jwt

exp = int(time.time()) + 86400 * 7  # 失效时间
user = &#39;liriansu&#39;  # 用户表示
key = &#39;hunter2&#39;  # 密钥
payload = &#123;&#39;exp&#39;: exp, &#39;user&#39;: user&#125;  # JSON 数据
token = jwt.encode(payload, key)

print(token)
# token可能会长这样子
# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.EoKoMCjq_zGqUg5HDfqw4EN7EiG6gMjkUZle0uGJDGU</code></pre>
<p>然后Client端每次在authorization header或者是query string里带上token。<br>Server端收到请求的时候，<br>用<code>payload = jwt.decode(token, key)</code>验证权限就行了。<br>验证通过以后，payload中就是整个JSON数据。<br>理论上你可以往token payload里塞任何<strong>_非敏感</strong>_数据。</p>
<h4 id="03-使用场景"><a href="#03-使用场景" class="headerlink" title="03 / 使用场景"></a>03 / 使用场景</h4><ul>
<li><p>鉴权</p>
<p>用户一旦登录,后续的每个请求都需要携带jwt,允许该用户访问该令牌允许的路由,服务和资源.</p>
<p>单点登录是当前使用最广泛的JWT的一项功能,因为开销较小,并且能够跨域使用</p>
</li>
<li><p>信息交换</p>
<p>JWT是在各方之间安全传输信息的好方式,因为JWT可以签名：例如使用公钥/私钥对，所以可以确定发件人是他们自称的人。此外，由于使用标头和有效载荷计算签名，因此您还可以验证内容是否未被篡改。</p>
</li>
</ul>
<h4 id="04-JWT结构"><a href="#04-JWT结构" class="headerlink" title="04 /  JWT结构"></a>04 /  JWT结构</h4><p><code> eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.EoKoMCjq_zGqUg5HDfqw4EN7EiG6gMjkUZle0uGJDGU</code></p>
<p>如上所示,JWT输出的是三个由点分隔的<code>xxxx.yyyy.zzzz</code>Base64-URL字符串，可以在HTML和HTTP环境中轻松传递，</p>
<p>他们分别代表:</p>
<ul>
<li>Header<ul>
<li>Header通常由两部分组成：令牌的类型，即JWT。和常用的散列算法</li>
<li>Header部分的JSON被Base64Url编码，形成JWT的第一部分。</li>
</ul>
</li>
<li>Payload<ul>
<li>存放沟通讯息的地方</li>
<li>Registered claims（注册声明）</li>
<li>Public claims（公开声明）</li>
<li>Private claims（私有声明）</li>
</ul>
</li>
<li>Signature<ul>
<li>用来验证发送请求者身份，由前两部分加密形成。</li>
</ul>
</li>
</ul>
<h4 id="04-所以综合来说，"><a href="#04-所以综合来说，" class="headerlink" title="04/ 所以综合来说，"></a>04/ 所以综合来说，</h4><p>假如使用JWT作为鉴权方式，<br>有以下几个特性：</p>
<ol>
<li>Client端不用管任何加密/解密，只用存token，在请求里面带上就行了。</li>
<li>Server端可以实现不依赖外部存储鉴权，所有的数据都丢在token里。</li>
<li>也就是说鉴权这一步不需要File/MySQL/Redis之类的数据库，也能知道用户身份。</li>
<li>因为token带失效时间，所以需要在失效前/后再刷新token。</li>
</ol>
<h4 id="05-常见问题"><a href="#05-常见问题" class="headerlink" title="05/ 常见问题"></a>05/ 常见问题</h4><h5 id="①-JWT-安全嗎"><a href="#①-JWT-安全嗎" class="headerlink" title="① JWT 安全嗎?"></a>① JWT 安全嗎?</h5><p>Base64编码方式是可逆的，也就是透过编码后发放的Token内容是可以被解析的。一般而言，我们都不建议在有效载荷内放敏感讯息，比如使用者的密码。</p>
<h5 id="②-JWT-Payload-內容可以被伪造嗎？"><a href="#②-JWT-Payload-內容可以被伪造嗎？" class="headerlink" title="② JWT Payload 內容可以被伪造嗎？"></a>② JWT Payload 內容可以被伪造嗎？</h5><p>JWT其中的一个组成内容为Signature，可以防止通过Base64可逆方法回推有效载荷内容并将其修改。因为Signature是经由Header跟Payload一起Base64组成的。</p>
<h5 id="③-如果我的-Cookie-被窃取了，那不就表示第三方可以做-CSRF-攻击"><a href="#③-如果我的-Cookie-被窃取了，那不就表示第三方可以做-CSRF-攻击" class="headerlink" title="③ 如果我的 Cookie 被窃取了，那不就表示第三方可以做 CSRF 攻击?"></a>③ 如果我的 Cookie 被窃取了，那不就表示第三方可以做 CSRF 攻击?</h5><p>是的，Cookie丢失，就表示身份就可以被伪造。故官方建议的使用方式是存放在LocalStorage中，并放在请求头中发送。</p>
<h5 id="④-空间及长度问题？"><a href="#④-空间及长度问题？" class="headerlink" title="④ 空间及长度问题？"></a>④ 空间及长度问题？</h5><p>JWT Token通常长度不会太小，特别是Stateless JWT Token，把所有的数据都编在Token里，很快的就会超过Cookie的大小（4K）或者是URL长度限制。</p>
<h5 id="⑤-Token失效问题？"><a href="#⑤-Token失效问题？" class="headerlink" title="⑤ Token失效问题？"></a>⑤ Token失效问题？</h5><p>无状态JWT令牌（Stateless JWT Token）发放出去之后，不能通过服务器端让令牌失效，必须等到过期时间过才会失去效用。</p>
<p>假设在这之间Token被拦截，或者有权限管理身份的差异造成授权Scope修改，都不能阻止发出去的Token失效并要求使用者重新请求新的Token。</p>
<h4 id="06-JWT使用建议"><a href="#06-JWT使用建议" class="headerlink" title="06/ JWT使用建议"></a>06/ JWT使用建议</h4><ul>
<li>不要存放敏感信息在Token里。</li>
<li>Payload中的exp时效不要设定太长。</li>
<li>开启Only Http预防XSS攻击。</li>
<li>如果担心重播攻击（replay attacks ）可以增加jti（JWT ID），exp（有效时间） Claim。</li>
<li>在你的应用程序应用层中增加黑名单机制，必要的时候可以进行Block做阻挡（这是针对掉令牌被第三方使用窃取的手动防御）。</li>
</ul>
]]></content>
      <categories>
        <category>前端安全</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title>a标签的url怎么会乱码嘞？？？？</title>
    <url>/2020/11/26/JavaScript/JavaScript-a%E6%A0%87%E7%AD%BE%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近写博客发现自己博客链接经常是一堆乱码 ，查了下资料发现是浏览器会将特殊字符转义，想要变回我们需要的样子需要对这个字符串解码~</p>
<a id="more"></a>

<p>类似下面这样 👿👿👿👿👿：<br><img src="https://s3.ax1x.com/2020/11/26/D0M9N8.png"></p>
<p>具体百度过程 😁 和调试过程 🙄（调试个棒槌）就不细说了 ， 这里是我得到的解决方案 ：<br>通过<code>decodeURI()</code>对链接进行解码 ， 我是这么写的</p>
<pre><code class="ejs"> &lt;a href=&quot;&lt;%= decodeURI(page.permalink) %&gt;&quot; target=&quot;_blank&quot;&gt;
    &lt;%= decodeURI(page.permalink) %&gt;
  &lt;/a&gt;</code></pre>
<p>所以最后我的链接就可以变回我需要的样子：<br><img src="https://s3.ax1x.com/2020/11/26/D0QdZq.png"></p>
<p>诶 ，说到这里就有人问我了：马老湿 ， 你这个 <code>decodeURI</code> 是干肾么用的呀？</p>
<p>我就啪的一下，很快啊~ ，给你甩出一个闪电五连鞭：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000013236956">《JS 对 url 进行编码和解码（三种方式）》</a></li>
<li><a href="https://segmentfault.com/a/1190000013236956">《JS 对 url 进行编码和解码（三种方式）》</a></li>
<li><a href="https://segmentfault.com/a/1190000013236956">《JS 对 url 进行编码和解码（三种方式）》</a></li>
<li><a href="https://segmentfault.com/a/1190000013236956">《JS 对 url 进行编码和解码（三种方式）》</a></li>
<li><a href="https://segmentfault.com/a/1190000013236956">《JS 对 url 进行编码和解码（三种方式）》</a></li>
</ul>
<p>并告诉你这个知识点我也是刚学从他这边学的 ， 而且年轻人一定要讲武德 <del>~</del></p>
<p>🤠👹🧐👻😼😽🙀😿😾🐱‍👤🐱‍🏍🐱‍💻🐱‍🐉🐱‍👓🐱‍🚀🙈🙉🙊🐵🐶🐺🐱🦁🦁🦒🦊</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>原型,原型链</title>
    <url>/2020/11/20/JavaScript/07%20-%20JavaScript-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<blockquote>
<h4> 
 原型,原型链
</h4>
</blockquote>
<a id="more"></a>



<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识:"></a>前置知识:</h3><ul>
<li><p>js分为函数对象和普通对象,,每个对象都有<code>_proto_</code>属性,但是只有函数对象才有<code>prototype</code>属性</p>
</li>
<li><p>Object,Function都是js内置函数,类似的还有Array , RegExp , Date , Boolean , Nuber , String </p>
</li>
<li><p><code>_porto_</code>,<code>constructor</code>属性是<strong>对象</strong>所独有的</p>
</li>
<li><p><code>prototype</code>属性是<strong>函数</strong>所独有的</p>
</li>
<li><p>函数也是对象的一种,所以函数中也有<code>_protot_</code>和<code>constructor</code></p>
</li>
</ul>
<h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><pre><code>function Peron() &#123; &#125;
var person = new Person()
person.name = &#39;kevin&#39;
console.log(person.name)</code></pre>
<h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>每个函数都有<code>prototype</code>属性</p>
<pre><code>function Person() &#123; &#125;

Person.prototype.name = &#39;kavin&#39;

var person1 = new Person()
var person2 = new Person()

console.log(person1.name); //kavin
console.log(person2.name); //kavin</code></pre>
<ul>
<li>函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。</li>
<li>那什么是原型呢？每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中继承属性</li>
</ul>
<p><strong>构造函数和实例原型之间的关系</strong></p>
<p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png"></p>
<h3 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a><code>_proto_</code></h3><p>每一个js对象都有一个属性,就是<code>_Proto_</code>,这个属性会指向该对象的原型</p>
<pre><code>function Person() &#123; &#125;

var person = new Person()

console.log(person.__proto__ === Person.prototype); //true
</code></pre>
<p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png"></p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>consttructor指向该构造函数本身,即</p>
<pre><code>Person.prototype.constructor = Person</code></pre>
<p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png"></p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a><a href="https://segmentfault.com/a/1190000008959943">原型链</a></h3><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>原型原型链</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖节流及其应用场景</title>
    <url>/2020/11/20/JavaScript/08.1%20-%20JavaScript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<blockquote>
<h4> 
 复习一下防抖节流及其应用场景
</h4>
</blockquote>
<a id="more"></a>

<h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><p>在事件被触发的n秒后再执行回调,如果在这n秒内又被触发,则重新计时</p>
<pre><code>function debounse(fun, delay) &#123;
    let timer;
    // 设置一个 timer
    return function (args) &#123;
      let _this = this
      let _args = args
      clearTimeout(timer)
      timer = setTimeout(function () &#123;
        fun.call(_this, _args);
      &#125;, delay);
    &#125;
  &#125;</code></pre>
<h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p>
<pre><code>function throttle(fun, delay) &#123;
    let last, timer
    return function (args) &#123;
      let _this = this
      let _args = args
      let now = +new Date()
      if (last &amp;&amp; now &lt; last + delay) &#123;
        clearTimeout(timer)
        timer = setTimeout(function () &#123;
          last = now
          fun.apply(_this, _args)
        &#125;, delay)
      &#125; else &#123;
        last = now
        fun.apply(_this, _args)
      &#125;
    &#125;
  &#125;</code></pre>
<h3 id="demo"><a href="#demo" class="headerlink" title="demo:"></a>demo:</h3><h5 id="模拟ajax请求"><a href="#模拟ajax请求" class="headerlink" title="模拟ajax请求"></a>模拟ajax请求</h5><pre><code>function ajax(params) &#123;
    console.log(&#39;ajax request : &#39; + params)
&#125;</code></pre>
<h5 id="普通input"><a href="#普通input" class="headerlink" title="普通input:"></a>普通input:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252be5c94d6b?imageslim"></p>
<h5 id="加入防抖"><a href="#加入防抖" class="headerlink" title="加入防抖:"></a>加入防抖:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4b429b56?imageslim"></p>
<h5 id="加入节流"><a href="#加入节流" class="headerlink" title="加入节流:"></a>加入节流:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4c1a9686?imageslim"></p>
<h3 id="demo代码"><a href="#demo代码" class="headerlink" title="demo代码"></a>demo代码</h3><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
  没有防抖的Input &lt;input type=&quot;text&quot; class=&quot;unDebounce&quot;&gt;
  &lt;br&gt;
  加入防抖的Input &lt;input type=&quot;text&quot; class=&quot;debounce&quot;&gt;
  &lt;br&gt;
  加入截留的Input &lt;input type=&quot;text&quot; class=&quot;htrottle&quot;&gt;
&lt;/body&gt;

&lt;script&gt;
  function ajax(params) &#123;
    console.log(&#39;ajax request : &#39; + params)
  &#125;

  let inputValue0 = document.querySelector(&#39;.unDebounce&#39;)

  inputValue0.addEventListener(&#39;keyup&#39;, function (e) &#123;
    ajax(e.target.value)
  &#125;)
  /**********************防抖********************************/

  function debounse(fun, delay) &#123;
    let timer;
    // 设置一个 timer
    return function (args) &#123;
      let _this = this
      // 取debounce执行作用域的this
      let _args = args
      clearTimeout(timer)
      timer = setTimeout(function () &#123;
        fun.call(_this, args);
      &#125;, delay);
    &#125;
  &#125;

  let inputValue1 = document.querySelector(&#39;.debounce&#39;)

  let debounse_ajax = debounse(ajax, 500)

  inputValue1.addEventListener(&#39;keyup&#39;, function (e) &#123;
    debounse_ajax(e.target.value)
  &#125;)

  /**********************节流********************************/

  function throttle(fun, delay) &#123;
    let last, timer
    return function (args) &#123;
      let _this = this
      let _args = args
      let now = +new Date()
      if (last &amp;&amp; now &lt; last + delay) &#123;
        clearTimeout(timer)
        timer = setTimeout(function () &#123;
          last = now
          fun.apply(_this, _args)
        &#125;, delay)
      &#125; else &#123;
        last = now
        fun.apply(_this, _args)
      &#125;
    &#125;
  &#125;

  let inputValue2 = document.querySelector(&#39;.htrottle&#39;)

  let htrottle_ajax = throttle(ajax, 2000)

  inputValue2.addEventListener(&#39;keyup&#39;, function (e) &#123;
    htrottle_ajax(e.target.value)
  &#125;)
&lt;/script&gt;

&lt;/html&gt;</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>防抖节流</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript作用域&amp;可执行上下文</title>
    <url>/2020/11/16/JavaScript/03%20-%20JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<blockquote>
<p>JavaScript深入 - 作用域相关问题</p>
</blockquote>
<a id="more"></a>

<h3 id="01-什么是作用域"><a href="#01-什么是作用域" class="headerlink" title="01 / 什么是作用域?"></a>01 / 什么是作用域?</h3><p><strong>作用域是指程序源代码中定义变量的区域:</strong></p>
<ul>
<li>作用域规定了当前执行代码对变量的访问权限</li>
<li>JavaScript采用词法作用域(静态作用域)</li>
</ul>
<h3 id="02-词法作用域和静态作用域的区别"><a href="#02-词法作用域和静态作用域的区别" class="headerlink" title="02 / 词法作用域和静态作用域的区别?"></a>02 / 词法作用域和静态作用域的区别?</h3><ul>
<li>静态作用域:    函数的作用域在函数定义的时候就已经决定了</li>
<li>动态作用域: 函数的作用域在函数调用的时候才决定</li>
</ul>
<h3 id="03-作用域包含两种"><a href="#03-作用域包含两种" class="headerlink" title="03 / 作用域包含两种:"></a>03 / 作用域包含两种:</h3><ul>
<li>全局作用域<ul>
<li>最外层函数和在最外层函数外面定义的变量拥有全局作用域</li>
<li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li>
<li>所有 window 对象的属性拥有全局作用域</li>
</ul>
</li>
<li>函数作用域<ul>
<li>指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到</li>
</ul>
</li>
<li>块级作用域<ul>
<li>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>作用域&amp;可执行上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器解析js流程</title>
    <url>/2020/11/16/JavaScript/05%20-%20JavaScript-%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF(Event%20Loop)/</url>
    <content><![CDATA[<blockquote>
<h4> 
 浏览器解析js流程
</h4>
</blockquote>
<a id="more"></a>
<h4 id="JS解析"><a href="#JS解析" class="headerlink" title="JS解析"></a>JS解析</h4><p><a href="https://imgchr.com/i/BufjDe"><img src="https://s1.ax1x.com/2020/10/26/BufjDe.png" alt="BufjDe.png"></a></p>
<p>js解析是由浏览器    </p>
<p>js是单线程运行,也就是说同时只能做一件事,所有任务都需要排队,</p>
<p>为了解决某些任务比较耗时,需要一种机制来使其可以执行排在后面的任务,就出现了同步任务和异步任务</p>
<p>JS执行机制可以看做一个主线程加上一个任务队列.</p>
<p>同步任务就是主线程上面执行的任务 , 异步任务就是放在任务队列的任务</p>
<p>所有的同步任务都在主线程上面执行,形成一个执行栈</p>
<p>异步任务有了运行结果就会在任务队列中放置一个事件,脚本运行时依次运行执行栈,然后会从任务队列中提取事件,</p>
<p>运行任务队列中的任务,该过程是不断重复的,所以又叫<strong>做事件循环</strong>(Event loop)</p>
<ul>
<li>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。</li>
<li>请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。</li>
<li>原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。</li>
<li>CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>浏览器解析js流程</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入URL到页面加载发生了什么</title>
    <url>/2020/11/16/JavaScript/06%20-%20%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<h4> 
 从输入URL到页面加载发生了什么???
</h4>
</blockquote>
<a id="more"></a>



<p>总体来说分为以下几个过程:</p>
<ul>
<li><a href="#01-dns%E8%A7%A3%E6%9E%90">01/ DNS解析</a><ul>
<li><a href="#dns%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B">DNS解析过程</a></li>
</ul>
</li>
<li><a href="#02-tcp%E8%BF%9E%E6%8E%A5">02 /TCP连接</a></li>
<li><a href="#03-%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82">03 /发送HTTP请求</a></li>
<li><a href="#04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%B9%B6%E8%BF%94%E5%9B%9Ehttp%E6%8A%A5%E6%96%87">04 /服务器处理请求并返回HTTP报文</a></li>
<li><a href="#05-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2">05 /浏览器解析渲染页面</a></li>
</ul>
<h3 id="01-DNS解析"><a href="#01-DNS解析" class="headerlink" title="01/ DNS解析"></a>01/ DNS解析</h3><p>DNS解析的过程就是在寻找哪台机器上有你需要的资源的全过程.<br>当你在浏览器中输入一个地址时,将网址转换为IP的过程叫做DNS解析</p>
<h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS解析本质上是一个递归查询的过程</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAFZeU.png"></p>
<p>上图是查找<code>www.google.com</code>这个网址的过程</p>
<ol>
<li>在<code>本地域名服务器</code>中查询IP地址–&gt;无</li>
<li><code>本地域名服务器</code>向<code>根域名服务器</code>发送请求–&gt;无</li>
<li><code>本地域名服务器</code> 向<code>COM顶级域名服务器</code>发送请求–&gt;无</li>
<li>……</li>
<li>最后本地服务器得到Google的IP的字号并缓存到本地,功下次使用</li>
</ol>
<p>由上可以看出网址解析是一个 从右到左的过程:<br><code>com</code> –&gt; <code>google.com</code> –&gt; <code>www.google.com</code><br>根域名服务器呢?<br>默认情况下所有网址最后一位都是. , 即<code>www.google.com.</code>,方便用户一般都会省略,浏览器在请求DNS的时候会自动加上,<br>即NDS解析流程:<br><code>.</code>–&gt;<code>com.</code>–&gt;<code>google.com.</code>–&gt;<code>www.google.com.</code></p>
<h3 id="02-TCP连接"><a href="#02-TCP连接" class="headerlink" title="02 /TCP连接"></a>02 /TCP连接</h3><p>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p>
<p>三次握手:</p>
<ul>
<li>主机A向主机B发送TCP连接请求数据包</li>
<li>主机B收到请求后，会发回连接确认数据包。 </li>
<li>第三次，主机A收到主机B的确认报文后，还需作出确认，即发送一个序列号seq(A)=x+1；确认号为ack(A)=y+1的报文；</li>
</ul>
<p>四次挥手:(假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下)</p>
<ul>
<li>客户端向服务端发送关闭链接的请求</li>
<li>服务器收到请求之后,回复这个请求并确认</li>
<li>服务端也发送一个关闭链接的请求给客户端</li>
<li>客户端收到请求之后确认关闭然后断开tcp链接</li>
</ul>
<h3 id="03-发送HTTP请求"><a href="#03-发送HTTP请求" class="headerlink" title="03 /发送HTTP请求"></a>03 /发送HTTP请求</h3><ul>
<li>HTTP报文是包裹在tcp报文中发送的,服务端收到TCP报文时会解包提取出HTTP报文,但是该过程存在一定风险,HTTP报文是明文,如果中间被截取的话会存在一些信息泄露的风险</li>
<li>HTTPS协议本质就是HTTP+SSL,在HTTP报文进入TCP报文之前,先使用SSL报文进行加密.从网络层的结构看它位于HTTP协议与TCP协议之间<br><a href="https://imgchr.com/i/BunpMn"><img src="https://s1.ax1x.com/2020/10/26/BunpMn.png" alt="BunpMn.png"></a></li>
</ul>
<p><strong>HTTPS过程:</strong></p>
<p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TSL/SSL握手),在握手的过程中将确立对方家里传输数据的密码信息.TLS/SSL使用了非对称加密,对称加密以及hash等.</p>
<p>HTTPS相对于HTTP,虽然提供了安全保证,但势必会造成一些时间上的损耗,如握手和加密等过程,使用前需要做好安全和性能方面的权衡</p>
<p><strong>HTTP请求:</strong></p>
<p>http请求主要发生在客户端.发送http请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080,HTTPS协议443)<br>http请求报文由三部分组成</p>
<ul>
<li><p>请求行 ( 常用方法有get,post,put,delete…等)</p>
</li>
<li><p>请求报头(请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息)</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAklNQ.png"></p>
<blockquote>
<p>上图是使用Chrome开发者工具截取的对百度的HTTP请求以及响应报文，从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</p>
</blockquote>
</li>
<li><p>请求正文(客户端向服务端传递的数据)</p>
<blockquote>
<p>上图是使用Chrome开发者工具截取的对百度的HTTP请求以及响应报文，从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</p>
</blockquote>
<h3 id="04-服务器处理请求并返回HTTP报文"><a href="#04-服务器处理请求并返回HTTP报文" class="headerlink" title="04 /服务器处理请求并返回HTTP报文"></a>04 /服务器处理请求并返回HTTP报文</h3><p>HTTP响应报文也是由三部分组成: <strong>状态码</strong>, <strong>响应报头</strong>和<strong>响应报文</strong>。</p>
</li>
</ul>
<p><strong>状态码</strong><br>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p>
<ul>
<li>1xx:指示信息 - 表示请求已接收,继续处理</li>
<li>2xx:成功 - 表示请求已被成功接收,理解,处理</li>
<li>3xx:重定向 -  要完成请求必须进行更进一步的操作</li>
<li>4xx:客户端错误 - 请求有语法错误或请求无法实现.</li>
<li>5xx:服务端错误 - 服务器未能实现合法请求</li>
</ul>
<p><strong>常见错误码:</strong></p>
<ul>
<li>200:请求成功</li>
<li>204:无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li>
<li>301:永久移动。请求的资源已被永久的重定向到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li>
<li>302:临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li>
<li>304:未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>
<li>400:客户端请求的语法错误，服务器无法理解</li>
<li>401:请求要求用户的身份认证</li>
<li>403:服务器理解请求客户端的请求，但是拒绝执行此请求</li>
<li>404:服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li>
<li>422:请求格式正确，但是由于含有语义错误，无法响应。</li>
<li>500:服务器内部错误，无法完成请求</li>
</ul>
<h3 id="05-浏览器解析渲染页面"><a href="#05-浏览器解析渲染页面" class="headerlink" title="05 /浏览器解析渲染页面"></a>05 /浏览器解析渲染页面</h3><p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。</p>
<p><img src="https://s3.ax1x.com/2020/11/16/DAAsIg.png"></p>
<p>浏览器是一个边解析边渲染的过程。</p>
<ul>
<li>首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</li>
<li>这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;</li>
<li>当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。</li>
<li>页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</li>
</ul>
<p>该过程涉及到两个概念 : <strong>重绘</strong>,<strong>回流</strong></p>
<ul>
<li>**回流:**DOM节点中的各个元素都是以盒模型的形式存在,需要浏览器来计算其位置和大小等,该过程叫做回流</li>
<li>**重绘:**当盒模型的位置,大小以及其他属性,如颜色,字体等确定下来之后,浏览器就开始绘制内容,该过程叫做重绘</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>从输入URL到页面加载发生了什么</tag>
      </tags>
  </entry>
  <entry>
    <title>Promise</title>
    <url>/2020/11/15/JavaScript/09%20-%20JavaScript-Promise/</url>
    <content><![CDATA[<blockquote>
<h4> 
前端异步处理之 - Promise vs async/await
</h4>
</blockquote>
<a id="more"></a>

<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="1-js回调地狱"><a href="#1-js回调地狱" class="headerlink" title="1/ js回调地狱"></a>1/ js回调地狱</h4><blockquote>
<p>在开发过程中我们经常遇到这种情况: </p>
<p>异步js或使用回调的js很难直观地得到正确的结果 , 一个异步函数的输出是另外一个异步函数的输入,如果嵌套层数过多，可读性和可以维护性都会变得很差，产生所谓的“回调地狱</p>
</blockquote>
<pre><code>let fs = require(&#39;fs&#39;)

fs.readFile(&#39;./name.txt&#39;,&#39;utf8&#39;,function(err,data)&#123;
  fs.readFile(data, &#39;utf8&#39;,function(err,data)&#123;
    fs.readFile(data,&#39;utf8&#39;,function(err,data)&#123;
      console.log(data);
    &#125;)
  &#125;)
&#125;)</code></pre>
<p>总结一下回调地狱出现的原因:</p>
<ul>
<li><strong>嵌套调用</strong>，第一个函数的输出往往是第二个函数的输入；<ul>
<li><strong>处理多个异步请求并发</strong>，开发时往往需要同步请求最终的结果;</li>
</ul>
</li>
</ul>
<h4 id="2-怎么处理回调地狱"><a href="#2-怎么处理回调地狱" class="headerlink" title="2/ 怎么处理回调地狱"></a>2/ 怎么处理回调地狱</h4><ul>
<li><strong>消灭嵌套调用</strong>：通过 Promise 的链式调用可以解决(.then())；</li>
<li><strong>合并多个任务的请求结果</strong>：使用 Promise.all 获取合并多个任务的错误处理。</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="1-什么是promise"><a href="#1-什么是promise" class="headerlink" title="1.什么是promise?"></a>1.什么是promise?</h4><p><img src="https://s3.ax1x.com/2020/11/13/DS4cZt.png"><br> 如上图所示,Promise是一个构造函数,身上有</p>
<ul>
<li><p>all()</p>
</li>
<li><p>reject()</p>
</li>
<li><p>resolve()几个方法,</p>
</li>
</ul>
<p>prototype上有</p>
<ul>
<li>then()</li>
<li>catch()等方法</li>
</ul>
<h4 id="2-Promise的特征"><a href="#2-Promise的特征" class="headerlink" title="2.Promise的特征"></a>2.Promise的特征</h4><ul>
<li>对象的状态不受外界影响,<code>Promise</code>对象代表一个异步操作，有下面这三种状态,只有异步操作可以决定当前是哪种状态<ul>
<li>pending(进行中)</li>
<li>fulfilled(成功)</li>
<li>rejected(失败)</li>
</ul>
</li>
<li>状态一旦改变, 结果就不再变化,Promise状态只可能会出现下面两种情况<ul>
<li>pending —&gt; fulfilled</li>
<li>pending —&gt; rejected</li>
</ul>
</li>
</ul>
<p><strong><code>Promise</code>的优点：</strong></p>
<p><strong>可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</strong></p>
<h4 id="3-Promise怎么创建"><a href="#3-Promise怎么创建" class="headerlink" title="3.Promise怎么创建?"></a>3.Promise怎么创建?</h4><ul>
<li><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 <code>JavaScript</code> 引擎提供，不用自己部署</li>
<li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li>
<li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code>变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>
</ul>
<pre><code class="js">let promise = new Promise((resolve, reject) =&gt; &#123;
  //此处执行一些异步操作（调用后台API，定时器等）
  if (/*异步操作成功*/) &#123;
    resolve(value);
  &#125; else &#123;
    reject(error)
  &#125;
&#125;)</code></pre>
<ul>
<li><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。</li>
<li>其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</li>
</ul>
<pre><code>promise.then(res=&gt;&#123;
    //对于成功回调接受的数据做处理
&#125;,err=&gt;&#123;
    //对于失败的回调数据做处理
&#125;)</code></pre>
<h4 id="4-实现一个符合PromiseA-规范的Promise"><a href="#4-实现一个符合PromiseA-规范的Promise" class="headerlink" title="4. 实现一个符合PromiseA+规范的Promise"></a>4. 实现一个符合PromiseA+规范的Promise</h4><p>该版本只能简单实现处理同步/异步函数, then的链式调用并没有真正实现…需要再做研究</p>
<pre><code>//1.先定义三个状态
const PENDING = &quot;PENDING&quot;;
const FULFILLED = &quot;FULFILLED&quot;;
const REJECTED = &quot;REJECTED&quot;;
//2.clss实例化一个promise
class Promise &#123;
  constructor(executor) &#123;
    this.status = PENDING;
    //存放成功状态
    this.success = undefined;
    //存放失败状态
    this.error = undefined;

    // 存放成功的回调
    this.onResolvedCallbacks = [];
    // 存放失败的回调
    this.onRejectedCallbacks = [];

        //3.实现resolve , reject
    let resolve = (value) =&gt; &#123;
      if (this.status === PENDING) &#123;
        this.status = FULFILLED;
        this.success = value;
        //这句话的意思是把存储起来的异步回调也执行掉
        this.onResolvedCallbacks.forEach(fn =&gt; fn());
      &#125;
    &#125;

    let reject = (error) =&gt; &#123;
      if (this.status === PENDING) &#123;
        this.status = REJECTED;
        this.error = error;
        this.onRejectedCallbacks.forEach(fn =&gt; fn());
      &#125;
    &#125;

     //异常捕获
    try &#123;
      executor(resolve, reject)
    &#125; catch (error) &#123;
      reject(error)
    &#125;
  &#125;

    //4.实现then方法
  then(onFulfilled, onRejected) &#123;
    if (this.status === FULFILLED) &#123;
      return onFulfilled(this.success)
    &#125;
    if (this.status === REJECTED) &#123;
      return onRejected(this.error)
    &#125;
    if (this.status === PENDING) &#123;
      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onResolvedCallbacks.push(() =&gt; &#123;
        onFulfilled(this.success)
      &#125;);
      this.onRejectedCallbacks.push(() =&gt; &#123;
        onRejected(this.error);
      &#125;)
    &#125;
  &#125;
&#125;

//测试demo
let promise = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&#39;ok&#39;)
  &#125;, 2000)
&#125;).then((success) =&gt; &#123;
  console.log(&#39;success&#39;, success)
&#125;, (error) =&gt; &#123;
  console.log(&#39;error&#39;)
&#125;)

// success ok</code></pre>
<h4 id="5-async-await"><a href="#5-async-await" class="headerlink" title="5. async/await"></a>5. async/await</h4><blockquote>
<p>一种相对Promise更为优雅的异步函数处理方案</p>
</blockquote>
<p>5.1    什么是async/await</p>
<ul>
<li><code>async</code>是异步的意思</li>
<li><code>await</code>有等待的意思</li>
<li><code>async</code>用于申明一个<code>function</code>是异步的，而<code>await</code> 用于等待一个异步方法执行完成。</li>
</ul>
<p>5.2     使用</p>
<pre><code>async getAjaxData()&#123;
    let res = await sendAjax()
&#125;</code></pre>
<p>5.3 注意事项</p>
<pre><code>- await操作符等的是一个返回的结果，那么如果是同步的情况，那就直接返回了。
- 如果是异步的情况下，await会阻塞整一个流程，直到结果返回之后，才会继续下面的代码。
阻塞代码是一个很可怕的事情，而async函数，会被包在一个promise中，异步去执行。所以await只能在async函数中使用，如果在正常程序中使用，会造成整个程序阻塞，得不偿失。</code></pre>
<h4 id="6-Promise-和-async-await区别"><a href="#6-Promise-和-async-await区别" class="headerlink" title="6.Promise 和 async/await区别"></a>6.Promise 和 async/await区别</h4><p>直接上代码</p>
<ul>
<li>Promise版本</li>
</ul>
<pre><code>function doIt() &#123;
    console.time(&quot;doIt&quot;);
    const time1 = 300;
    step1(time1)
        .then(time2 =&gt; &#123;
            return step2(time1, time2)
                .then(time3 =&gt; [time1, time2, time3]);
        &#125;)
        .then(times =&gt; &#123;
            const [time1, time2, time3] = times;
            return step3(time1, time2, time3);
        &#125;)
        .then(result =&gt; &#123;
            console.log(`result is $&#123;result&#125;`);
            console.timeEnd(&quot;doIt&quot;);
        &#125;);
&#125;

doIt();</code></pre>
<ul>
<li>async / await 版本</li>
</ul>
<pre><code>async function doIt() &#123;
    console.time(&quot;doIt&quot;);
    const time1 = 300;
    const time2 = await step1(time1);
    const time3 = await step2(time1, time2);
    const result = await step3(time1, time2, time3);
    console.log(`result is $&#123;result&#125;`);
    console.timeEnd(&quot;doIt&quot;);
&#125;

doIt();</code></pre>
<p>更详细的可以参考:</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/288384170">&lt;&lt;你不知道的promise&gt;&gt;</a></li>
<li><a href="https://juejin.im/post/6844903843507994632">&lt;&lt;学习Promise基础及手写Promise&gt;&gt;</a></li>
<li><a href="https://juejin.im/post/6844903960910757902">&lt;&lt;理解async/await&gt;&gt;</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝浅拷贝</title>
    <url>/2020/11/15/JavaScript/JavaScript-%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<blockquote>
<h4> 
 深拷贝浅拷贝
</h4>
</blockquote>
<a id="more"></a>

<p><a href="https://juejin.im/post/6844903929705136141">https://juejin.im/post/6844903929705136141</a></p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote>
<p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。</p>
<p>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
</blockquote>
<p>浅拷贝只拷贝一层属性,无法拷贝引用数据类型</p>
<ul>
<li><code>Object.assign(&#123;&#125;,obj)</code>浅拷贝object</li>
<li><code>newobj = &#123;...obj2&#125;</code>  展开运算符浅拷贝</li>
<li><code>Object.fromEntries( Object.entriens(obj) ) </code>通过生成迭代器,在通过迭代器生成对象</li>
<li><code>Object.create(&#123;&#125;,Object.getOwnPropertyDescriptors(obj))</code></li>
</ul>
<p><strong>简单浅拷贝:</strong></p>
<pre><code>function clone(target)&#123;
    let cloneTarget=&#123;&#125;;
    for(let key in target)&#123;
        cloneTarget[key] = target[key]
    &#125;
    return cloneTarget
&#125;</code></pre>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote>
<p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p>
</blockquote>
<ul>
<li><code>JSON.parse(JSON.stringfy( obj ))</code>通过<strong>JSON的2次转换深拷贝obj</strong><ul>
<li>无法拷贝<code>undefined</code>与<code>symbol</code>属性</li>
<li>无法拷贝<strong>循环引用</strong>对象</li>
</ul>
</li>
<li>loadsh:<a href="http://lodash.think2011.net/cloneDeep"><em>.cloneDeep</em></a></li>
</ul>
<p>简单深拷贝(可以处理<strong>原始数据类型 + Object</strong>):</p>
<ul>
<li>如果是原始类型，无需继续拷贝，直接返回</li>
<li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行深拷贝后依次添加到新对象上。</li>
</ul>
<pre><code>function smpleDeepCopy(target) &#123;
  let type = typeof target
  if (type === &quot;object&quot;) &#123;
    let copy = &#123;&#125;;
    for (let key in target) &#123;
      copy[key] = smpleDeepCopy(target[key])
    &#125;
    return copy
  &#125;
  return target
&#125;</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>深拷贝浅拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2020/11/12/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<p>[1/二维数组中的查找](#1/ 二维数组中的查找)</p>
<p>[2/ 替换空格](#2/ 替换空格)</p>
<h4 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1/ 二维数组中的查找"></a>1/ 二维数组中的查找</h4><blockquote>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>demo:</p>
<ul>
<li><p>输入</p>
<pre><code>7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code></pre>
</li>
<li><p>输出</p>
<pre><code>true</code></pre>
</li>
</ul>
</blockquote>
<pre><code>function Find(target, array) &#123;
  for(let i=0;i&lt;array.length;i++)&#123;
    if(array[i].indexOf(target)!==-1)&#123;
      return true
    &#125;
  &#125;
  return false
&#125;</code></pre>
<h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2/ 替换空格"></a>2/ 替换空格</h4><blockquote>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<pre><code>function replaceSpace(str)
&#123;
  return str.replace(/ /g,&#39;%20&#39;)
&#125;</code></pre>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习</title>
    <url>/2020/11/09/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h4 id="React基础知识汇总"><a href="#React基础知识汇总" class="headerlink" title="React基础知识汇总"></a>React基础知识汇总</h4><p>[TOC]</p>
<a id="more"></a>

<h4 id="01-生命周期"><a href="#01-生命周期" class="headerlink" title="01 / 生命周期"></a>01 / 生命周期</h4><p><strong>react15生命周期</strong><img src="https://s1.ax1x.com/2020/11/10/BLFB1P.png"></p>
<p>React的生命周期就是组件从初始化到卸载到全过程，可以分为以下几个阶段</p>
<ul>
<li>初始化阶段(<ul>
<li><strong>constructor()</strong>, </li>
<li><strong>componentWillMount</strong>(),</li>
<li><strong>render</strong>(), </li>
<li><strong>componentDidMount</strong>()</li>
</ul>
</li>
<li>更新阶段<ul>
<li><strong>componentWillReceiveProps</strong>(),</li>
<li><strong>shouldComponentUpdate</strong>(), </li>
<li><strong>componentWillUpdate</strong>(), </li>
<li><strong>render</strong>(), </li>
<li><strong>componentDidUpdate</strong>()</li>
</ul>
</li>
<li>卸载阶段<ul>
<li><strong>componentWillUnmont</strong>()</li>
</ul>
</li>
</ul>
<p>这里需要注意的是更新阶段，componentWillReceiveProps是由父组件触发的更新，只要父组件更新，子组件的该生命周期就会被执行，跟props无关。同是，shouldComponentUpdate可以用来做性能优化</p>
<p><strong>react16生命周期</strong></p>
<p><img src="https://s1.ax1x.com/2020/11/10/BLkabF.png"></p>
<p>在React16的生命周期中，去掉了曾经的<strong>componentWillMount</strong>和<strong>componentWillUpdate</strong>，使用<strong>getDerivedStateFromProps</strong>代替这两个方法。同时在更新阶段的render方法和componentDidUpdate之间，新增了一个<strong>getSnapshotBeforeUpdate</strong>方法。接下来就来详细了解一下React这么做的原理以及这些新增生命周期的具体使用</p>
<p><strong>react15和react16的区别</strong></p>
<ul>
<li><h6 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLu3c9.png"></p>
<ul>
<li><p><code>-</code>    componentWillMount()</p>
</li>
<li><p><code>+</code>    getDerivedStateFromProps()</p>
<ol>
<li><p>getDerivedStateFromProps() 主要用于替换 componentWillReceiveProps() 的</p>
</li>
<li><p>getDerivedStateFromProps是一个静态方法 , 需要使用static声明</p>
</li>
<li><p>getDerivedStateFromProps 接收两个参数, 父组件传递过来的props和自身state</p>
</li>
<li><p>必须返回一个对象格式的返回值，否则控制台会被警告</p>
</li>
<li><p>该返回值会被用来更新现有state(并不会覆盖原有State，只做定向更新，如果原来State中没有该属性，则新增)，如果没有需要更新的时候，请记得返回一个null</p>
<pre><code>static getDerivedStateFromProps(props,state)&#123;
  return newState
&#125;</code></pre>
</li>
</ol>
</li>
</ul>
</li>
<li><h6 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLMPMj.png"></p>
<ul>
<li><code>-</code>componentWillReceiveProps()</li>
<li><code>+</code>getDerivedStateFormProps()</li>
<li><code>-</code>componentWillupdate()</li>
<li><code>+</code>getSnapshotBetforeupdate()</li>
</ul>
</li>
</ul>
<p>React16中也去掉了componentWillUpdate方法，新增了getSnapshotBeforeUpdate方法，这个方法在render方法之后，componentDidUpdate之前被执行，即真实DOM更新之前（获取更新前的真实DOM和更新前后的State&amp;props信息）。该方法需要一个返回值，作为componentDidUpdate的第三个参数。</p>
<ul>
<li><h6 id="componentWillReceiveProps-和getDerivedStateFormProps-区别"><a href="#componentWillReceiveProps-和getDerivedStateFormProps-区别" class="headerlink" title="componentWillReceiveProps()和getDerivedStateFormProps()区别"></a>componentWillReceiveProps()和getDerivedStateFormProps()区别</h6></li>
</ul>
<table>
<thead>
<tr>
<th>getDerivedStateFormProps( props , state )</th>
<th>componentWillReceiveProps( nextPorps )</th>
</tr>
</thead>
<tbody><tr>
<td>使用static 声明: <code>static getDerivedStateFormProps( props , state )&#123;&#125;</code></td>
<td>直接声明: <code>componentWillReceiveProps( nextPorps )&#123;&#125;</code></td>
</tr>
<tr>
<td><strong>在组件挂载阶段即可执行,父组件更新执行</strong></td>
<td><strong>只在父组件更新的时候执行</strong></td>
</tr>
<tr>
<td>接收两个参数:  props  ,  state</td>
<td>接收一个参数( nextPorps )</td>
</tr>
<tr>
<td><strong>必须返回一个对象格式的返回值 或 null</strong></td>
<td><strong>可以直接更新state状态</strong></td>
</tr>
</tbody></table>
<p><strong>demo:</strong></p>
<pre><code>  static getDerivedStateFromProps(props, state) &#123;
    if (props.age !== state.age) &#123;
      return &#123; age: props.age &#125;
      // 类似setStae
      // this.setState(&#123;
      //   age: props.age
      // &#125;);
    &#125;
    return null
  &#125;</code></pre>
<pre><code>  componentWillReceiveProps(nextporps) &#123;
    if (nextporps.age !== this.state.age) &#123;
      this.setState(&#123;
        age: nextporps.age 
      &#125;);
    &#125;
  &#125;</code></pre>
<h4 id="02-Virtual-Dom"><a href="#02-Virtual-Dom" class="headerlink" title="02 / Virtual Dom"></a>02 / Virtual Dom</h4><ul>
<li><p>什么是Virtual Dom?</p>
<ul>
<li>在原生的<code>JavaScript</code>程序中，我们直接对<code>DOM</code>进行创建和更改，而<code>DOM</code>元素通过我们监听的事件和我们的应用程序进行通讯。</li>
<li><code>React</code>会先将你的代码转换成一个<code>JavaScript</code>对象，然后这个<code>JavaScript</code>对象再转换成真实<code>DOM</code>。这个<code>JavaScript</code>对象就是所谓的虚拟<code>DOM</code>。</li>
<li>当我们需要创建或更新元素时，<code>React</code>首先会让这个<code>VitrualDom</code>对象进行创建和更改，然后再将<code>VitrualDom</code>对象渲染成真实<code>DOM</code>；</li>
<li>当我们需要对<code>DOM</code>进行事件监听时，首先对<code>VitrualDom</code>进行事件监听，<code>VitrualDom</code>会代理原生的<code>DOM</code>事件从而做出响应。</li>
</ul>
</li>
<li><p>为什么使用虚拟dom?</p>
<ul>
<li><p>可以提高开发效率</p>
<pre><code>使用JavaScript，我们在编写应用程序时的关注点在于如何更新DOM。

使用React，你只需要告诉React你想让视图处于什么状态，React则通过VitrualDom确保DOM与该状态相匹配。你不必自己去完成属性操作、事件处理、DOM更新，React会替你完成这一切。

这让我们更关注我们的业务逻辑而非DOM操作，这一点即可大大提升我们的开发效率。</code></pre>
</li>
<li><p>性能提升?(有一些矛盾)</p>
<pre><code>- 直接说虚拟DOM可以提升性能这种说法是很片面的,直接操作dom非常耗费性能这一点毋庸置疑,但是react同样也无法避免操作dom
-    如果是首次渲染,virtualDom不具有任何优势,甚至要进行更多的计算和耗费更多的内存
- virtualDOm优势在于diff算法和批量处理策略,在react页面更新之前,已经提前计算好了如何更新和渲染dom,减少重绘回流,因此可以理解为提升了性能</code></pre>
</li>
<li><p>跨浏览器兼容</p>
<pre><code>virtualDom自己实现了一套事件机制,模拟了事件捕获和冒泡的过程,采用了事件代理和批量更新的方法,可以抹平各浏览器事件处理不兼容的问题</code></pre>
</li>
</ul>
</li>
<li><p>React组件的渲染流程</p>
<ul>
<li><p>使用<code>React.createElement</code>或<code>JSX</code>编写<code>React</code>组件，<code>Babel</code>帮助我们把所有的<code>JSX </code>代码最后都会转换成<code>React.createElement(...) </code>格式</p>
<ul>
<li><p>JSX编写</p>
<pre><code>class Hello extends Component &#123;
  render() &#123;
    return &lt;div&gt;Hello ConardLi&lt;/div&gt;;
  &#125;
&#125;</code></pre>
</li>
<li><p><code>React.createElement</code>编写</p>
<pre><code>class Hello extends Component &#123;
  render() &#123;
    return React.createElement(&#39;div&#39;, null, `Hello ConardLi`);
  &#125;
&#125;</code></pre>
</li>
<li><p><code>Babel</code>转化demo</p>
<pre><code>&lt;div&gt;
  &lt;img src=&quot;avatar.png&quot; className=&quot;profile&quot; /&gt;
  &lt;Hello /&gt;
&lt;/div&gt;;</code></pre>
<pre><code>React.createElement(&quot;div&quot;, null, 
    React.createElement(&quot;img&quot;, &#123;
      src: &quot;avatar.png&quot;,
      className: &quot;profile&quot;
    &#125;), 
    React.createElement(Hello, null)
);</code></pre>
</li>
</ul>
</li>
<li><p><code>createElement</code>函数对<code>key</code>和<code>ref</code>等特殊的<code>props</code>进行处理，并获取<code>defaultProps</code>对默认<code>props</code>进行赋值，并且对传入的孩子节点进行处理，最终构造成一个<code>ReactElement</code>对象（所谓的虚拟<code>DOM</code>）。</p>
</li>
<li><p><code>ReactDOM.render</code>将生成好的虚拟<code>DOM</code>渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实<code>DOM</code>。</p>
</li>
</ul>
</li>
</ul>
<p>​    </p>
<ul>
<li><p>virtualDom的组成</p>
<p>即<code>ReactElement</code>element对象，我们的组件最终会被渲染成下面的结构</p>
<ul>
<li><code>type</code>：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或<code>class</code>）</li>
<li><code>key</code>：组件的唯一标识，用于<code>Diff</code>算法</li>
<li><code>ref</code>：用于访问原生<code>dom</code>节点</li>
<li><code>props</code>：传入组件的<code>props</code>，<code>chidren</code>是<code>props</code>中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点）</li>
<li><code>owner</code>：当前正在构建的<code>Component</code>所属的<code>Component</code></li>
<li><code>self</code>：（非生产环境）指定当前位于哪个组件实例</li>
<li><code>_source</code>：（非生产环境）指定调试代码来自的文件(<code>fileName</code>)和代码行数(<code>lineNumber</code>)</li>
</ul>
<p>例如;</p>
<pre><code>&lt;div class=&quot;title&quot;&gt;
      &lt;span&gt;Hello ConardLi&lt;/span&gt;
      &lt;ul&gt;
        &lt;li&gt;苹果&lt;/li&gt;
        &lt;li&gt;橘子&lt;/li&gt;
      &lt;/ul&gt;
&lt;/div&gt;</code></pre>
<pre><code>
const VitrualDom = &#123;
  type: &#39;div&#39;,
  props: &#123; class: &#39;title&#39; &#125;,
  children: [
    &#123;
      type: &#39;span&#39;,
      children: &#39;Hello ConardLi&#39;
    &#125;,
    &#123;
      type: &#39;ul&#39;,
      children: [
        &#123; type: &#39;li&#39;, children: &#39;苹果&#39; &#125;,
        &#123; type: &#39;li&#39;, children: &#39;橘子&#39; &#125;
      ]
    &#125;
  ]
&#125;</code></pre>
</li>
</ul>
<h4 id="03-diff算法"><a href="#03-diff算法" class="headerlink" title="03 / diff算法"></a>03 / diff算法</h4><ul>
<li>DIFF算法是DOM更新的一种算法,指页面被更新时,程序用哪种策略更新DOM</li>
<li>作用是用来计算出 <strong>Virtual DOM</strong> 中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面。</li>
</ul>
<p>DIFF算法策略:</p>
<ul>
<li><p>Tree Diff    对树每一层进行遍历，找出不同</p>
<p><img src="https://s3.ax1x.com/2020/11/17/DVYzW9.png"></p>
</li>
<li><p>Component Diff  是数据层面的差异比较</p>
</li>
<li><p>Element Diff  真实DOM渲染，结构差异的比较</p>
<ul>
<li>Diff提供三种DOM操作：<strong>删除</strong>、<strong>移动</strong>、<strong>插入</strong>。</li>
</ul>
</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/17/DVYozn.png"></p>
<h4 id="04-fiber架构"><a href="#04-fiber架构" class="headerlink" title="04 / fiber架构"></a>04 / fiber架构</h4><blockquote>
<p>fiber架构是React16对核心算法的一次重构</p>
<p>Fiber使原本同步渲染变为异步</p>
</blockquote>
<p><strong>4.1 React历史算法的风险</strong></p>
<blockquote>
<p>React16之前,组件每次更新都会触发React去构建一棵新的虚拟DOM树,通过与上一次虚拟DOM的diff对比,实现DOM的定更新</p>
<p>该过程是是一个递归的过程,调用栈非常深,只有最低层的返回了,才能逐层返回.</p>
<p>这个过程漫长且不可打断,同步一旦开始,就会牢牢抓住线程,直到递归完成,这个过程浏览器除了渲染不会再做其他事情,无法处理用户</p>
<p>交互状态,页面可能会卡死</p>
</blockquote>
<p><strong>4.2 Fiber是怎样处理渲染的？</strong></p>
<blockquote>
<p>Fiber 会将一个大的更新任务拆解为许多个小任务。</p>
<p>每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。</p>
<p>在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”</p>
</blockquote>
<p><strong>4.3 说回生命周期</strong></p>
<p>在最开始给出生命周期图的时候，细心的同学会发现，在下面这张图的左边，React又将生命周期划分了如下三个阶段</p>
<p><img src="https://s1.ax1x.com/2020/11/10/BL0HNF.png"></p>
<ul>
<li>render：纯净且没有副作用，可能会被暂停或者终止，重新启动</li>
<li>Pre-commit阶段：可以读取DOM</li>
<li>commit阶段：可以使用DOM，运行副作用，安排更新</li>
</ul>
<p><strong>4.4为什么会这样分呢？</strong></p>
<blockquote>
<p>总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。</p>
<p>为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，再狂的框架也不敢在用户眼皮子底下胡乱更改视图，所以这个过程必须用同步渲染来求稳。</p>
</blockquote>
<p><strong>4.5废除的生命周期跟Fiber之间的联系</strong></p>
<pre><code>在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。这就导致 render 阶段的生命周期都是有可能被重复执行的。

带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：

componentWillMount；

componentWillUpdate；

componentWillReceiveProps。

这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。</code></pre>
<h4 id="05-React数据传递方案"><a href="#05-React数据传递方案" class="headerlink" title="05 / React数据传递方案"></a>05 / React数据传递方案</h4><ul>
<li>组件传值</li>
<li>context</li>
<li>redux</li>
</ul>
<h4 id="06-setState之后发生什么"><a href="#06-setState之后发生什么" class="headerlink" title="06 / setState之后发生什么?"></a>06 / setState之后发生什么?</h4><p>一、React中setState后发生了什么</p>
<blockquote>
<p>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程(Reconciliation)。</p>
<p>经过调和过程，React 会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个Ul界面。</p>
<p>在React得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变,这就保证了按需更新，而不是全部重新渲染。</p>
</blockquote>
<p>二、setState 为什么默认是异步</p>
<blockquote>
<p>假如所有setState是同步的，意味着每执行一次setState时 (有可能一个同步代码中， 多次setState) 都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异 步，则可以把一一个同步代码中的多个setState合并成- -次组件更新。</p>
</blockquote>
<p>三、setState什么时候是同步</p>
<blockquote>
<p>在setTimeout或者原生事件中，setState是同步的。</p>
</blockquote>
<h4 id="7-componentWillUpdate可以直接修改state的值吗？"><a href="#7-componentWillUpdate可以直接修改state的值吗？" class="headerlink" title="7 / componentWillUpdate可以直接修改state的值吗？"></a>7 / componentWillUpdate可以直接修改state的值吗？</h4><blockquote>
<p>react组件在每次需要重新渲染时候都会调用<code>componentWillUpdate()</code>,</p>
<p>例如，我们调用 <code>this.setState()</code>时候</p>
<p>在这个函数中我们之所以不调用<code>this.setState()</code>是因为该方法会触发另一个<code>componentWillUpdate()</code>,如果我们<code>componentWillUpdate()</code>中触发状态更改,我们将以无限循环结束.</p>
</blockquote>
<h4 id="8-使用Hooks要遵守哪些原则？"><a href="#8-使用Hooks要遵守哪些原则？" class="headerlink" title="8 / 使用Hooks要遵守哪些原则？"></a>8 / 使用Hooks要遵守哪些原则？</h4><blockquote>
<ol>
<li>只在最顶层使用 Hook, 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</li>
<li>只在 React 函数中调用 Hook, 不要在普通的 JavaScript 函数中调用 Hook。</li>
<li>可以：<br>✅ 在 React 的函数组件中调用 Hook<br>✅ 在自定义 Hook 中调用其他 Hook</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React生命周期函数</title>
    <url>/2020/11/06/React/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<blockquote>
<p>​    温故而知新<del>~</del></p>
<p>​    越基础,越重要哦~</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/11/06/Bf52x1.jpg"></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-Hook学习</title>
    <url>/2020/11/06/React/React-hooks/</url>
    <content><![CDATA[<blockquote>
<p>一直都知道Hook这个新技术,但是工作过程中几乎没有用到,最近刚好有时间来学习一下<del>~</del></p>
</blockquote>
<a id="more"></a>

<h3 id="01-什么是Hook"><a href="#01-什么是Hook" class="headerlink" title="01/什么是Hook?"></a>01/什么是Hook?</h3><p>Hook是react16.8新增特性,可以在不编写class的情况下使用state以及其他React特性</p>
<h3 id="02-什么是Hook"><a href="#02-什么是Hook" class="headerlink" title="02/什么是Hook?"></a>02/什么是Hook?</h3><ul>
<li>Hook顾名思义是钩子的意思,它可以使函数组件中可以勾入React-State以及生命周期特性等等.</li>
<li>Hook不能在class组件中使用</li>
</ul>
<h3 id="03-Hook内置组件"><a href="#03-Hook内置组件" class="headerlink" title="03/Hook内置组件"></a>03/Hook内置组件</h3><ul>
<li><p><strong>useState</strong>    (用于操控state)</p>
<ul>
<li><p><strong>使用:</strong></p>
<pre><code>const [stateName , stateChangeFun] = useState(初始值)</code></pre>
<pre><code>const [count , setCount] = useState(0)
&lt;Button onClick=&#123;()=&gt;setCount(count++)&#125;&gt;Click&lt;/Button&gt;    </code></pre>
</li>
</ul>
</li>
<li><p><strong>useEffect</strong></p>
<p>Effect Hook 可以让我们在react中执行副作用操作</p>
<p><code>useEffect</code> 的第二个参数，有三种情况</p>
<ol>
<li>什么都不传，组件每次 <code>render</code> 之后 <code>useEffect</code> 都会调用，相当于 <code>componentDidMount</code> 和 <code>componentDidUpdate</code></li>
</ol>
</li>
</ul>
<ol start="2">
<li>传入一个空数组 [], 只会调用一次，相当于 <code>componentDidMount</code> 和 <code>componentWillUnmount</code><ol start="3">
<li>传入一个数组，其中包括变量，只有这些变量变动时，<code>useEffect</code> 才会执行</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF攻击</title>
    <url>/2020/11/04/Safe/CSRF%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="01-什么是CSRF攻击"><a href="#01-什么是CSRF攻击" class="headerlink" title="01/ 什么是CSRF攻击?"></a>01/ 什么是CSRF攻击?</h4><p>CSRF攻击指的是跨站请求伪造,攻击者诱导用户进入第三方网站,然后该网站向被攻击者网站发送跨站请求.</p>
<p>如果用户在被攻击者网站中保存了登录状态,攻击者就可以利用这个状态,绕过后台验证,冒充用户向服务器执行一些操作;</p>
<h4 id="02-CSRF攻击分类"><a href="#02-CSRF攻击分类" class="headerlink" title="02/ CSRF攻击分类"></a>02/ CSRF攻击分类</h4><ul>
<li>GET请求的CSRF攻击, 通常用img标签构建请求,用户打开网站的时候,自动发送请求</li>
<li>POST请求CSRF攻击,比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单</li>
<li>链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>
</ul>
<h4 id="03-防御方法"><a href="#03-防御方法" class="headerlink" title="03/ 防御方法"></a>03/ 防御方法</h4><ul>
<li>第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</li>
<li>第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</li>
<li>第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li>
<li>第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li>
<li>验证码</li>
</ul>
]]></content>
      <categories>
        <category>前端安全</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS攻击</title>
    <url>/2020/11/04/Safe/XSS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<p>前端知识回顾之 - XSS攻击</p>
<a id="more"></a>

<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><h4 id="1-什么是xss攻击"><a href="#1-什么是xss攻击" class="headerlink" title="1.什么是xss攻击"></a>1.什么是xss攻击</h4><ul>
<li>xss攻击即跨站脚本攻击,是一种恶意代码注入攻击,攻击者通过在网站上面注入恶意代码,使之在浏览器上面运行,从而获取用户的敏感信息如cookie等</li>
<li>xss的本质是因为网站没有对恶意代码进行过滤, 与正常代码混在一起,但是浏览器不能识别代码哪些可信哪些不可信,从而导致了恶意代码的执行.</li>
</ul>
<h4 id="2-XSS攻击分类"><a href="#2-XSS攻击分类" class="headerlink" title="2.XSS攻击分类"></a>2.XSS攻击分类</h4><ul>
<li><p>存储型</p>
<blockquote>
<p>存储型XSS攻击是将恶意代码提交到网站服务器中,当用户请求数据的时候,服务器将恶意代码拼接到HTML里面后返回,导致恶意代码的执行</p>
</blockquote>
</li>
<li><p>反射型</p>
<blockquote>
<p>反射型指的是某些通过url参数获取数据的网站,攻击者构建特殊的url,当服务器收到请求之后,从url中获取数据,并将其拼接为html后返回,从而导致了恶意代码的执行</p>
</blockquote>
</li>
<li><p>DOM型</p>
<blockquote>
<p>DOM型XSS攻击指的是攻击者构建了特殊的URL,当用户打开了网站之后,js脚本从url中获取数据,从而导致了恶意代码的执行</p>
</blockquote>
</li>
</ul>
<h4 id="3-如何预防XSS攻击"><a href="#3-如何预防XSS攻击" class="headerlink" title="3.如何预防XSS攻击"></a>3.如何预防XSS攻击</h4><p>​    预防XSS攻击主要有两个方案</p>
<ul>
<li><p>恶意代码提交的时候(不可靠)</p>
<blockquote>
<p>当数据即将存入数据库的时候进行转义,但是数据库的数据可能在多个地方使用,有些地方不需要转义,由于我们无法判断这些数据最后的使用场景,所以该方法是<strong>不可靠的</strong></p>
</blockquote>
</li>
<li><p>浏览器执行之前</p>
<blockquote>
<ul>
<li>使用纯前端的方式,不用服务器拼接HTML返回    </li>
<li>对需要插入的HTML进行充分的转义</li>
</ul>
</blockquote>
</li>
<li><p>对于DOM性XSS攻击还有以下几种方式</p>
<blockquote>
<ul>
<li>CSP,CSP本质是简历一个白名单,告诉浏览器哪些外部资源是可以加载和执行,从而防止恶意代码的注入攻击</li>
<li>对敏感信息进行保护,比如cookie使用http-only,禁止脚本获取cookie</li>
<li>使用验证码,防止脚本伪装用户进行操作</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="4-什么是CSP"><a href="#4-什么是CSP" class="headerlink" title="4.什么是CSP"></a>4.什么是CSP</h4><p>​    CSP指的是内容安全侧策略</p>
<p>​    他的本质是建立一个白名单,告诉浏览器哪些外部资源可以加在和执行.</p>
<p>​    <strong>开启SCP方式:</strong></p>
<ul>
<li>一种是设置 HTTP 首部中的 <code>Content-Security-Policy</code></li>
<li>一种是设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li>
</ul>
<p>详细资料可以参考： <a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p>
]]></content>
      <categories>
        <category>前端安全</category>
      </categories>
      <tags>
        <tag>前端安全</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM事件 , 事件流</title>
    <url>/2020/11/03/JavaScript/02%20-%20JavaScript-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</url>
    <content><![CDATA[<blockquote>
<h4> 
DOM事件, 事件流
</h4>
</blockquote>
<a id="more"></a>

<h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><blockquote>
<p>事件是指JavaScript与HTML交互的基础.要实现用户与页面的交互,先要对目标元素绑定特定的事件,设置事件处理函数,用户触发事件,事件处理函数执行,产生交互效果</p>
</blockquote>
<h4 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h4><p>DOM 级别分为四个级别：DOM0 级、DOM1 级、DOM2 级、DOM3 级；<br><img src="https://s1.ax1x.com/2020/10/28/B1JoY4.md.jpg" alt="B1JoY4.md.jpg"></p>
<p>DOM事件分为三个级别:<br>DOM0 级事件: 给元素绑定事件</p>
<pre><code>&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;/button&gt;
&lt;script&gt;
    var btn = document.getElementById(&#39;btn&#39;)
    btn.onclick = function() &#123;
        console.log(&#39;Hello World&#39;)
    &#125;
    // btn.onclick = null // 解绑事件
&lt;/script&gt;</code></pre>
<blockquote>
<p>   缺点：无法设置多个事件处理函数</p>
</blockquote>
<p>DOM2 级事件:用到了事件监听</p>
<pre><code>&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;/button&gt;
&lt;script&gt;
    var btn = document.getElementById(&#39;btn&#39;);    
    btn.addEventListener(&#39;click&#39;, showFn, false)
    btn.addEventListener(&#39;click&#39;, showFn2, false)
    // btn.removeEventListener(&#39;click&#39;, showFn, false) // 解绑事件 
    function showFn() &#123;
        alert(&#39;Hello World&#39;);
    &#125;
     function showFn2() &#123;
        alert(&#39;Hello World2&#39;);
    &#125; 
&lt;/script&gt;</code></pre>
<blockquote>
<p>可以为事件设置多个事件处理函数，可以通过第三个参数 ( useCapture ) 设置在什么阶段执行事件处理函数，默认是 false， 即在事件冒泡阶段执行事件处理函数。</p>
</blockquote>
<blockquote>
<p>需要注意的是在 IE8 及以下版本需要用 attachEvent 和 detachEvent 实现，只有两个参数，事件名需要以 on 开头，只支持在事件冒泡阶段执行事件处理函数。</p>
</blockquote>
<p>DOM3 级事件</p>
<blockquote>
<p>DOM3 级事件是在 DOM2 级事件的基础上添加了更多的事件类型，允许自定义事件。</p>
</blockquote>
<p>UI事件，当用户与页面上的元素交互时触发，如：load、scroll<br>焦点事件，当元素获得或失去焦点时触发，如：blur、focus<br>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup<br>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel<br>文本事件，当在文档中输入文本时触发，如：textInput<br>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress<br>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart<br>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</p>
<pre><code>// 自定义事件
var event = new Event(&#39;test&#39;)
// 给元素绑定事件
domElement.addEventListener(&#39;test&#39;, function() &#123;
    console.log(&#39;event test&#39;)
&#125;,)

// 触发事件
setTimeout(function() &#123;
    domElement.dispatchEvent(event)
&#125;, 1000)
</code></pre>
<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><blockquote>
<p>事件流又称为事件传播，描述的是从<strong>页面中接收事件的顺序</strong>。</p>
<p>DOM2 级事件规定事件流包括三个阶段: </p>
<ul>
<li>事件捕获(capturing phase)</li>
<li>目标事件(target phase)</li>
<li>事件冒泡(bubbling phase)</li>
</ul>
<p>发生的顺序是：事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段</p>
</blockquote>
<h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><blockquote>
<p>​    事件起始元素逐级向上传播</p>
</blockquote>
<pre><code>&lt;style&gt;
  #parent &#123;
      width: 200px;
      height: 200px;
      background-color: green;
  &#125;
  #child &#123;
      width: 100px;
      height: 100px;
      background-color: yellow;
  &#125;
&lt;/style&gt;

&lt;div id=&quot;parent&quot;&gt;
  &lt;div id=&quot;child&quot;&gt;目标元素&lt;/div&gt;
  父级元素
&lt;/div&gt;

&lt;script&gt;
  var parent = document.getElementById(&#39;parent&#39;)
  var child = document.getElementById(&#39;child&#39;)

  parent.addEventListener(&#39;click&#39;, function(e) &#123;
      console.log(&#39;parent bubbling&#39;)
  &#125;, false)

  child.addEventListener(&#39;click&#39;, function() &#123;
      console.log(&#39;target bubbling&#39;)
  &#125;, false)

  document.body.addEventListener(&#39;click&#39;, function() &#123;
      console.log(&#39;body bubbling&#39;)
  &#125;, false)

  document.documentElement.addEventListener(&#39;click&#39;, function() &#123;
      console.log(&#39;html bubbling&#39;)
  &#125;, false)

  document.addEventListener(&#39;click&#39;, function() &#123;
      console.log(&#39;document bubbling&#39;)
  &#125;, false)

  window.addEventListener(&#39;click&#39;, function() &#123;
      console.log(&#39;window bubbling&#39;)
  &#125;, false)
&lt;/script&gt;</code></pre>
<p>运行结果：</p>
<h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><blockquote>
<p>​    事件按 window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素 的方向向下层元素传递。</p>
</blockquote>
<pre><code>&lt;style&gt;
  #parent &#123;
      width: 200px;
      height: 200px;
      background-color: green;
  &#125;
  #child &#123;
      width: 100px;
      height: 100px;
      background-color: yellow;
  &#125;
&lt;/style&gt;

&lt;div id=&quot;parent&quot;&gt;
  &lt;div id=&quot;child&quot;&gt;目标元素&lt;/div&gt;
  父级元素
&lt;/div&gt;

&lt;script&gt;
  var parent = document.getElementById(&#39;parent&#39;)
  var child = document.getElementById(&#39;child&#39;)

  parent.addEventListener(&#39;click&#39;, function(e) &#123;
      console.log(&#39;parent capture&#39;)
  &#125;, true)

  child.addEventListener(&#39;click&#39;, function() &#123;
      console.log(&#39;target capture&#39;)
  &#125;, true)

  document.body.addEventListener(&#39;click&#39;, function() &#123;
      console.log(&#39;body capture&#39;)
  &#125;, true)

  document.documentElement.addEventListener(&#39;click&#39;, function() &#123;
      console.log(&#39;html capture&#39;)
  &#125;, true)

  document.addEventListener(&#39;click&#39;, function() &#123;
      console.log(&#39;document capture&#39;)
  &#125;, true)

  window.addEventListener(&#39;click&#39;, function() &#123;
      console.log(&#39;window capture&#39;)
  &#125;, true)
&lt;/script&gt;</code></pre>
<p>运行结果:</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>DOM事件事件流</tag>
      </tags>
  </entry>
  <entry>
    <title>一段js代码在浏览器中是如何执行的</title>
    <url>/2020/11/02/JavaScript/04%20-%20JavaScript-%E4%B8%80%E6%AE%B5js%E4%BB%A3%E7%A0%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<h3 id="一段js代码在浏览器中是如何执行的"><a href="#一段js代码在浏览器中是如何执行的" class="headerlink" title="一段js代码在浏览器中是如何执行的?"></a>一段js代码在浏览器中是如何执行的?</h3><blockquote>
<p>   在了解代码执行流程之前 , 我们需要知道一点前置知识 , </p>
<ul>
<li>js解析顺序</li>
<li>可执行代码</li>
<li>执行上下文栈<br>当我们这些前置知识都捋清楚了 , js执行流程也就清楚了…..<a id="more"></a>
</li>
</ul>
</blockquote>
<h3 id="01-JS代码执行顺序是什么"><a href="#01-JS代码执行顺序是什么" class="headerlink" title="01 / JS代码执行顺序是什么"></a>01 / JS代码执行顺序是什么</h3><p>  JavaScript代码是逐行执行的 , 但是js引擎并非一行一行的<strong>解析</strong>执行程序,而是一段一段的分析执行,为什么是分段执行的呢?又按什么规则来分段的呢?这里我们需要再了解一下什么是<strong>可执行代码</strong></p>
<p>  (Js代码是逐行执行的,但是js引擎并非逐行解析程序执行的,而是判断是否可执行代码一段一段的执行的)</p>
<h3 id="02-可执行代码-amp-执行上下文"><a href="#02-可执行代码-amp-执行上下文" class="headerlink" title="02 / 可执行代码 &amp; 执行上下文"></a>02 / 可执行代码 &amp; 执行上下文</h3><p>  可执行代码有三种,全局代码,函数代码,eval代码,当执行到可执行代码的时候,就会进行准备一些工作 . 这个准备工作就是<strong>执行上下文</strong></p>
<ul>
<li><p>全局代码</p>
</li>
<li><p>函数代码</p>
</li>
<li><p>eval代码( evla()函数可以将传入的字符串当做 JavaScript 代码进行执行 )</p>
<h3 id="05-执行上下文栈"><a href="#05-执行上下文栈" class="headerlink" title="05 / 执行上下文栈"></a>05 / 执行上下文栈</h3><p>为了管理js中大量的可执行上下文,JavaScript引擎创建了<strong>执行上下文栈</strong>来管理可执行上下文</p>
</li>
<li><p>当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈(ECStack)压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext.</p>
<pre><code>const ECStack  = [    
  globalContext 
]</code></pre>
</li>
</ul>
<ul>
<li><p>当函数开始执行的时候,同样生成一个可以执行上下文并压入可执行上下文栈,当函数执行完毕的时候,再从执行上下文栈中弹出</p>
<pre><code>const ECStack  = [
  eval()
  function()
  globalContext 
]</code></pre>
</li>
</ul>
<h3 id="06-总结"><a href="#06-总结" class="headerlink" title="06 / 总结:"></a>06 / 总结:</h3><ul>
<li>在执行一段代码时，JS 引擎会首先<strong>创建一个执行栈</strong>,然后JS引擎会创建一个<strong>全局执行上下文</strong>，并push到执行栈中</li>
</ul>
<ul>
<li>这个过程JS引擎会为这段代码中<strong>所有变量</strong>分配内存并赋一个初始值（undefined）</li>
</ul>
<ul>
<li>在创建完成后，JS引擎会进入<strong>执行阶段</strong>，这个<strong>过程JS引擎会逐行的执行代码</strong>，即为之前分配好内存的变量逐个赋值(真实值)。</li>
</ul>
<ul>
<li>如果这段代码中存在function的声明和调用，那么JS引擎会创建一个<strong>函数执行上下文</strong>，并push到执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文push到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。</li>
</ul>
<ul>
<li><p>还有一种特殊情况是，在子函数执行的过程中，父函数已经return了，这种情况下，JS引擎会将父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。</p>
<h3 id="JS引擎如何处理高并发"><a href="#JS引擎如何处理高并发" class="headerlink" title="JS引擎如何处理高并发?"></a>JS引擎如何处理高并发?</h3></li>
</ul>
<p>  <strong>JS引擎是单线程的</strong>，那么它是如何处理高并发的呢？即当代码中存在异步调用时JS是如何执行的?</p>
<p>  比如setTimeout或fetch请求都是non-blocking的，<br>  当异步调用代码触发时，JS引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push进任务队列中等待被调用，<br>  当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立刻将任务队列中的回调函数逐个push进调用栈并执行。这个过程我们也称之为<strong>事件循环</strong>。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2020/11/01/JavaScript/08%20-%20JavaScript-%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<blockquote>
<h4> 
 闭包
</h4>
</blockquote>
<a id="more"></a>

<h4 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0/前置知识:"></a>0/前置知识:</h4><p><a href="https://juntengma.github.io/2020/11/03/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F/">&lt;&lt;JavaScript作用域&amp;可执行上下文&gt;&gt;</a></p>
<h4 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1/什么是闭包?"></a>1/什么是闭包?</h4><pre><code>- 内部函数可以访问其所在的外部函数中声明的参数和变量
- 闭包找到的是同一地址中,父级函数中对应变量最终的值</code></pre>
<h4 id="2-闭包的特点"><a href="#2-闭包的特点" class="headerlink" title="2/闭包的特点"></a>2/闭包的特点</h4><pre><code>- 让外部访问函数内部变量成为可能；
-    局部变量会常驻在内存中；
- 可以避免使用全局变量，防止全局变量污染；
- 可能会造成内存泄露</code></pre>
<h4 id="3-实际使用案例"><a href="#3-实际使用案例" class="headerlink" title="3/实际使用案例"></a>3/实际使用案例</h4><ul>
<li><p>函数防抖节流</p>
<pre><code>function debounce(fun, delay) &#123;
  let timer
  return function (args) &#123;
    let _this = this
    let _args = args
      clearTimeout(timer)
    timer = setTimeout(() =&gt; &#123;
        fun.call(_this, _args)
    &#125;, delay);
  &#125;
&#125;</code></pre>
</li>
<li><p>使用闭包设计单例模式</p>
<pre><code>class CreateUser &#123;
    constructor(name) &#123;
        this.name = name;
        this.getName();
    &#125;
    getName() &#123;
         return this.name;
    &#125;
&#125;
// 代理实现单例模式
var ProxyMode = (function() &#123;
    var instance = null;
    return function(name) &#123;
        if(!instance) &#123;
            instance = new CreateUser(name);
        &#125;
        return instance;
    &#125;
&#125;)();
// 测试单体模式的实例
var a = ProxyMode(&quot;aaa&quot;);
var b = ProxyMode(&quot;bbb&quot;);
// 因为单体模式是只实例化一次，所以下面的实例是相等的
console.log(a === b);    //true</code></pre>
</li>
<li><p>为多个组件独立属性</p>
<p>假如我现在要在页面中使用echarts画6个线状图，需要6个容器 </p>
<p>需要为每个容器元素声明一个独立id,不然会混乱</p>
<pre><code> constructor()&#123;
 this.state = &#123;id: &quot;EchartsLine&quot;+Util.clourse()&#125;;
 &#125;
  componentDidMount() &#123;
      this.myEChart =echarts.init(document.getElementById(this.state.id));//不同id
  &#125;</code></pre>
<pre><code>&lt;div id=&#123;this.state.id&#125; className=&#39;echarts-line&#39;&gt;&lt;/div&gt;</code></pre>
<pre><code>clourse()&#123;
    let clourse = (function()&#123;
        var a = 1;
        return function()&#123;
            return a++;
        &#125;
    &#125;)(this);
    this.clourse = clourse;
&#125;
//使用数字命名 不用害怕被篡改</code></pre>
</li>
<li><p>设置私有变量</p>
<pre><code>let _width = Symbol();
    class Private &#123;
        constructor(s) &#123;
            this[_width] = s
        &#125;
        foo() &#123;
            console.log(this[_width])
        &#125;
    var p = new Private(&quot;50&quot;);
    p.foo();
    console.log(p[_width]);//可以拿到</code></pre>
<pre><code> //赋值到闭包里
    let sque = (function () &#123;
        let _width = Symbol();

        class Squery &#123;
            constructor(s) &#123;
                this[_width] = s
            &#125;

            foo() &#123;
                console.log(this[_width])
            &#125;
        &#125;
        return Squery
    &#125;)();
    let ss = new sque(20);
    ss.foo();
    console.log(ss[_width])</code></pre>
</li>
<li><p>拿到正确的值（老掉牙的问题了😝）</p>
<pre><code>for(var i=0;i&lt;10;i++)&#123;
    setTimeout(function()&#123;
        console.log(i)//10个10
    &#125;,1000)
&#125;</code></pre>
<pre><code>for(var i=0;i&lt;10;i++)&#123;
((j)=&gt;&#123;
  setTimeout(function()&#123;
        console.log(j)//1-10
    &#125;,1000)&#125;)(i)
&#125;</code></pre>
<p>原理是 声明了10个自执行函数，保存当时的值到内部</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>Https及其加密原理</title>
    <url>/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https/</url>
    <content><![CDATA[<p>Https协议及其加密原理</p>
<a id="more"></a>

<h2 id="1-http-协议存在的一些问题"><a href="#1-http-协议存在的一些问题" class="headerlink" title="1/http 协议存在的一些问题"></a>1/http 协议存在的一些问题</h2><ul>
<li>http报文明文发送,可能会被第三方窃听</li>
<li>http报文可能会被第三方截取之后修改通信内容,接收方没有办法发现报文内容的修改</li>
<li>http还存在认证问题,第三方可以冒充他人参与通信</li>
</ul>
<h2 id="2-Https简介"><a href="#2-Https简介" class="headerlink" title="2/Https简介"></a>2/Https简介</h2><ul>
<li>HTTPS指的是超文本传输安全协议,HTTPS是基于HTTTP协议的,不过它会使用TLS/SSL来对数据进行加密,即Http+TLS/SSL</li>
<li>使用TLS和SSL协议,所有的信息都是加密的,第三方没有办法窃听,并且他提供了一种校验机制,信息一旦被篡改,通信双方立刻就会发现</li>
<li>它还配备了身份证书,防止身份被冒充的情况出现</li>
</ul>
<h2 id="3-SSL加密方式"><a href="#3-SSL加密方式" class="headerlink" title="3/SSL加密方式"></a>3/SSL加密方式</h2><ul>
<li><p>对称加密</p>
<p><img src="https://s1.ax1x.com/2020/11/10/Bqe2dS.png"></p>
<pre><code>对称加密即客户端和服务端同时约定同一种秘钥,客户端发送信息给服务端使用该秘钥加密,服务端收到信息后在用秘钥解密,整个流程类似下面这个例子:
期末考试,小明找小红希望数学考试的时候小红可以帮他,两个人考试前约定了一把秘钥:小红把所有的答案都加上250;
小红把答案通过秘钥加密: 15 + 250 = 265 --&gt; 偷偷的丢给小明
小明通过秘钥解密: 265- 250 = 15 ---&gt; 小明得到正确答案</code></pre>
<ul>
<li>对称加密加密效率高速度快</li>
<li>但是该加密方式存在一些漏洞,假如别人获取到了加密方式,然后再用该方案来解密,那数据信息岂不是还是可以被截取修改,因此出现了非对称加密的方案</li>
</ul>
</li>
<li><p>非对称加密</p>
<p>非对称加密就是有两把密钥，公钥和私钥。私钥自己藏着，不告诉任何人；而公钥可以公开给别人。</p>
<p><img src="https://s1.ax1x.com/2020/11/10/Bqe7LV.png"></p>
<pre><code>非对称加密即通信双方各自有一个秘钥和公钥,公钥用来对信息进行加密,私钥用来对信息进行解密;
通信的时候, 公钥是随着信息一起发送给对方的,即公钥是公开的, 但是私钥是不会公开的
假如A发送信息给B:
- A把自己发送的信息连同公钥(加密方式)一起发送给B,
- B方收到信息和公钥的时候,把返回的信息通过A的公钥对信息进行加密
- 返回信息给A的同时把自己的公钥和密文一起发送给A
- A收到B的加密信息之后,再通过自己的私钥对信息进行解密,如果还需要和B进行通信,再用B的公钥加密即可</code></pre>
<ul>
<li>非对称加密相对于对称加密安全度是高了一点,但是如果拦截方把数据拦截下来,将自己的数据用拦截下来的公钥加密后返回给发送方,放松方并不能识别出来是不是目标通信对象发来的信息,因此还需要<strong>数字签名</strong>来作保障</li>
</ul>
</li>
</ul>
<h2 id="4-数字签名"><a href="#4-数字签名" class="headerlink" title="4/数字签名"></a>4/数字签名</h2><p>数字签名是附加在报文上面的特殊加密校验码.可以防止报文被篡改,如果恶意攻击在传输过程中篡改了报文,那么校验的时候就不再匹配,因此可以确认报文被篡改;</p>
<p><strong>数字签名加密过程:</strong></p>
<ul>
<li>发送端将报文通过算法（比如通过HASH函数）提取为定长的摘要；</li>
<li>发送端将摘要应用签名算法，以私有密钥作为参数生成一个签名；</li>
<li>计算得出签名后，将签名附加在报文末端发送给接收方；</li>
<li>接收端收到报文后，对签名进行检查。接收端通过公开密钥解码签名。然后比对报文生成的摘要是否与签名一致便可判断报文是否被篡改。</li>
</ul>
<p><strong>数字证书:</strong></p>
<p>数字证书是由权威机构给某网站颁发的一种认可凭证。它主要包含一些认证信息，比如：对象的名称（服务器、组织、个人等）、过期时间、证书颁发者、来自证书发布者的数字签名。</p>
<p><img src="https://s1.ax1x.com/2020/11/10/BqM3Bq.png"></p>
<p>上面的图片就是<a href="http://www.google.com的证书./">www.google.com的证书。</a></p>
<p>我们可以看到在上面讲到数字签名的时候，似乎就可以保证报文的安全了。为什么还需要数字证书呢？这个设想一下这个场景：比如某人A把发送到浏览器的公有密钥进行了替换，同时A在给浏览器发送报文时使用自己的私有密钥对报文进行数字签名，那么浏览器就不能确认报文是否来自于真实服务器。这个时候就可以使用数字证书进行验证，因为数字证书中保存了真实服务器的信息。</p>
<h2 id="5-HTTPS的工作流程"><a href="#5-HTTPS的工作流程" class="headerlink" title="5/HTTPS的工作流程"></a>5/HTTPS的工作流程</h2><p><strong>建立安全传输</strong><br>在TCP连接建立完成以后，在HTTPS协议中，客户端和服务端会初始化SSL层，也就是安全层。</p>
<p><strong>SSL握手</strong><br>在发送报文之前，客户端和服务端会进行一次SSL握手，在这个过程中主要完成以下工作：</p>
<ul>
<li><p>交换协议版本号；</p>
</li>
<li><p>选择一个两端都了解的密码；</p>
</li>
<li><p>对两端的身份进行认证；</p>
</li>
<li><p>生成临时会话密钥，以便加密信道（建立完安全通道后，传输报文时使用对称加密）；</p>
</li>
</ul>
<p>在SSL会进行很多工作，处理交换一些必要的信息之外，还会对身份进行认证。</p>
<p>这里的认证是通过数字证书进行的，在客户端获取证书后，会采用相应的算法对服务端的身份信息进行验证：</p>
<ul>
<li><p>日期检测：客户端会检查证书的有效期是否合法；</p>
</li>
<li><p>签名颁布者可信度检测：浏览器会附带一个签名颁发机构的授信列表，如果浏览器收到了位置的颁发机构签发的证书，那么它会显示一条警告信息；</p>
</li>
<li><p>签名检测：客户端对签名使用签名颁发机构的公开密钥，然后将其与校验码比较，以便验证证书是否合法；</p>
</li>
<li><p>站点身份检测：客户端验证数字证书中的域名是否与服务端的域名匹配；</p>
</li>
</ul>
<p>身份认证完成后，客户端与服务端进行密码协商，确定本次连接采用哪种加密算法进行通信。</p>
<p><strong>开始通信</strong><br>SSL握手完成后，就完成建立了HTTPS通道，客户端与服务端就会根据协商的加密算法进行通信。</p>
<p>整个HTTPS的工作流程可以总结如下：</p>
<p><img src="https://s1.ax1x.com/2020/11/10/BqM7Uf.png"></p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6/总结"></a>6/总结</h2><p>相较于HTTP协议，HTTPS确保了报文的机密性以及完整性。HTTPS确保这些的依赖就是SSL/TSL协议，SSL/TSL安全协议搭配数字证书保证了报文在传输过程中的绝对安全。</p>
]]></content>
      <categories>
        <category>Http&amp;Https</category>
      </categories>
      <tags>
        <tag>Https</tag>
      </tags>
  </entry>
  <entry>
    <title>Http</title>
    <url>/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%99%A8%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<p>HTTPS的一些知识</p>
<a id="more"></a>

<h3 id="1-什么是HTTP协议"><a href="#1-什么是HTTP协议" class="headerlink" title="1/什么是HTTP协议"></a>1/什么是HTTP协议</h3><ul>
<li>HTTP协议是超文本传输协议的简称,规定了服务端和客户端(前后端)通信方式以及占用的接口</li>
<li>HTTP协议是一个局域TCP/IP通信协议来传输数据的</li>
</ul>
<h3 id="2-HTTP协议的特性"><a href="#2-HTTP协议的特性" class="headerlink" title="2/HTTP协议的特性"></a>2/HTTP协议的特性</h3><ul>
<li>HTTP协议支持客户端/服务端模式,也是一种请求/响应模式的协议</li>
<li>简单快速,客户端向服务器请求服务时,只需要提供请求方法和URL.常用的有 GET,PSOT,DELETE,HEAD等</li>
<li>无连接:HTTP协议规定浏览器和服务端只能保持短暂的链接,浏览器的每次请求都需要与服务器建立一个TCP链接,服务器处理完成后立即断开TCP链接</li>
<li>无状态:无状态是指服务器不跟踪也不记录请求过的状态,后续如果需要前面的信息,必须重传.</li>
<li>但是可以借助cookie和session记住来做身份认证和状态记录</li>
</ul>
<h3 id="3-HTTP报文组成"><a href="#3-HTTP报文组成" class="headerlink" title="3/HTTP报文组成"></a>3/HTTP报文组成</h3><h4 id="请求报问"><a href="#请求报问" class="headerlink" title="请求报问"></a>请求报问</h4><ul>
<li>请求行</li>
<li>请求头(Request Header)</li>
<li>请求正文</li>
</ul>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul>
<li>状态行</li>
<li>响应头(Response Header)</li>
<li>响应正文</li>
</ul>
<h3 id="4-常见请求方法"><a href="#4-常见请求方法" class="headerlink" title="4/常见请求方法"></a>4/常见请求方法</h3><ul>
<li>GET</li>
<li>HEAD:类似GET请求,但是返回的响应中没有具体内容,用于获取报头</li>
<li>POST</li>
<li>PUT:从客户端向服务器传送的数据取代指定的文档的内容</li>
<li>DELETE:请求服务器删除指定页面</li>
</ul>
<h3 id="5-响应状态码"><a href="#5-响应状态码" class="headerlink" title="5/响应状态码"></a>5/响应状态码</h3><p>状态码分类：</p>
<ul>
<li>1XX- 信息型，服务器收到请求，需要请求者继续操作。</li>
<li>2XX- 成功型，请求成功收到，理解并处理。</li>
<li>3XX - 重定向，需要进一步的操作以完成请求。</li>
<li>4XX - 客户端错误，请求包含语法错误或无法完成请求。</li>
<li>5XX - 服务器错误，服务器在处理请求的过程中发生了错误。</li>
</ul>
<h3 id="6-常见状态码"><a href="#6-常见状态码" class="headerlink" title="6/常见状态码"></a>6/常见状态码</h3><ul>
<li>200:请求成功</li>
<li>204:无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li>
<li>301:永久重定向，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li>
<li>302:临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li>
<li>304:未修改。所请求的资源未修改，服务器不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li>
<li>400:客户端请求的语法错误，服务器无法理解</li>
<li>401:请求要求用户的身份认证</li>
<li>403:服务器理解请求客户端的请求，但是拒绝执行此请求</li>
<li>404:服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li>
<li>422:请求格式正确，但是由于含有语义错误，无法响应。</li>
<li>500:服务器内部错误，无法完成请求</li>
</ul>
]]></content>
      <categories>
        <category>Http&amp;Https</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2020/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>复习做的几个算法练习题/…</p>
<a id="more"></a>
<p>一、不借助临时变量，进行两个整数的交换</p>
<pre><code>let a = 1, b = 2;
[a, b] = [b, a]
console.log(a, b);</code></pre>
<p>二、字符串查找：请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。<br>🌰:</p>
<pre><code>a=&#39;34&#39;;b=&#39;1234567&#39;; // 返回 2
a=&#39;35&#39;;b=&#39;1234567&#39;; // 返回 -1
a=&#39;355&#39;;b=&#39;12354355&#39;; // 返回 5
isContain(a,b);
</code></pre>
<p>三、统计一个字符串出现最多的字母：给出一段英文连续的英文字符窜，找出重复出现次数最多的字母。<br>🌰:</p>
<pre><code>输入 ： afjghdfraaaasdenas
输出 ： a
</code></pre>
<pre><code>function hasMost(str) &#123;
  let counts = &#123;&#125;
  for (let item of str) &#123;
    counts[`$&#123;item&#125;`] = 0
    for (let j of str) &#123;
      if (j === item) &#123;
        counts[`$&#123;item&#125;`] = counts[`$&#123;item&#125;`] + 1;
      &#125;
    &#125;
  &#125;
  getMax(counts)
&#125;

function getMax(counts) &#123;
  let maxValue = 0
  let maxItem = &#39;&#39;
  for (let item in counts) &#123;
    if (counts[item] &gt; maxValue) &#123;
      maxValue = counts[item]
      maxItem = item
    &#125;
  &#125;
  console.log(maxItem, maxValue)
&#125;</code></pre>
<p>四、找出下列正数组的最大差值<br>🌰:</p>
<pre><code>输入 [10,5,11,7,8,9]
输出 6</code></pre>
<pre><code>function getDifferenceValue(arr) &#123;
  let maxNum = null, minNum = null
  arr.forEach(item =&gt; &#123;
    !maxNum ? maxNum = item : !minNum ? minNum = item : null
    item &gt; maxNum
      ? maxNum = item
      : item &lt; minNum
        ? minNum = item
        : minNum
  &#125;)
  console.log(maxNum, minNum)
  console.log(maxNum - minNum)
&#125;</code></pre>
<p>五、斐波那契数列：1、1、2、3、5、8、13、21。输入n，输出数列中第n位数的值。<br>🌰:</p>
<pre><code>function getValue(num) &#123;
  if (num &lt; 2) &#123;
    return 1
  &#125; else &#123;
    return (getValue(num - 1) + getValue(num - 2))
  &#125;
&#125;</code></pre>
<p>六、用js实现二分查找：二分查找的前提是有序数组</p>
<pre><code>🌰:
将要查找的值每次与中间值比较，大于中间值，则在右边进行相同的查找，小于中间值则在左边进行比较查找，找到返回索引值，没找到返回-1。</code></pre>
<p>var missingNumber = function (nums) {<br>  let left = 0, right = nums.length - 1;<br>  while (left &lt;= right) {<br>    let mid = Math.floor((left + right) / 2);<br>    if (mid === nums[mid]) {<br>      left = mid + 1;<br>    } else if (mid &lt; nums[mid]) {<br>      right = mid - 1;<br>    }<br>  }<br>  return left;<br>};</p>
<p>```<br>七、数组去重</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Http各版本特性及其区别</title>
    <url>/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E7%89%88%E6%9C%AC%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="HTTP各版本特性及区别"><a href="#HTTP各版本特性及区别" class="headerlink" title="HTTP各版本特性及区别"></a>HTTP各版本特性及区别</h3><a id="more"></a>


<p>本文参考:<br><a href="https://juejin.im/post/6844903923136856078">https://juejin.im/post/6844903923136856078</a><br><a href="https://segmentfault.com/a/1190000019891825">https://segmentfault.com/a/1190000019891825</a></p>
<p>HTTP 是基于 TCP/IP 协议的一个应用层协议，是现代互联网的一个基础协议。规定了客户端与服务端之间的通信格式以及所占用的服务端口80(HTTPS是443)。</p>
<h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>HTTP 协议从开始立项到现在一共经历了 4 个版本:</p>
<pre><code>HTTP 0.9 -&gt; HTTP 1.0 -&gt; HTTP 1.1 -&gt; HTTP 2</code></pre>
<h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h4><p>HTTP 0.9 是一个最古老的版本</p>
<p><strong>只支持GET请求方式</strong>：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息<br>没有请求头概念：所以不能在请求中指定版本号，<strong>服务端也只具有返回 HTML字符串的能力</strong><br><strong>服务端相响应之后，立即关闭TCP连接</strong></p>
<h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h4><p>随着 HTTP 1.0 的发布，这个版本:</p>
<p>请求方式<strong>新增了POST，DELETE，PUT，HEADER等方式</strong><br>增添了<strong>请求头</strong>和<strong>响应头</strong>的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)<br>扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输<br>在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。</p>
<h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p>一个简单请求的头信息</p>
<pre><code>GET / HTTP/1.0
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*</code></pre>
<p>浏览器控制台reponse headers<br><img src="https://s1.ax1x.com/2020/10/30/BtJAlF.png"></p>
<p>可以看到在请求方法之后有 请求资源的位置 + 请求协议版本，之后是一些客户端的信息配置</p>
<h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p>一个简单响应的头信息(v1.0)</p>
<pre><code>HTTP/1.0 200 OK
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
// 这是一个空行
...数据内容</code></pre>
<p>浏览器控制台request headers<br><img src="https://s1.ax1x.com/2020/10/30/BtJfhV.png"></p>
<p>服务端的响应头第一个就是 请求协议版本，后面紧跟着是这次请求的状态码、以及状态码的描述，之后的内容是一些关于返回内容的描述。</p>
<h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p>在 HTTP 1.0 的时候，任何的资源都可以被传输，传输的格式呢也是多种多样的，客户端在收到响应体的内容的时候就是根据这个 Content-Type 去进行解析的。所以<strong>服务端返回时候</strong>必须带着这个字段。<br><img src="https://s1.ax1x.com/2020/10/30/BtYKBj.png"><br>一些常见的 Content-Type 可以参考 对照表。 这些 Content-Type 有一个总称叫做<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a></p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li>无状态：服务器不跟踪不记录请求过的状态</li>
<li><strong>无连接</strong>：<strong>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接）</strong></li>
</ul>
<h6 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h6><p>对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录</p>
<h6 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h6><p>无连接导致的性能缺陷有两种：</p>
<ul>
<li><strong>无法复用连接</strong><br>每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低</li>
<li><strong>队头阻塞</strong><br>HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</li>
</ul>
<h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h4><p>  HTTP 1.1 是在 1.0 发布之后的半年就推出了，完善了 1.0 版本。目前也还有很多的互联网项目基于 HTTP 1.1 在向外提供服务。</p>
<h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><p>长连接：新增Connection字段，可以设置keep-alive值保持连接不断开<br>管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回<br>缓存处理：新增字段cache-control<br>断点传输</p>
<h6 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h6><p>HTTP 1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据.</p>
<p>B站首页，就有keep-alive，因为他们也有IM的成分在里面。需要大量复用TCP连接～<br><img src="https://s1.ax1x.com/2020/10/30/Btt4L4.png"></p>
<h6 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h6><p>基于长连接的基础，我们先看没有管道化请求响应：</p>
<p>tcp没有断开，用的同一个通道</p>
<pre><code>--&gt; 请求1 &gt; 响应1 
--&gt; 请求2 &gt; 响应2 
--&gt; 请求3 &gt; 响应3</code></pre>
<p>管道化的请求响应：</p>
<pre><code>--&gt; 请求1 --&gt; 请求2 --&gt; 请求3 

--&gt; 响应1 --&gt; 响应2 --&gt; 响应3</code></pre>
<p>即使服务器先准备好响应2,也是按照请求顺序先返回响应1</p>
<p>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p>
<h6 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理:"></a>缓存处理:</h6><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。 通过设置字段cache-control来控制缓存。</p>
<p><strong>怎么解决解决队头阻塞的问题?</strong></p>
<blockquote>
<p>实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个TCP的会话。<br>也就是说，上图我们看到的并行，其实是不同的TCP连接上的HTTP请求和响应。这也就是我们所熟悉的浏览器对同域下并行加载6~8个资源的限制。而这，才是真正的并行！</p>
</blockquote>
<p><strong>浏览器同域名请求的最大并发数限制</strong></p>
<blockquote>
<p>当我们在浏览网页的时候，对浏览速度有一个重要的影响因素，就是浏览器的并发数量。并发数量简单通俗的讲就是，当浏览器网页的时候同时工作的进行数量。</p>
</blockquote>
<ul>
<li><p>HTTP客户端一般对同一个服务器的并发连接个数都是有限制的。<br>实际上，浏览器确实使用并行连接，但它们将并行连接的总数限制为少量（<strong>通常为四个</strong>）。服务器可以自由地关闭来自特定客户端的过多连接。</p>
</li>
<li><p>一些主流浏览器对HTTP 1.1和HTTP 1.0的最大并发连接数目，可以参考如下表格：</p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/30/BtcGjA.png"></p>
<h6 id="断点传输"><a href="#断点传输" class="headerlink" title="断点传输"></a>断点传输</h6><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p>
<h5 id="Http-1-1的致命缺点："><a href="#Http-1-1的致命缺点：" class="headerlink" title="Http 1.1的致命缺点："></a>Http 1.1的致命缺点：</h5><p>1.明文传输<br>2.其实还是没有解决无状态连接的<br>3.当有多个请求同时被挂起的时候,就会拥塞请求通道，导致后面请求无法发送<br>4.臃肿的消息首部:HTTP/1.1能压缩请求内容,但是消息首部不能压缩;在现今请求中,消息首部占请求绝大部分(甚至是全部)也较为常见.</p>
<h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h4><h5 id="特性-2"><a href="#特性-2" class="headerlink" title="特性:"></a>特性:</h5><h6 id="二进制帧封装"><a href="#二进制帧封装" class="headerlink" title="二进制帧封装:"></a>二进制帧封装:</h6><p>HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率</p>
<h6 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用:"></a>多路复用:</h6><blockquote>
<p>所有的请求都是通过一个 TCP 连接并发完成。<br>HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。</p>
<p>同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。</p>
<p>即：HTTP2.0对于同一域名下所有请求都是基于流的，不管对于同一域名访问多少文件，也只建立一路连接。优先级高的流会被优先发送。图片请求的优先级要低于 CSS 和 SCRIPT，这个设计可以确保重要的东西可以被优先加载完</p>
</blockquote>
<h6 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩:"></a>头部压缩:</h6><p>由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源，</p>
<p>HTTPS 和 HTTP</p>
<ul>
<li>HTTPS 协议需要申请证书</li>
<li>HTTP 和 HTTPS 使用端口不一样，前者是80，后者是443</li>
<li>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li>
<li>HTTPS 可以有效的防止运营商劫持</li>
</ul>
]]></content>
      <categories>
        <category>Http&amp;Https</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>JsonServer</title>
    <url>/2020/10/28/%E5%B7%A5%E5%85%B7/Json-server/</url>
    <content><![CDATA[<h1 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h1><p>json-server 是什么？如何使用？</p>
<blockquote>
<p>json-server 是一个 npm 管理的包，可以提供前端提供mock的功能。</p>
</blockquote>
<a id="more"></a>

<h2 id="json-server-的使用"><a href="#json-server-的使用" class="headerlink" title="json-server 的使用"></a>json-server 的使用</h2><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1/安装"></a>1/安装</h4><p>全局安装:</p>
<pre><code>- yarn global add json-server

- npm install -g json-server </code></pre>
<h4 id="2-提供一个json数据的文件"><a href="#2-提供一个json数据的文件" class="headerlink" title="2.提供一个json数据的文件"></a>2.提供一个json数据的文件</h4><h4 id="3-使用json-server命令开启一个端口服务"><a href="#3-使用json-server命令开启一个端口服务" class="headerlink" title="3.使用json-server命令开启一个端口服务"></a>3.使用json-server命令开启一个端口服务</h4><pre><code>json-server --watch --port 3000 test.json</code></pre>
<h4 id="4-接口的使用"><a href="#4-接口的使用" class="headerlink" title="4.接口的使用:"></a>4.接口的使用:</h4><blockquote>
<ol>
<li>列表</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>详情</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>分页</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>排序</li>
</ol>
</blockquote>
<blockquote>
<ol start="5">
<li>全局查询<br>需要使用第三方接口调试工具的(postman)</li>
</ol>
</blockquote>
<blockquote>
<ol start="6">
<li>提供 增加（post）、</li>
</ol>
</blockquote>
<blockquote>
<ol start="7">
<li>删除(delete)、</li>
</ol>
</blockquote>
<blockquote>
<ol start="8">
<li>更新(put)</li>
</ol>
</blockquote>
<p>我们常见的接口：都是 get 或者 post 请求一个 url 地址即可。<br>json-server 除了常见的 get 或者 post ，还提供了诸如 put 、delete 这样的HTTP请求方式，<strong>对于这种使用 http请求方式 + 请求url地址 形成的 api ，我们一般叫做 RESTFul 风格的api</strong>, <em>RESTFul 风格的api底层遵循的是 REST 架构这种协议。</em></p>
<p>倒叙:<a href="http://localhost:3000/news?sort=id&amp;order=desc">http://localhost:3000/news?sort=id&amp;order=desc</a> </p>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>JsonServer</tag>
      </tags>
  </entry>
  <entry>
    <title>JSONP跨域请求及其原理</title>
    <url>/2020/10/28/Ajax/JsonP/</url>
    <content><![CDATA[<p>JSONP及其原理</p>
<a id="more"></a>

<h5 id="1、JSONP的产生"><a href="#1、JSONP的产生" class="headerlink" title="1、JSONP的产生"></a>1、JSONP的产生</h5><p><strong>背景:</strong></p>
<ul>
<li><p>因为浏览器同源策略限制,AJAX跨域请求不到信息</p>
</li>
<li><p>Web页面上面调用js文件不受是否跨域影响(类似的还有<code>&lt;script&gt;</code>,<code>&lt;IMG&gt;</code>,<code>&lt;iframe&gt;</code>)</p>
</li>
<li><p>于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、Web socket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；</p>
</li>
<li><p>恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被JS原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</p>
</li>
<li><p>客户端在对JSON文件调用成功之后,也就获得了自己所需要的数据,剩下的就是按自己的需求进行处理和展现了</p>
</li>
<li><p>为了方便客户使用数据,逐渐形成了一种非正式传输协议—JSONP.</p>
<blockquote>
<p>该协议允许用户传递一个callback参数给服务端,然后服务端返回数据时会将这个callback参数坐会函数名来包裹JSON数据,这样客户端就可以随意订制自己的函数来自动处理返回函数了</p>
</blockquote>
</li>
</ul>
<h5 id="2、JSONP弊端"><a href="#2、JSONP弊端" class="headerlink" title="2、JSONP弊端"></a>2、JSONP弊端</h5><ul>
<li>只能发送get请求</li>
<li>需要服务端配合</li>
</ul>
<h5 id="3、JSON流程"><a href="#3、JSON流程" class="headerlink" title="3、JSON流程"></a>3、JSON流程</h5><ul>
<li>先定义好全局函数</li>
<li>动态创建script标签</li>
<li>给服务器提供事先创建好的容器</li>
<li>服务器获取容器</li>
<li>将内容填充进容器</li>
</ul>
<h5 id="4、-代码实现-https-github-com-JuntengMa-JavaScript-tree-master-JsonP"><a href="#4、-代码实现-https-github-com-JuntengMa-JavaScript-tree-master-JsonP" class="headerlink" title="4、[代码实现]:https://github.com/JuntengMa/JavaScript/tree/master/JsonP"></a>4、[代码实现]:<a href="https://github.com/JuntengMa/JavaScript/tree/master/JsonP">https://github.com/JuntengMa/JavaScript/tree/master/JsonP</a></h5>]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>JSONP</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax</title>
    <url>/2020/10/28/Ajax/Ajax/</url>
    <content><![CDATA[<p>AJAX复习一下~</p>
<a id="more"></a>

<h5 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h5><h5 id="01-ajax是什么"><a href="#01-ajax是什么" class="headerlink" title="01-ajax是什么"></a>01-ajax是什么</h5><blockquote>
<p>​    JavaScript执行异步网络请求</p>
</blockquote>
<h5 id="02-ajax原理"><a href="#02-ajax原理" class="headerlink" title="02-ajax原理"></a>02-ajax原理</h5><p><strong>现在浏览器AJAX主要依靠XMLHttpRequest对象实现</strong></p>
<p><img src="https://s1.ax1x.com/2020/11/10/BbxQdP.png"></p>
<h5 id="03-创建ajax"><a href="#03-创建ajax" class="headerlink" title="03 - 创建ajax"></a>03 - 创建ajax</h5><h6 id="1-创建Ajax核心对象XMLHttpRequest"><a href="#1-创建Ajax核心对象XMLHttpRequest" class="headerlink" title="1/创建Ajax核心对象XMLHttpRequest"></a>1/创建Ajax核心对象XMLHttpRequest</h6><pre><code>var xhr = null ;
if(window.XMLHttpRequest)&#123;
    xhr = new XMLHttpRequest()
&#125;else&#123;
    xhr = new ActiveXobject(&quot;Microsoft.XMLHTTP&quot;)
&#125;</code></pre>
<h6 id="2-向服务器发送请求"><a href="#2-向服务器发送请求" class="headerlink" title="2/向服务器发送请求"></a>2/向服务器发送请求</h6><pre><code>xhr.open(method,url,async:boolean)
xhr.send(string); //POST请求时候采用string参数,否则不需要带参数</code></pre>
<ul>
<li><strong>method</strong> : GET/POST</li>
<li>**url:**请求链接(位置)</li>
<li>**async:**是否异步</li>
</ul>
<pre><code>xhr.open(&quot;POST&quot;,&quot;test.html&quot;,true);  
xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);  
xhr.send(&quot;fname=Henry&amp;lname=Ford&quot;);  //post请求参数放在send里面，即请求体</code></pre>
<h6 id="3-服务器响应处理-区分同步-异步情况"><a href="#3-服务器响应处理-区分同步-异步情况" class="headerlink" title="3/服务器响应处理(区分同步/异步情况)"></a>3/服务器响应处理(区分同步/异步情况)</h6><ul>
<li>responseText:获得字符串形式的响应数据</li>
<li>ResponseXML:获得XML形式的响应数据</li>
</ul>
<p>👹同步处理数据</p>
<pre><code>1. xhr.open(&quot;GET&quot;,&quot;info.txt&quot;,false);  
2. xhr.send();  
3. document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText; //获取数据直接显示在页面上</code></pre>
<p>👺异步处理数据(要在请求状态改变事件中处理。)</p>
<pre><code>1. xhr.onreadystatechange=function()  &#123; 
2.    if (xhr.readyState==4 &amp;&amp;xhr.status==200)  &#123; 
3.       document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText;  
4.      &#125;
5.    &#125; </code></pre>
<h6 id="4-什么是readyState"><a href="#4-什么是readyState" class="headerlink" title="4/什么是readyState?"></a>4/什么是readyState?</h6><p>readyState是XMLHttpRequest对象的一个属性,用来表示当前XMLHttpRequest对象处于什么状态</p>
<ul>
<li>0 : 未初始化,尚未调用xhr.open()方法</li>
<li>1 : 启动,已经调用xhr.open放大,但是未send</li>
<li>2 : 发送,已经调用xhr.send方法,但是还没有收到响应</li>
<li>3 : 接收,已经接收到部分响应数据</li>
<li>4 : 完成,已经接收到全部响应数据,并且可以在客户端使用</li>
</ul>
<h6 id="05-GET和POST请求数据区别"><a href="#05-GET和POST请求数据区别" class="headerlink" title="05/GET和POST请求数据区别"></a>05/GET和POST请求数据区别</h6><ul>
<li>get请求,参数在url中显示,post请求放在send里面</li>
<li>get请求发送数据量小,Post请求发送数据量比较大</li>
<li>get请求安全性低,会被缓存,POST反之</li>
</ul>
<h5 id="04-AJAX代码"><a href="#04-AJAX代码" class="headerlink" title="04/AJAX代码"></a>04/AJAX代码</h5><pre><code>function verificationParams(requestInfo) &#123;
    //地址不能为空
    if (!requestInfo.url) &#123;
        throw new Error(&#39;输入请求地址&#39;)
    &#125;

    //判断是异步是否合规
    if (typeof requestInfo.async !== &#39;boolean&#39;) &#123;
        throw new Error(&#39;async只接受boolean类型数据&#39;)
    &#125;

    //请求方式
    if (!(requestInfo.type.toUpperCase() === &#39;GET&#39; || requestInfo.type.toUpperCase() === &#39;post&#39;)) &#123;
        throw new Error(&#39;请求方式有误&#39;)
    &#125;
&#125;

function ajax(params) &#123;
    //默认参数对象
    let requestInfo=&#123;
        type: &#39;GET&#39;,//请求方式
        url:&#39;&#39;,
        data:&#39;&#39;,//请求参数
        datatype:&#39;string&#39;, //数据类型
        async:true,//异步还是同步
        callBack:function()&#123;&#125; //处理函数    
    &#125;

    for(let item in params)&#123;
        requestInfo[item] = params[item]
    &#125;

    verificationParams(requestInfo)

    const &#123; type, url, data, datatype, async, callBack &#125; = requestInfo

    //数据类型转换
    let str=&#39;&#39;
    let dataType = Object.prototype.toString.call(data)
    if (dataType===&#39;[object String]&#39;)&#123;
        str = data.replace(/,/g,&#39;&amp;&#39;)
    &#125; else if (dataType===&#39;[object Object]&#39;)&#123;
        for(let attr in data)&#123;
            str+=attr+&#39;=&#39;+data[attr]+&#39;&amp;&#39;
        &#125;
        str=str.slice(0,-1)
    &#125;

    let xhr = new XMLHttpRequest()

    if(type.toUpperCase()===&#39;GET&#39;)&#123;
        xhr.open(type.toUpperCase(),url+&#39;?&#39;+str,async)
        xhr.send()
    &#125;else&#123;
        xhr.open(type.toUpperCase(),url,async)
        xhr.setRequestHeader(&#39;content-type&#39;, &#39;application/x-www-form-urlencoded&#39;)
        xhr.send(str)
    &#125;
    xhr.onload=function()&#123;
        if(datatype===&#39;json&#39;)&#123;
            callBack(eval(&#39;(&#39;+xhr.responseText+&#39;)&#39;))
        &#125;else&#123;
            callBack(xhr.responseText)
        &#125;
    &#125;
&#125;

function Ajax(params)&#123;
    let promise=new Promise(function(resolve,reject)&#123;
        ajax(&#123;
            url:params.url,
            type:params.type.toUpperCase() || &#39;GET&#39;,
            data:params.data ||&#39;&#39;,
            datatype:params.datatype || &#39;string&#39;,
            async:params.async || true,
            callBack:function(res)&#123;
                resolve(res)
            &#125;
        &#125;)
    &#125;)
    return promise
&#125;</code></pre>
]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>盒模型,BFC</title>
    <url>/2020/10/28/Css/Css%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p>   关于盒模型的一些总结</p>
</blockquote>
<a id="more"></a>
<h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><h5 id="标准盒模型-box-sizing-content-box"><a href="#标准盒模型-box-sizing-content-box" class="headerlink" title="标准盒模型(box-sizing:content-box)"></a>标准盒模型(box-sizing:content-box)</h5><pre><code>width = content width;
height = content height;</code></pre>
<h5 id="怪异盒模型-box-sizing-border-box"><a href="#怪异盒模型-box-sizing-border-box" class="headerlink" title="怪异盒模型(box-sizing:border-box)"></a>怪异盒模型(box-sizing:border-box)</h5><pre><code>width = content width + padding + border;
height = content height + padding + border;</code></pre>
<h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><h5 id="01-什么是BFC"><a href="#01-什么是BFC" class="headerlink" title="01/什么是BFC?"></a>01/什么是BFC?</h5><p>块级格式化上下文</p>
<p>BFC是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<h5 id="02-建立BFC"><a href="#02-建立BFC" class="headerlink" title="02/建立BFC"></a>02/建立BFC</h5><ul>
<li>浮动</li>
<li>绝对定位</li>
<li>行内块元素</li>
<li>表格单元</li>
<li>弹性盒</li>
<li>overflow不为visible</li>
</ul>
<h5 id="03-BFC应用场景"><a href="#03-BFC应用场景" class="headerlink" title="03/BFC应用场景"></a>03/BFC应用场景</h5><ul>
<li>清除浮动</li>
<li>阻止元素被浮动元素覆盖</li>
<li>实现两列自适应布局</li>
</ul>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
        <tag>盒模型</tag>
        <tag>BFC</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习</title>
    <url>/2020/10/26/TypeScript/TypeScript/</url>
    <content><![CDATA[<a id="more"></a>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack配置</title>
    <url>/2020/10/19/%E5%B7%A5%E5%85%B7/webpack/</url>
    <content><![CDATA[<p>webpack基本配置</p>
<a id="more"></a>

<h3 id="1-什么是-webpack"><a href="#1-什么是-webpack" class="headerlink" title="1. 什么是 webpack"></a>1. 什么是 webpack</h3><blockquote>
<p>webpack 是一个现代 javaScript 应用程序的静态模块打包器, 分析项目结构，处理模块化依赖，转换成为浏览器 可运行的代码。</p>
</blockquote>
<h3 id="2-webpack-用来做什么"><a href="#2-webpack-用来做什么" class="headerlink" title="2. webpack 用来做什么"></a>2. webpack 用来做什么</h3><blockquote>
<ul>
<li>代码转换: TypeScript 编译成 JavaScript、SCSS,LESS 编译成 CSS。</li>
<li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片。</li>
<li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li>
<li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件</li>
<li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li>
</ul>
</blockquote>
<h3 id="3-webpack安装"><a href="#3-webpack安装" class="headerlink" title="3.webpack安装"></a>3.webpack安装</h3><pre><code>//全局安装webpack及webpack-cli模块
yarn global add webpack webpack--cli
//本地安装项目模块（一般本地安装，防止本地和全局版本不一致）
yarn add webpack webpack-cli -dev(-D)
//打包命令
npx webpack</code></pre>
<h3 id="4-插件"><a href="#4-插件" class="headerlink" title="4.插件"></a>4.插件</h3><h4 id="1-webpack-dev-server"><a href="#1-webpack-dev-server" class="headerlink" title="1. webpack-dev-server"></a>1. webpack-dev-server</h4><pre><code class="node">devServer: &#123;//这里做开发服务器配置
    port: 3000,
    contentBase: path.join(__dirname, &#39;dist&#39;),//_dirname：表示在当前目录
    compress: true,//启动gzip压缩
&#125;</code></pre>
<h4 id="2-HtmlWebpackPlugin"><a href="#2-HtmlWebpackPlugin" class="headerlink" title="2.  HtmlWebpackPlugin"></a>2.  HtmlWebpackPlugin</h4><pre><code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);

new HtmlWebpackPlugin(&#123;
  template: &#39;./src/index.html&#39;,
  filename: &#39;index.html&#39;,
  minify: &#123;//用于对文件进行压缩
    removeAttributeQuotes: true,// 移除属性的引号
    collapseWhitespace: true,
    removeComments: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    useShortDoctype: true
  &#125;,
  hash: true
&#125;)</code></pre>
<h4 id="3-热更新"><a href="#3-热更新" class="headerlink" title="3.  热更新"></a>3.  热更新</h4><pre><code>new webpack.HotModuleReplacementPlugin(),</code></pre>
<h4 id="4-打包分析插件"><a href="#4-打包分析插件" class="headerlink" title="4. 打包分析插件"></a>4. 打包分析插件</h4><pre><code>const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin;

module.exports = &#123;
  plugins: [
    new BundleAnalyzerPlugin()
  ]
&#125;
//安装， 然后重启一下server， 然后就可以在http://127.0.0.1:8888/ 看到这个分析了。</code></pre>
<h4 id="5-开启进度条"><a href="#5-开启进度条" class="headerlink" title="5.  开启进度条"></a>5.  开启进度条</h4><pre><code>const ProgressBarPlugin = require(&#39;progress-bar-webpack-plugin&#39;);
new ProgressBarPlugin(),</code></pre>
<h4 id="6-打包时长测试"><a href="#6-打包时长测试" class="headerlink" title="6. 打包时长测试"></a>6. 打包时长测试</h4><pre><code>const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);

const smp = new SpeedMeasurePlugin();

const webpackConfig = smp.wrap(&#123;
  plugins: [
    new MyPlugin(),
    new MyOtherPlugin()
  ]
&#125;);</code></pre>
]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>for-in &amp; for-of的区别 和 map-for &amp; Each区别</title>
    <url>/2020/10/09/JavaScript/forIn-forOF-Map-forEach%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<h4> 
 for-in & for-of的区别 和 map-for & Each区别
</h4>
</blockquote>
<a id="more"></a>

<h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><ul>
<li>遍历一个对象的除<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>以外的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举</a>属性, <strong>用于遍历对象</strong></li>
<li>for…in 循环出的是 key</li>
</ul>
<pre><code>const obj = &#123;
    name: &#39;哇塞&#39;,
    age: 18
&#125;

for(let item in obj)&#123;
    console.log(item)
&#125;
// Output:
//name
//age</code></pre>
<h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><ul>
<li><strong>用于遍历数组</strong></li>
<li>for-of 是 ES6 引入属性</li>
<li>for-of 不能用来遍例普通对象,需要和 Obect.keys()搭配使用</li>
<li>for…of 循环出的是 value</li>
</ul>
<pre><code>let aArray = [&#39;a&#39;,123,&#123;a:&#39;1&#39;,b:&#39;2&#39;&#125;]</code></pre>
<p>结论:</p>
<ul>
<li>推荐在<strong>循环对象</strong>属性的时候，使用<strong>for…in</strong></li>
<li>在<strong>遍历数组</strong>的时候的时候使用<strong>for…of</strong>。</li>
<li>for…in 循环出的是 key，for…of 循环出的是 value</li>
<li>注意，for…of 是 ES6 新引入的特性。修复了 ES5 引入的 for…in 的不足</li>
<li>for…of 不能循环普通的对象，需要通过和 Object.keys()搭配使用</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript处理异步函数几种方案</title>
    <url>/2020/10/01/JavaScript/JavaScript-%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<h4> 
 for-in & for-of的区别 和 map-for & Each区别
</h4>
</blockquote>
<a id="more"></a>

<h1 id="JS处理异步函数几种方案"><a href="#JS处理异步函数几种方案" class="headerlink" title="JS处理异步函数几种方案"></a>JS处理异步函数几种方案</h1><h4 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1.回调函数"></a>1.回调函数</h4><p>顾名思义: 将一个函数作为参数传入另外一个函数中,等父级函数执行完再执行回调函数</p>
<pre><code class="js">function f1(callBack)&#123;
    console.log(&quot;hello&quot;)
    let data = &quot;world&quot;
    callBack(data)
&#125;
f1((data)=&gt;console.log(data))
// hello
// world</code></pre>
<p>回调函数优缺点:</p>
<blockquote>
<p>优点: 简单方便,适用于<strong>只有一个异步的操作</strong><br>缺点:如果嵌套层级过深,会形成回调地狱,耦合度过强</p>
</blockquote>
<pre><code class="js">getData(&#39;x&#39;,()=&gt;&#123;
    //callBack函数体
    getData2(&#39;y&#39;,()=&gt;&#123;
        //callBack函数体
        getData3(&#39;z&#39;,()=&gt;&#123;
            //callBack函数体
            ...
        &#125;)
    &#125;)
&#125;)</code></pre>
<h4 id="2-Promise对象-async-await-最常用-终极解决方案"><a href="#2-Promise对象-async-await-最常用-终极解决方案" class="headerlink" title="2.Promise对象+async+await(最常用,终极解决方案)"></a>2.Promise对象+async+await(最常用,终极解决方案)</h4><ul>
<li><p>promise严格来说是一种模式,可以来管理异步代码</p>
</li>
<li><p>什么是Promise?</p>
<blockquote>
<p>Promise是解决异步编程的一种方案</p>
</blockquote>
</li>
<li><p>优点:</p>
<blockquote>
<p>可以解决回调地狱问题,且Promise只有resolve 和 reject 两种状态</p>
</blockquote>
</li>
<li><p>常用API:</p>
<blockquote>
<p>resolve : 返回异步操作成功结果<br>reject    : 返回异步操作失败结果<br>then      : 执行Promise状态为成功的操作<br>catch     :执行Promise状态为失败的操作<br>finally    :不管Promise是否成功都执行的操作</p>
</blockquote>
</li>
<li><p>使用:</p>
<pre><code class="js">    const p  = new Promise((resolve,reject)=&gt;&#123;
        //异步操作
        if(success)&#123;
            resolve(&#39;some message&#39;)
        &#125;else&#123;
            reject(err)
        &#125;
    &#125;)
    p.then(res=&gt;&#123;
        //resolve数据
    &#125;).catch(err=&gt;&#123;
        //rejects数据
    &#125;).finally(()=&gt;&#123;
        //执行一些操作
    &#125;)</code></pre>
</li>
<li><p>使用案例2: 封装nodejs的request模块</p>
<pre><code class="js">const request = require(&quot;request&quot;);
const requestData = (uri) =&gt; &#123;
    return new Promise((resolve, reject) =&gt; &#123;
        request(&#123;
            uri
        &#125;, (err, res, body) =&gt; &#123;
            resolve(&#123;
                err,
                res,
                body
            &#125;)
        &#125;)
    &#125;)
&#125;;
//使用
let url = &quot;https://imgcache.qq.com/wss/security//ssl/build/ssl-444feca18a7857546ff9b39bbc95a17c.js&quot;;
(async() =&gt; &#123;
    let &#123;
        err,
        res,
        body
    &#125; = await requestData(url)
    console.log(res)
&#125;)()</code></pre>
</li>
</ul>
<h4 id="3-事件绑定"><a href="#3-事件绑定" class="headerlink" title="3.事件绑定"></a>3.事件绑定</h4><p>事件绑定的方法有三种</p>
<p>一，事件监听，<br>二，对象.on方法，<br>三，直接在行内写<br>事件监听有两种方法，</p>
<blockquote>
<ul>
<li>addlisenerevent</li>
<li>attachevent</li>
</ul>
</blockquote>
<p>两种事件监听的区别:<br>addeventlistener参数个数一般是三个，参数书写（事件类型）不写on执行顺序为：顺序注册倒序执行，兼容非IE7.8，最后一个参数是TRUE或FALSE，TRUE为捕获，FALSE为冒泡，默认FALSE<br>attachevent参数个数为两个，参数书写不写on，执行顺序：顺序注册倒序执行，兼容ie78</p>
<h4 id="4-Generator函数"><a href="#4-Generator函数" class="headerlink" title="4.Generator函数"></a>4.Generator函数</h4>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器同源策略</title>
    <url>/2020/09/29/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>关于同源策略的一点总结~</p>
<a id="more"></a>


<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h5 id="01、什么是同源策略"><a href="#01、什么是同源策略" class="headerlink" title="01、什么是同源策略"></a>01、什么是同源策略</h5><blockquote>
<p>同源策略是浏览器安全的基石</p>
<p>同源：</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。</p>
<p>它的同源情况如下：</p>
<ul>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
</ul>
</blockquote>
<h5 id="02、同源策略目的"><a href="#02、同源策略目的" class="headerlink" title="02、同源策略目的"></a>02、同源策略目的</h5><blockquote>
<p>同源策略目的，是为了保证用户信息安全，防止恶意网站窃取数据</p>
</blockquote>
<h5 id="03、同源策略限制范围"><a href="#03、同源策略限制范围" class="headerlink" title="03、同源策略限制范围"></a>03、同源策略限制范围</h5><blockquote>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM无法获得</li>
<li>AJAX请求不能发送</li>
</ul>
</blockquote>
<h5 id="04、规避同源策略方案"><a href="#04、规避同源策略方案" class="headerlink" title="04、规避同源策略方案"></a>04、规避同源策略方案</h5><blockquote>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
</blockquote>
<h5 id="05、JSONP"><a href="#05、JSONP" class="headerlink" title="05、JSONP"></a>05、JSONP</h5><blockquote>
<ul>
<li><p>什么是JSONP<br>JSONP是服务器与客户端跨原通信的常用方案。最大特点就是简单适用，老式浏览器全部支持，服务器改造小</p>
</li>
<li><p>原理</p>
<p>网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，该方法不受同源策略限制，服务器收到请求之后，将数据放在指定的名字回调函数中传回来</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>同源策略</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>Axios二次封装</title>
    <url>/2020/09/27/Ajax/Axios/</url>
    <content><![CDATA[<hr>
<a id="more"></a>


<h3 id="01-新建src-api文件夹"><a href="#01-新建src-api文件夹" class="headerlink" title="01-新建src/api文件夹"></a>01-新建src/api文件夹</h3><pre><code>api
 - ajax.js
 - index.js</code></pre>
<h3 id="02-新建axios-js文件"><a href="#02-新建axios-js文件" class="headerlink" title="02-新建axios.js文件"></a>02-新建axios.js文件</h3><pre><code class="js">import axios from &#39;axios&#39;

//封装ajax
export default function ajax(url=&#39;&#39;,params=&#123;&#125;,type=&#39;GET&#39;)&#123;
  let promise;
  type = type.toUpperCase()
  return new Promise(((resolve, reject) =&gt; &#123;
    //1.判断请求方式
    if (type===&#39;GET&#39;)&#123;
      //1.1拼接字符串
      let str = &#39;&#39;;
      Object.keys(params).forEach((value,index) =&gt; &#123;
        if (index+1===Object.keys(params).length)&#123;
          str+=value+&#39;=&#39;+params[value];
        &#125;else&#123;
          str+=value+&#39;=&#39;+params[value]+&#39;&amp;&#39;;
        &#125;
      &#125;);
      //1.2完整路径
      url+=&#39;?&#39;+str;
      //1.3发送get请求
      promise = axios.get(url);
    &#125;else if(type===&#39;POST&#39;)&#123;
      //1.3发送post请求
      promise = axios.post(url,params);
    &#125;
    //2.返回请求结果
    promise.then((response)=&gt;&#123;
      resolve(response.data);
    &#125;).catch((error)=&gt;&#123;
      reject(error);
    &#125;);
  &#125;))
&#125;
</code></pre>
<h3 id="03-新建index-js文件"><a href="#03-新建index-js文件" class="headerlink" title="03-新建index.js文件"></a>03-新建index.js文件</h3><pre><code>import ajax from &#39;./ajax&#39;

//发送请求
export const getPhoneCode = (phone)=&gt;ajax(&#39;/api/getPhoneCode&#39;,&#123;phone&#125;);
</code></pre>
<h3 id="04-api调用"><a href="#04-api调用" class="headerlink" title="04-api调用"></a>04-api调用</h3><pre><code>import &#123; xxxxx &#125; from &#39;api/index.js (文件路径)&#39;</code></pre>
]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>Axios</tag>
      </tags>
  </entry>
  <entry>
    <title>React父组件调用子组件</title>
    <url>/2020/09/25/React/React-%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>React父组件调用子组件方案</p>
<a id="more"></a>

<h2 id="方案一：-ref控制"><a href="#方案一：-ref控制" class="headerlink" title="方案一： ref控制"></a>方案一： ref控制</h2><h4 id="Parent-Component-Parent-tsx"><a href="#Parent-Component-Parent-tsx" class="headerlink" title="Parent Component ( Parent.tsx )"></a>Parent Component ( Parent.tsx )</h4><pre><code>import * as React from &#39;react&#39;;

import &#123; ChildA &#125; from &#39;./ChildA&#39;;

//多个子组件时可以先定义如下组件：
class Childrens extends React.Component&lt;any, any&gt; &#123;
  _childA: any;
  _childB: any;
  _childC: any;
&#125;

export class Parent extends Childrens &#123;

  //调用子组件方式：
  get_childA_sum = () =&gt; &#123;
    this._childA.sum(1, 2)
  &#125;

  render() &#123;
    const children = &#123;
      on_childA_ref: ref =&gt; &#123;
        this._childA = ref;
      &#125;,
      on_childB_ref: ref =&gt; &#123;
        this._childB = ref;
      &#125;,
      on_childC_ref: ref =&gt; &#123;
        this._childC = ref;
      &#125;,
    &#125;

    return (
      &lt;div&gt;
        &lt;button onClick=&#123;() =&gt; this.get_childA_sum()&#125;&gt; SumA &lt;/button&gt;
        &lt;ChildA _childA=&#123;children.on_childA_ref&#125; /&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;


</code></pre>
<h4 id="Children-Component-ChildA-tsx"><a href="#Children-Component-ChildA-tsx" class="headerlink" title="Children Component  (ChildA.tsx)"></a>Children Component  (ChildA.tsx)</h4><pre><code>import * as React from &#39;react&#39;;

interface ChildAProps &#123;
  _childA:Function;
&#125;

export class ChildA extends React.Component&lt;ChildAProps, any&gt; &#123;

  componentDidMount() &#123;
        this.props._childA(this)
    &#125;

  sum = (a , b) =&gt; &#123;
    alert(a+b)
  &#125;

  render()&#123;
    return(
      &lt;div&gt;
        组件A
      &lt;/div&gt;
    )
  &#125;

&#125;</code></pre>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-富文本框(braft-editor)</title>
    <url>/2020/09/24/React/React-richText/</url>
    <content><![CDATA[<h2 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h2><a id="more"></a>

<p><a href="https://www.yuque.com/braft-editor/be/gz44tn#wx1vkv">https://www.yuque.com/braft-editor/be/gz44tn#wx1vkv</a></p>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;;
// 引入编辑器组件

import BraftEditor from &#39;braft-editor&#39;;
// 引入编辑器样式
import &#39;braft-editor/dist/index.css&#39;;

import &#123; UploadFn &#125; from &#39;./UploadFn&#39;;

export class RichText extends Component &#123;
    constructor() &#123;
        super();
        this.state = &#123;
            editorState: BraftEditor.createEditorState(null),
        &#125;;
        RichText.submitContent = this.submitContent.bind(this);
    &#125;

    async componentDidMount() &#123;
        // 假设此处从服务端获取html格式的编辑器内容
        let htmlContent = this.props.htmlContent || null;
        // 使用BraftEditor.createEditorState将html字符串转换为编辑器需要的editorStat
        this.setState(&#123;
            editorState: BraftEditor.createEditorState(htmlContent),
        &#125;);
    &#125;

    componentWillReceiveProps(nextProps) &#123;
        if (nextProps.htmlContent !== this.state.htmlContent) &#123;
            this.setState(&#123;
                editorState: BraftEditor.createEditorState(nextProps.htmlContent),
            &#125;);
        &#125;
    &#125;

    submitContent = async () =&gt; &#123;
        // 在编辑器获得焦点时按下ctrl+s会执行此方法
        // 编辑器内容提交到服务端之前，可直接调用editorState.toHTML()来获取HTML格式的内容
        const htmlContent = this.state.editorState.toHTML();
        return htmlContent;
    &#125;;

    handleEditorChange = editorState =&gt; &#123;
        this.setState(&#123; editorState &#125;);
    &#125;;

    render() &#123;
        return (
            &lt;BraftEditor
                value=&#123;this.state.editorState&#125;
                onChange=&#123;this.handleEditorChange&#125;
                onSave=&#123;this.submitContent&#125;
                onBlur=&#123;() =&gt; &#123;
                    const htmlContent = this.state.editorState.toHTML();
                &#125;&#125;
                // excludeControls=&#123;[&#39;options&#39;]&#125;
                media=&#123;&#123; uploadFn: UploadFn &#125;&#125;
            /&gt;
        );
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React中使用Echats</title>
    <url>/2020/09/22/React/React-echart/</url>
    <content><![CDATA[<p>React中使用Echats记录</p>
<a id="more"></a>



<h4 id="1-安装echats"><a href="#1-安装echats" class="headerlink" title="1.安装echats"></a>1.安装echats</h4><pre><code>npm install echarts --save
npm install --save echarts-for-react</code></pre>
<h4 id="2-引入所需模块"><a href="#2-引入所需模块" class="headerlink" title="2.引入所需模块"></a>2.引入所需模块</h4><pre><code class="javascript">// 引入 ECharts 主模块
var echarts = require(&#39;echarts/lib/echarts&#39;);
// 引入柱状图
require(&#39;echarts/lib/chart/bar&#39;);
// 引入提示框和标题组件
require(&#39;echarts/lib/component/tooltip&#39;);
require(&#39;echarts/lib/component/title&#39;);</code></pre>
<h4 id="3-实例"><a href="#3-实例" class="headerlink" title="3.实例"></a>3.实例</h4><pre><code class="javascript">showTrend() &#123;
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById(&#39;trend&#39;));
        //柱状图点击事件
        myChart.on(&#39;click&#39;, params =&gt; &#123;

        &#125;);
              // 绘制图表
        myChart.setOption(&#123;
            title: &#123; text: &#39;近十五日趋势&#39; &#125;,
            color: [&#39;#3398DB&#39;],
            tooltip: &#123;
                trigger: &#39;axis&#39;,
                axisPointer: &#123;
                    type: &#39;shadow&#39;,
                &#125;,
            &#125;,
            grid: &#123;
                left: &#39;3%&#39;,
                right: &#39;4%&#39;,
                bottom: &#39;3%&#39;,
                containLabel: true,
            &#125;,
            xAxis: &#123;
                type: &#39;category&#39;,
                data: this.state.trendDate,
                axisTick: &#123;
                    alignWithLabel: true,
                &#125;,
            &#125;,
            yAxis: [&#123; type: &#39;value&#39; &#125;],
            series: [
                &#123;
                    name: &#39;告警总数&#39;,
                    type: &#39;bar&#39;,
                    barWidth: &#39;60%&#39;,
                    data: this.state.trendData,
                &#125;,
            ],
        &#125;);
    &#125;</code></pre>
<h4 id="4-DOM部分"><a href="#4-DOM部分" class="headerlink" title="4.DOM部分"></a>4.DOM部分</h4><pre><code class="html">&lt;div id=&quot;trend&quot; style=&#123;&#123; height: 300 &#125;&#125;&gt;&lt;/div&gt;</code></pre>
<h4 id="5-效果图"><a href="#5-效果图" class="headerlink" title="5.效果图"></a>5.效果图</h4><p><img src="https://cdn.jsdelivr.net/gh/JuntengMa/Images@1.1/blog/echats.jpg"></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>在react传值问题--context传值</title>
    <url>/2020/09/22/React/React-Redux/</url>
    <content><![CDATA[<h1 id="Redux-的基础概念"><a href="#Redux-的基础概念" class="headerlink" title="Redux 的基础概念"></a>Redux 的基础概念</h1><p>什么是Redux?</p>
<p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p>
<h2 id="三个基本原则"><a href="#三个基本原则" class="headerlink" title="三个基本原则"></a>三个基本原则</h2><ul>
<li>整个应用只有一个可信数据源 —  store</li>
<li>State只能通过Action更改</li>
<li>State的更改只能写成一个纯函数,也就是每次更改必须返回一个新的State——Reducer</li>
</ul>
<h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><p>Action 就是一个单纯的包含 { type , pyload }的对象, </p>
<ul>
<li><p>type 用来标识动作类型</p>
</li>
<li><p>pyload用来携带数据</p>
</li>
<li><p>Action需要通过store.dispatch()方法来发送</p>
</li>
</ul>
<p>比如一个最简单的 action：</p>
<pre><code>&#123;
  type: &#39;ADD_TODO&#39;,
  text: &#39;Build my first Redux app&#39;
&#125;</code></pre>
<h2 id="Reducers"><a href="#Reducers" class="headerlink" title="Reducers"></a>Reducers</h2><p>Reducers用来处理Action触发的对状态的更改</p>
<p>Reducer接受<code>oldState</code>和<code>action</code>两个参数,并返回一个新的state</p>
<p>一个Reducer_demo:</p>
<pre><code>const initialState = &#123;
  a: &#39;a&#39;,
  b: &#39;b&#39;
&#125;;

function someApp(state = initialState, action) &#123;
  switch (action.type) &#123;
    case &#39;CHANGE_A&#39;:
      return &#123; ...state, a: &#39;Modified a&#39; &#125;;
    case &#39;CHANGE_B&#39;:
      return &#123; ...state, b: action.payload &#125;;
    default:
      return state
  &#125;
&#125;</code></pre>
<p>Reducer 也是 <strong>pure function</strong>，这点非常重要，所以绝对不要在 reducer 里面做一些引入 side-effects 的事情，比如：</p>
<ul>
<li>直接修改 state 参数对象</li>
<li>请求 API</li>
<li>调用不纯的函数，比如 <code>Data.now()</code> <code>Math.random()</code></li>
</ul>
<p>因为 Redux 里面只有一个 Store，对应一个 State 状态，所以整个 State 对象就是由一个 reducer 函数管理，但是如果所有的状态更改逻辑都放在这一个 reducer 里面，显然会变得越来越巨大，越来越难以维护。得益于纯函数的实现，我们只需要稍微变通一下，让状态树上的每个字段都有一个 reducer 函数来管理就可以拆分成很小的 reducer 了：</p>
<pre><code class="javascript">function someApp(state = &#123;&#125;, action) &#123;
  return &#123;
    a: reducerA(state.a, action),
    b: reducerB(state.b, action)
  &#125;;
&#125;</code></pre>
<p>Redux 提供了一个工具函数 <code>combineReducers</code> 来简化这种 reducer 合并：</p>
<pre><code class="javascript">import &#123; combineReducers &#125; from &#39;redux&#39;;

const someApp = combineReducers(&#123;
  a: reducerA,
  b: reducerB
&#125;);</code></pre>
<h2 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h2><p>现在有了 Action 和 Reducer，Store 的作用就是连接这两者，Store 的作用有这么几个：</p>
<ul>
<li>Hold 住整个应用的 State 状态树</li>
<li>提供一个 <code>getState()</code> 方法获取 State</li>
<li>提供一个 <code>dispatch()</code> 方法发送 action 更改 State</li>
<li>提供一个 <code>subscribe()</code> 方法注册回调函数监听 State 的更改</li>
</ul>
<p>创建一个 Store 很容易，将 <strong>root reducer</strong> 函数传递给 <code>createStore</code> 方法即可：</p>
<pre><code>import &#123; createStore &#125; from &#39;redux&#39;;
import someApp from &#39;./reducers&#39;;
let store = createStore(someApp);

// 你也可以额外指定一个初始 State（initialState），这对于服务端渲染很有用
// let store = createStore(someApp, window.STATE_FROM_SERVER);

let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));

// Dispatch
store.dispatch(&#123; type: &#39;CHANGE_A&#39; &#125;);
store.dispatch(&#123; type: &#39;CHANGE_B&#39;, payload: &#39;Modified b&#39; &#125;);

// Stop listening to state updates
unsubscribe();</code></pre>
<h1 id="Redux-和-React-Redux-区别"><a href="#Redux-和-React-Redux-区别" class="headerlink" title="Redux 和 React-Redux 区别"></a>Redux 和 React-Redux 区别</h1><h3 id="1-Redux"><a href="#1-Redux" class="headerlink" title="1.Redux"></a>1.Redux</h3><p>用户视图层的操作执行了dispatch,</p>
<p>dispatch又调用了Reducers函数,</p>
<p>Reducers获取当前状态state进行业务处理,形成一个newState保存到Store仓库中,</p>
<p>Store所有依赖的视图层发生同步更新<img src="https://s3.ax1x.com/2020/11/17/DVtjnP.png" alt="redux数据流"></p>
<p>限制:只能在当前这一层进行传递,如果项目关系比较复杂,层次比较深 , 只能用props进行逐层传递——&gt;<strong>redux不能进行跨层级获取数据</strong>—-&gt;React-Redux解决</p>
<h3 id="2-React-Redux"><a href="#2-React-Redux" class="headerlink" title="2.React-Redux"></a>2.React-Redux</h3><p><img src="https://s3.ax1x.com/2020/11/17/DVNPpj.png" alt="react-redux工作流程2"></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>在react传值问题--context传值</title>
    <url>/2020/09/22/React/React-context/</url>
    <content><![CDATA[<blockquote>
<p>最近React回炉重造,看到context传值问题,顺便研究了一下…..</p>
</blockquote>
<a id="more"></a>

<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>01/什么是context?</p>
<blockquote>
<p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。</p>
</blockquote>
<p>02/为什么要用context?</p>
<blockquote>
<p>在一个典型的 React 应用中，数据是通过 props 属性自上而下（由父及子）进行传递的，但这种做法对于某些类型的属性而言是极其繁琐的（例如：地区偏好，UI 主题），这些属性是应用程序中许多组件都需要的。Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。</p>
</blockquote>
<p>03/怎么使用?</p>
<ul>
<li><p>createContext</p>
<p>通过createContent创建一个MyContext对象</p>
<pre><code>const MyContext = React.createContext(defaultValue);</code></pre>
</li>
<li><p>Context.Provider</p>
<p>作为数据来源,为需要用到数据的组件提供数据</p>
<pre><code>&lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt;</code></pre>
</li>
<li><p>Context.Consumer</p>
<p>作为使用数据方</p>
<pre><code>&lt;MyContext.Consumer&gt;
  &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;
&lt;/MyContext.Consumer&gt;</code></pre>
</li>
<li><p>Class.contextType(暂时没搞懂)</p>
</li>
</ul>
<p>04/个人理解</p>
<p>​    可以把context当做一个简化版的redux(store) , A把数据存在仓库里面,当A的儿子或者孙子想要仓库里的东西的时候,可以去仓库里面取出来用就好</p>
<p>05/demo</p>
<ul>
<li><p>我现在有一个组件ContextDemo需要把state里面的数据共享出去,Consumers组件需要使用和修改共享出去的数据</p>
<pre><code>&lt;ContextDemo state=&#123;...this.state&#125;&gt;
   &lt;Toolbar&gt;
           &lt;Consumers/&gt;
    &lt;/Toolbar&gt;
&lt;/ContextDemo&gt;</code></pre>
</li>
<li><p>ContextDemo组件</p>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;;
import &#123; Toolbar &#125; from &#39;./Toolbar&#39;;

export class ContextDemo extends React.Component &#123;

state = &#123;
 toggle: true,
 handleToggle: () =&gt; this.handleToggle()
&#125;

handleToggle = () =&gt; &#123;
 this.setState(&#123;
   toggle: !this.state.toggle
 &#125;)
&#125;

render() &#123;
 return (
   &lt;Toolbar /&gt;
 )
&#125;
&#125;</code></pre>
</li>
<li><p>实例化React.createContext</p>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;;
import &#123; Toolbar &#125; from &#39;./Toolbar&#39;;

//React.createContext(&#123;&#125;)里面有两个对象,Provider和Consumer,可以自定义一个contextName,在这里直接解构并export出去
export const &#123; Provider, Consumer&#125; = React.createContext(&#123;&#125;)

export class ContextDemo extends React.Component &#123;

  state = &#123;
    toggle: true,
    handleToggle: () =&gt; this.handleToggle()
  &#125;

  handleToggle = () =&gt; &#123;
    this.setState(&#123;
      toggle: !this.state.toggle
    &#125;)
  &#125;

  render() &#123;
    return (
     //Provider value存放需要共享出去的数据
      &lt;Provider value=&#123;this.state&#125;&gt;
        &lt;Toolbar /&gt;
      &lt;/Provider&gt;
    )
  &#125;
&#125;</code></pre>
</li>
<li><p>Toolbar组件</p>
<pre><code>import React, &#123; Component &#125; from &#39;react&#39;;
import &#123; Consumers &#125; from &#39;./Consumers&#39;;

export function Toolbar(props) &#123;
  return (
    &lt;div&gt;
      &lt;Consumers /&gt;
    &lt;/div&gt;
  );
&#125;</code></pre>
</li>
<li><p>Consumers组件</p>
<pre><code>import React from &#39;react&#39;;

//这里引入从ContextDemo中export的Consumer
import &#123; Consumer&#125; from &#39;./index.js&#39; 

export class Consumers extends React.Component &#123;
  render() &#123;
    return &lt;Consumer&gt;
      &#123;
      //注意这里是一个箭头函数,可以解构出来他们的参数
        (&#123; toggle, handleToggle&#125;) =&gt;
          &lt;button onClick=&#123;() =&gt; handleToggle()&#125;&gt;
            &#123;toggle ? &#39;✔&#39; : &#39;❌&#39;&#125;
          &lt;/button&gt;
      &#125;
    &lt;/Consumer&gt;
  &#125;
&#125;</code></pre>
</li>
<li><p>效果</p>
<ul>
<li><p>浏览器查看结果</p>
<p><img src="https://s1.ax1x.com/2020/11/11/Bjs5X4.png"></p>
</li>
<li><p><img src="https://s1.ax1x.com/2020/11/11/BjsLh6.gif"></p>
</li>
</ul>
</li>
</ul>
<p><a href="https://github.com/JuntengMa/react_demo_js">demo代码</a></p>
<p>06/ 注意事项</p>
<p>react官网写的很明白,context是一个实验性的api,在未来的版本中可能会被移除,还是尽量谨慎使用吧….</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>在react中实现文本复制</title>
    <url>/2020/09/22/React/React-%E6%96%87%E6%9C%AC%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>‘在react中实现文本复制’</p>
<a id="more"></a>

<h2 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h2><pre><code class="js">copyTranslateResult = () =&gt; &#123;
        const copyDOM = document.querySelector(&#39;.translateResult&#39;);

        if (copyDOM.innerHTML !== &#39;&#39;) &#123;

            var range = document.createRange(); //创建一个range

            window.getSelection().removeAllRanges(); //清楚页面中已有的selection

            range.selectNode(copyDOM); // 选中需要复制的节点

            window.getSelection().addRange(range); // 执行选中元素

            var successful = document.execCommand(&#39;copy&#39;); // 执行 copy 操作

            if (successful) &#123;
                                //这里使用了antd的message组件
                message.success(&#39;复制成功！&#39;);

            &#125; else &#123;
                                //这里使用了antd的message组件
                message.warning(&#39;复制失败，请手动复制！&#39;);
            &#125;
            // 移除选中的元素
            window.getSelection().removeAllRanges();
        &#125; else &#123;
            message.warning(&#39;没有内容&#39;);
        &#125;

    &#125;;</code></pre>
<h2 id="方案二-推荐该方案，方案一自测ios不兼容-："><a href="#方案二-推荐该方案，方案一自测ios不兼容-：" class="headerlink" title="方案二(推荐该方案，方案一自测ios不兼容)："></a>方案二(推荐该方案，方案一自测ios不兼容)：</h2><p><a href="https://ant.design/docs/react/recommendation-cn">antd社区精选组件推荐</a>: <strong><a href="https://github.com/nkbt/react-copy-to-clipboard">react-copy-to-clipboard</a>：</strong></p>
<h4 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h4><pre><code>npm install --save react-copy-to-clipboard
or
yarn add react-copy-to-clipboard</code></pre>
<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><pre><code class="jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import &#123;CopyToClipboard&#125; from &#39;react-copy-to-clipboard&#39;;

class App extends React.Component &#123;
  state = &#123;
    value: &#39;&#39;,
    copied: false,
  &#125;;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;input value=&#123;this.state.value&#125;
          onChange=&#123;(&#123;target: &#123;value&#125;&#125;) =&gt; this.setState(&#123;value, copied: false&#125;)&#125; /&gt;

        &lt;CopyToClipboard text=&#123;this.state.value&#125;
          onCopy=&#123;() =&gt; this.setState(&#123;copied: true&#125;)&#125;&gt;
          &lt;span&gt;Copy to clipboard with span&lt;/span&gt;
        &lt;/CopyToClipboard&gt;

        &lt;CopyToClipboard text=&#123;this.state.value&#125;
          onCopy=&#123;() =&gt; this.setState(&#123;copied: true&#125;)&#125;&gt;
          &lt;button&gt;Copy to clipboard with button&lt;/button&gt;
        &lt;/CopyToClipboard&gt;

        &#123;this.state.copied ? &lt;span style=&#123;&#123;color: 'red'&#125;&#125;&gt;Copied.&lt;/span&gt; : null&#125;
      &lt;/div&gt;
    );
  &#125;
&#125;

const appRoot = document.createElement(&#39;div&#39;);
document.body.appendChild(appRoot);
ReactDOM.render(&lt;App /&gt;, appRoot);
</code></pre>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React - diffView</title>
    <url>/2020/09/18/React/React-diffView/</url>
    <content><![CDATA[<p>文档对比组件封装…</p>
<a id="more"></a>


<h1 id="react-diff-view"><a href="#react-diff-view" class="headerlink" title="react-diff-view"></a>react-diff-view</h1><p><a href="https://github.com/praneshr/react-diff-viewer.git">https://github.com/praneshr/react-diff-viewer.git</a></p>
<h1 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h1><pre><code>yarn add react-diff-viewer

# or

npm i react-diff-viewer</code></pre>
<h1 id="封装组件-DiffView-tsx"><a href="#封装组件-DiffView-tsx" class="headerlink" title="封装组件 DiffView.tsx"></a>封装组件 DiffView.tsx</h1><pre><code>import * as React from &#39;react&#39;;

import ReactDiffViewer from &#39;react-diff-viewer&#39;;

export interface DiffViewProps &#123;
    oldValue: string;
    newValue: string;
    splitView?: boolean; //true 分两栏 | false  分一栏
    leftTitle?: string;
    rightTitle?: string;
    style?: object
&#125;

export class DiffView extends React.Component&lt;DiffViewProps&gt; &#123;
    public render() &#123;
        const &#123; oldValue, newValue, splitView = true, leftTitle, rightTitle, style &#125; = this.props;
        return (
            &lt;div style=&#123;&#123;
				...style,
				overflowY: 'scroll',
				wordWrap: 'break-word',
				wordBreak: 'break-all'
			&#125;&#125;&gt;
                &lt;ReactDiffViewer
                    oldValue=&#123;oldValue&#125;
                    newValue=&#123;newValue&#125;
                    splitView=&#123;splitView&#125;
                    leftTitle=&#123;leftTitle&#125;
                    rightTitle=&#123;rightTitle&#125;
                /&gt;
            &lt;/div&gt;

        );
    &#125;
&#125;

</code></pre>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p><a href="https://github.com/praneshr/react-diff-viewer#props">https://github.com/praneshr/react-diff-viewer#props</a></p>
<table>
<thead>
<tr>
<th>Prop</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>oldValue</td>
<td><code>string</code></td>
<td><code>&#39;&#39;</code></td>
<td>Old value as string.</td>
</tr>
<tr>
<td>newValue</td>
<td><code>string</code></td>
<td><code>&#39;&#39;</code></td>
<td>New value as string.</td>
</tr>
<tr>
<td>splitView</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td>Switch between <code>unified</code> and <code>split</code> view.</td>
</tr>
<tr>
<td>disableWordDiff</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>Show and hide word diff in a diff line.</td>
</tr>
<tr>
<td>compareMethod</td>
<td><code>DiffMethod</code></td>
<td><code>DiffMethod.CHARS</code></td>
<td>JsDiff text diff method used for diffing strings. Check out the <a href="https://github.com/praneshr/react-diff-viewer/tree/v3.0.0#text-block-diff-comparison">guide</a> to use different methods.</td>
</tr>
<tr>
<td>hideLineNumbers</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>Show and hide line numbers.</td>
</tr>
<tr>
<td>renderContent</td>
<td><code>function</code></td>
<td><code>undefined</code></td>
<td>Render Prop API to render code in the diff viewer. Helpful for <a href="https://github.com/praneshr/react-diff-viewer#syntax-highlighting">syntax highlighting</a></td>
</tr>
<tr>
<td>onLineNumberClick</td>
<td><code>function</code></td>
<td><code>undefined</code></td>
<td>Event handler for line number click. <code>(lineId: string) =&gt; void</code></td>
</tr>
<tr>
<td>highlightLines</td>
<td><code>array[string]</code></td>
<td><code>[]</code></td>
<td>List of lines to be highlighted. Works together with <code>onLineNumberClick</code>. Line number are prefixed with <code>L</code> and <code>R</code> for the left and right section of the diff viewer, respectively. For example, <code>L-20</code> means 20th line in the left pane. To highlight a range of line numbers, pass the prefixed line number as an array. For example, <code>[L-2, L-3, L-4, L-5]</code> will highlight the lines <code>2-5</code> in the left pane.</td>
</tr>
<tr>
<td>showDiffOnly</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td>Shows only the diffed lines and folds the unchanged lines</td>
</tr>
<tr>
<td>extraLinesSurroundingDiff</td>
<td><code>number</code></td>
<td><code>3</code></td>
<td>Number of extra unchanged lines surrounding the diff. Works along with <code>showDiffOnly</code>.</td>
</tr>
<tr>
<td>codeFoldMessageRenderer</td>
<td><code>function</code></td>
<td><code>Expand &#123;number&#125; of lines ...</code></td>
<td>Render Prop API to render code fold message.</td>
</tr>
<tr>
<td>styles</td>
<td><code>object</code></td>
<td><code>&#123;&#125;</code></td>
<td>To override style variables and styles. Learn more about <a href="https://github.com/praneshr/react-diff-viewer#overriding-styles">overriding styles</a></td>
</tr>
<tr>
<td>useDarkTheme</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td>To enable/disable dark theme.</td>
</tr>
<tr>
<td>leftTitle</td>
<td><code>string</code></td>
<td><code>undefined</code></td>
<td>Column title for left section of the diff in split view. This will be used as the only title in inline view.</td>
</tr>
<tr>
<td>rightTitle</td>
<td><code>string</code></td>
<td><code>undefined</code></td>
<td>Column title for right section of the diff in split view. This will be ignored in inline view.</td>
</tr>
<tr>
<td>linesOffset</td>
<td><code>number</code></td>
<td><code>0</code></td>
<td>Number to start count code lines from.</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>Css文本超出自动换行</title>
    <url>/2020/09/18/Css/Css%E6%96%87%E6%9C%AC%E8%B6%85%E5%87%BA%E8%87%AA%E5%8A%A8%E6%8D%A2%E8%A1%8C/</url>
    <content><![CDATA[<pre><code>word-wrap:break-word; 
word-break:break-all; 
overflow: hidden;/*这个参数根据需要来决定要不要*/</code></pre>
]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>React-antd-ImportExcel</title>
    <url>/2020/09/04/React/React-antd-ImportExcel/</url>
    <content><![CDATA[<center>“基于 XLSX 封装的  Excel 并解析为 JSON格式数据的组件”</center>

<a id="more"></a>


<h1 id="React-antd-ImportExcel"><a href="#React-antd-ImportExcel" class="headerlink" title="React-antd-ImportExcel"></a>React-antd-ImportExcel</h1><p>工作需求，需要</p>
<pre><code class="js">import * as React from &#39;react&#39;;

import * as XLSX from &#39;xlsx&#39;;

import &#123; Button, Icon, message &#125; from &#39;antd&#39;;

export interface ImportExcelProps &#123;
    getFileInfo: Function;
    notice?: string;
&#125;

//css文件为以下注释样式
import &#39;./uploadStyle.css&#39;;
&lt;!--
.uploadBtn &#123;
    position: absolute;
    font-size: 5px;
    width: &#39;100%&#39;;
    height: &#39;100%&#39;;
    right: 0;
    top: 0;
    opacity: 0;
    filter: alpha(opacity = 0);
    cursor: pointer;
&#125;
--&gt;

export class ImportExcel extends React.Component&lt;ImportExcelProps, any&gt; &#123;

    importExcel = file =&gt; &#123;
        // 获取上传的文件对象
        const &#123; files &#125; = file.target;
        // 通过FileReader对象读取文件
        const fileReader = new FileReader();
        fileReader.onload = event =&gt; &#123;
            try &#123;
                const &#123; result &#125; = event.target;
                // 以二进制流方式读取得到整份excel表格对象
                const workbook = XLSX.read(result, &#123; type: &#39;binary&#39; &#125;);
                let data = []; // 存储获取到的数据
                // 遍历每张工作表进行读取（这里默认只读取第一张表）
                for (const sheet in workbook.Sheets) &#123;
                    if (workbook.Sheets.hasOwnProperty(sheet)) &#123;
                        // 利用 sheet_to_json 方法将 excel 转成 json 数据
                        data = data.concat(XLSX.utils.sheet_to_json(workbook.Sheets[sheet]));
                        break; // 如果只取第一张表，就取消注释这行
                    &#125;
                &#125;
                //这里获取解析好的excel内容
                this.props.getFileInfo(data)
            &#125; catch (e) &#123;
                // 这里可以抛出文件类型错误不正确的相关提示
                message.warning(&#39;error&#39;)
            &#125;
        &#125;;
        // 以二进制方式打开文件
        files.length &gt; 0 &amp;&amp; fileReader.readAsBinaryString(files[0]);
    &#125;

    render() &#123;
        const &#123; notice &#125; = this.props
        return (
            &lt;Button type=&quot;primary&quot; style=&#123;&#123; position: 'relative' &#125;&#125;&gt;
                &lt;input type=&#39;file&#39; accept=&#39;.xlsx, .xls&#39; onChange=&#123;e =&gt; this.importExcel(e)&#125; className=&quot;uploadBtn&quot; /&gt;&#123;notice || &#39;导入Excel&#39;&#125;
                &lt; Icon type=&quot;upload&quot; /&gt;
            &lt;/Button&gt;
        );
    &#125;
&#125;
</code></pre>
<p>使用</p>
<pre><code class="js">//getFileInfo 用于获取解析出来的数据，按需写接收函数
&lt;ImportExcel getFileInfo=&#123;getFileInfo&#125; notice=&quot;导入EXcel&quot; /&gt;</code></pre>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React-antd-exportExcel</title>
    <url>/2020/09/04/React/React-antd-exportExcel/</url>
    <content><![CDATA[<center> “基于 XLSX 封装的 excel 导出组件”</center>

<a id="more"></a>

<pre><code class="js">import * as React from &quot;react&quot;

import * as XLSX from &quot;xlsx&quot;

import &#123; Button, Icon &#125; from &quot;antd&quot;

export interface ExportExcelProps &#123;
  notice: string;
  fileName: string;
  headers: string[] | Function; //表头
  getExportData: Function;
&#125;

export class ExportExcel extends React.Component&lt;ExportExcelProps, any&gt; &#123;
  handleExport = async () =&gt; &#123;
    const &#123; headers, fileName &#125; = this.props
    //这里是获取导出数据的函数
    const exportData = await this.props.getExportData()

    this.exportExcel(headers, exportData, fileName)
  &#125;

  exportExcel(headers, data, fileName) &#123;
    const _headers = headers
      .map((item, i) =&gt;
        Object.assign(
          &#123;&#125;,
          &#123;
            key: item.key,
            title: item.title,
            position: String.fromCharCode(65 + i) + 1,
          &#125;
        )
      )
      .reduce(
        (prev, next) =&gt;
          Object.assign(&#123;&#125;, prev, &#123;
            [next.position]: &#123; key: next.key, v: next.title &#125;,
          &#125;),
        &#123;&#125;
      )

    const _data = data
      .map((item, i) =&gt;
        headers.map((key, j) =&gt;
          Object.assign(
            &#123;&#125;,
            &#123;
              content: item[key.key],
              position: String.fromCharCode(65 + j) + (i + 2),
            &#125;
          )
        )
      )
      // 对刚才的结果进行降维处理（二维数组变成一维数组）
      .reduce((prev, next) =&gt; prev.concat(next))
      // 转换成 worksheet 需要的结构
      .reduce(
        (prev, next) =&gt;
          Object.assign(&#123;&#125;, prev, &#123; [next.position]: &#123; v: next.content &#125; &#125;),
        &#123;&#125;
      )

    // 合并 headers 和 data
    const output = Object.assign(&#123;&#125;, _headers, _data)
    // 获取所有单元格的位置
    const outputPos = Object.keys(output)
    // 计算出范围 ,[&quot;A1&quot;,..., &quot;H2&quot;]
    const ref = `$&#123;outputPos[0]&#125;:$&#123;outputPos[outputPos.length - 1]&#125;`

    // 构建 workbook 对象
    const wb = &#123;
      SheetNames: [&quot;mySheet&quot;],
      Sheets: &#123;
        mySheet: Object.assign(
          &#123;&#125;,
          output, //列宽
          &#123;
            &quot;!ref&quot;: ref,
            &quot;!cols&quot;: [
              &#123; wpx: 150 &#125;,
              &#123; wpx: 150 &#125;,
              &#123; wpx: 150 &#125;,
              &#123; wpx: 150 &#125;,
              &#123; wpx: 150 &#125;,
              &#123; wpx: 150 &#125;,
              &#123; wpx: 150 &#125;,
              &#123; wpx: 150 &#125;,
            ],
          &#125;
        ),
      &#125;,
    &#125;
    // 导出 Excel
    XLSX.writeFile(wb, `$&#123;fileName&#125;.xlsx`)
  &#125;
  render() &#123;
    const &#123; notice &#125; = this.props
    return (
      &lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; this.handleExport()&#125;&gt;
        &#123;notice&#125;
        &lt;Icon type=&quot;download&quot; /&gt;
      &lt;/Button&gt;
    )
  &#125;
&#125;</code></pre>
<p>使用</p>
<pre><code class="js">&lt;ExportExcel
  notice=&quot;Excel导出&quot;
  fileName=&quot;test&quot;
  headers=&#123;initColumn&#125;
  getExportData=&#123;exportData&#125;
/&gt;</code></pre>
<p>示例表头&amp;数据：</p>
<pre><code class="js">header=[
    &#123;
        title: 姓名,
        dataIndex: name,
        key: name,
    &#125;,
    &#123;
        title: 性别,
        dataIndex: sex,
        key: sex,
    &#125;,
    &#123;
        title: 年龄,
        dataIndex: age,
        key: age,
    &#125;,
]

exportData=[
    &#123;
    name:&#39;小明&#39;，
    sex:&#39;男&#39;，
    age:18
    &#125;,
    &#123;
    name:&#39;小张&#39;，
    sex:&#39;女&#39;，
    age:20
    &#125;
]</code></pre>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/2020/09/02/JavaScript/JavaScript-ES6/</url>
    <content><![CDATA[<blockquote>
<h4> 
 ES6
</h4>
</blockquote>
<a id="more"></a>



<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h4 id="ES6是什么"><a href="#ES6是什么" class="headerlink" title="ES6是什么"></a>ES6是什么</h4><p>es6是ECMA为JavaScript订制的第6个版本,2015年6月发行,涵盖了2015 - 2020</p>
<h4 id="ES6特性"><a href="#ES6特性" class="headerlink" title="ES6特性"></a>ES6特性</h4><ul>
<li>表达式<ul>
<li>[声明 (let/const)](#### 声明)</li>
<li>解构赋值</li>
</ul>
</li>
<li>内置对象<ul>
<li>字符串扩展</li>
<li>数值扩展</li>
<li>对象扩展</li>
<li>数组扩展</li>
<li>函数扩展</li>
<li>正则扩展</li>
<li>Symbol / set /Map / Proxy /Reflect</li>
</ul>
</li>
<li>语句与运算<ul>
<li>class</li>
<li>Module</li>
<li>Iterator</li>
</ul>
</li>
<li>异步编程<ul>
<li>Promise</li>
<li>Generator</li>
<li>Async</li>
</ul>
</li>
</ul>
<h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><ul>
<li>let (声明变量,类似var,但是只在代码块中有效)<ul>
<li>let声明的变量只在所处于的块级有效；</li>
<li>let没有‘变量提升’的特性，而是‘暂时性死区（temporal dead zone）’特性</li>
</ul>
</li>
<li>const (声明常量)<ul>
<li>声明恒定变量，声明的同时就必须赋值，否则会报错</li>
</ul>
</li>
</ul>
<h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域:"></a>块级作用域:</h4><h5 id="ES6之前"><a href="#ES6之前" class="headerlink" title="ES6之前"></a>ES6之前</h5><ul>
<li>全局作用域</li>
<li>函数作用域</li>
</ul>
<p>因此会产生变量提升的问题</p>
<pre><code>function func()&#123;
    console.log(test);
    var test = 1;
&#125;;
func();
//undefind
在进入func之前,所有通过var声明的变量提前声明并赋予undefinded值</code></pre>
<h5 id="ES6-1"><a href="#ES6-1" class="headerlink" title="ES6"></a>ES6</h5><ul>
<li>全局作用域</li>
<li>函数作用域</li>
<li>块级作用域</li>
</ul>
<pre><code>function f1() &#123;
  let n = 5;
  if (true) &#123;
    let n = 10;
  &#125;
  console.log(n); // 5
&#125;


function f1() &#123;
  var n = 5;
  if (true) &#123;
    var n = 10;
  &#125;
  console.log(n); // 10
&#125;</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript获取元素位置</title>
    <url>/2020/09/01/JavaScript/JavaScript-%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%9D%90%E6%A0%87%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<h4> 
 JavaScript获取元素位置
</h4>
</blockquote>
<a id="more"></a>
<h2 id="js获取元素相对于父级元素的高度"><a href="#js获取元素相对于父级元素的高度" class="headerlink" title="js获取元素相对于父级元素的高度"></a>js获取元素相对于父级元素的高度</h2><h4 id="1-offsetLeft-、offsetTop"><a href="#1-offsetLeft-、offsetTop" class="headerlink" title="1. offsetLeft 、offsetTop"></a>1. offsetLeft 、offsetTop</h4><p>offsetLeft/offsetTop -  用于获取子元素相对于父元素的位移（左位移、上位移）</p>
<h4 id="2-offsetWidth、offsetHeight"><a href="#2-offsetWidth、offsetHeight" class="headerlink" title="2. offsetWidth、offsetHeight"></a>2. offsetWidth、offsetHeight</h4><p>offsetWidth/offsetHeight - 用于获取元素的可见宽度和可见高度</p>
<h4 id="3-clientX-、clientY"><a href="#3-clientX-、clientY" class="headerlink" title="3. clientX 、clientY"></a>3. clientX 、clientY</h4><p>用于获取鼠标坐标（相对于页面的坐标）</p>
<p>var event = event || window.event;</p>
<ul>
<li>event.clientX</li>
<li>event.clientY</li>
</ul>
<h4 id="4-offsetLeft与style-left的区别"><a href="#4-offsetLeft与style-left的区别" class="headerlink" title="4.offsetLeft与style.left的区别"></a>4.offsetLeft与style.left的区别</h4><ol>
<li>    <ul>
<li>style.left返回的是字符串      //30px</li>
<li>offsetLeft返回的是数值        //30</li>
</ul>
</li>
<li>    <ul>
<li>style.left可读可写</li>
<li>offsetLeft只读</li>
</ul>
</li>
<li>     <ul>
<li>style.left的值需事先定义，否则取到的值为空</li>
<li>offsetLeft不需提前定义，直接获取</li>
</ul>
</li>
</ol>
<h4 id="5-兼容问题"><a href="#5-兼容问题" class="headerlink" title="5.兼容问题"></a>5.兼容问题</h4><pre><code>chrome：

e.pageX——相对整个页面的坐标
e.layerX——相对当前坐标系的border左上角开始的坐标
e.offsetX——相对当前坐标系的border左上角开始的坐标
e.clientX——相对可视区域的坐标
e.x——相对可视区域的坐标

ff：

e.pageX——相对整个页面的坐标
e.layerX——相对当前坐标系的border左上角开始的坐标
e.offsetX——无
e.clientX——相对可视区域的坐标
e.x——无

opera：

e.pageX——相对整个页面的坐标
e.layerX——无
e.offsetX——相对当前坐标系的内容区域左上角开始的坐标
e.clientX——相对可视区域的坐标
e.x——相对可视区域的坐标

safari：（这个和chrome是一样的）

e.pageX——相对整个页面的坐标
e.layerX——相对当前坐标系的border左上角开始的坐标
e.offsetX——相对当前坐标系的border左上角开始的坐标
e.clientX——相对可视区域的坐标
e.x——相对可视区域的坐标

IE9：

e.pageX——相对整个页面的坐标
e.layerX——相对当前坐标系的border左上角开始的坐标 + 滚动条滚过的距离（这个NB轰轰了····=。=）
e.offsetX——相对当前坐标系的内容区域左上角开始的坐标
e.clientX——相对可视区域的坐标
e.x——相对当前坐标系的border左上角开始

IE8：

e.pageX——无
e.layerX——无
e.offsetX——相对当前坐标系的内容区域左上角开始的坐标
e.clientX——相对可视区域的坐标
e.x——相对当前坐标系的border左上角开始

IE7：

e.pageX——无
e.layerX——无
e.offsetX——相对当前坐标系的内容区域左上角开始的坐标
e.clientX——相对可视区域的坐标
e.x——相对当前坐标系的border左上角开始

IE6：

e.pageX——无
e.layerX——无
e.offsetX——相对当前坐标系的内容区域左上角开始的坐标
e.clientX——相对可视区域的坐标
e.x——相对当前坐标系的border左上角开始</code></pre>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
