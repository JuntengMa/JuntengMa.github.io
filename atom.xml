<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>June&#39;s Blog</title>
  
  
  <link href="https://juntengma.github.io/atom.xml" rel="self"/>
  
  <link href="https://juntengma.github.io/"/>
  <updated>2020-10-30T09:00:13.846Z</updated>
  <id>https://juntengma.github.io/</id>
  
  <author>
    <name>June</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Https及其加密原理</title>
    <link href="https://juntengma.github.io/2020/10/30/Https/"/>
    <id>https://juntengma.github.io/2020/10/30/Https/</id>
    <published>2020-10-30T08:59:24.175Z</published>
    <updated>2020-10-30T09:00:13.846Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="Https" scheme="https://juntengma.github.io/categories/Https/"/>
    
    
    <category term="Https" scheme="https://juntengma.github.io/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>Http</title>
    <link href="https://juntengma.github.io/2020/10/30/Http/"/>
    <id>https://juntengma.github.io/2020/10/30/Http/</id>
    <published>2020-10-30T08:49:32.136Z</published>
    <updated>2020-10-30T09:19:17.633Z</updated>
    
    <content type="html"><![CDATA[<p>HTTPS的一些知识</p><a id="more"></a><h3 id="1-什么是HTTP协议"><a href="#1-什么是HTTP协议" class="headerlink" title="1/什么是HTTP协议"></a>1/什么是HTTP协议</h3><ul><li>HTTP协议是超文本传输协议的简称,规定了服务端和客户端(前后端)通信方式以及占用的接口</li><li>HTTP协议是一个局域TCP/IP通信协议来传输数据的</li></ul><h3 id="2-HTTP协议的特性"><a href="#2-HTTP协议的特性" class="headerlink" title="2/HTTP协议的特性"></a>2/HTTP协议的特性</h3><ul><li>HTTP协议支持客户端/服务端模式,也是一种请求/响应模式的协议</li><li>简单快速,客户端向服务器请求服务时,只需要提供请求方法和URL.常用的有 GET,PSOT,DELETE,HEAD等</li><li>无连接:HTTP协议规定浏览器和服务端只能保持短暂的链接,浏览器的每次请求都需要与服务器建立一个TCP链接,服务器处理完成后立即断开TCP链接</li><li>无状态:无状态是指服务器不跟踪也不记录请求过的状态,后续如果需要前面的信息,必须重传.</li><li>但是可以借助cookie和session记住来做身份认证和状态记录</li></ul><h3 id="3-HTTP报文组成"><a href="#3-HTTP报文组成" class="headerlink" title="3/HTTP报文组成"></a>3/HTTP报文组成</h3><h4 id="请求报问构成"><a href="#请求报问构成" class="headerlink" title="请求报问构成"></a>请求报问构成</h4><ul><li>请求行</li><li>请求头(Request Header)</li><li>请求正文</li></ul><h4 id="响应报文构成"><a href="#响应报文构成" class="headerlink" title="响应报文构成"></a>响应报文构成</h4><ul><li>状态行</li><li>响应头(Response Header)</li><li>响应正文</li></ul><h3 id="4-常见请求方法"><a href="#4-常见请求方法" class="headerlink" title="4/常见请求方法"></a>4/常见请求方法</h3><ul><li>GET</li><li>POST</li><li>HEAD:类似GET请求,但是返回的响应中没有具体内容,用于获取报头</li><li>PUT:从客户端向服务器传送的数据取代指定的文档的内容</li><li>DELETE:请求服务器删除指定页面</li></ul><h3 id="5-响应状态码"><a href="#5-响应状态码" class="headerlink" title="5/响应状态码"></a>5/响应状态码</h3><p>状态码分类：</p><ul><li>1XX- 信息型，服务器收到请求，需要请求者继续操作。</li><li>2XX- 成功型，请求成功收到，理解并处理。</li><li>3XX - 重定向，需要进一步的操作以完成请求。</li><li>4XX - 客户端错误，请求包含语法错误或无法完成请求。</li><li>5XX - 服务器错误，服务器在处理请求的过程中发生了错误。</li></ul><h3 id="6-常见状态码"><a href="#6-常见状态码" class="headerlink" title="6/常见状态码"></a>6/常见状态码</h3><ul><li>200:请求成功</li><li>204:无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>301:永久移动。请求的资源已被永久的重定向到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302:临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>304:未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>400:客户端请求的语法错误，服务器无法理解</li><li>401:请求要求用户的身份认证</li><li>403:服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404:服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>422:请求格式正确，但是由于含有语义错误，无法响应。</li><li>500:服务器内部错误，无法完成请求</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;HTTPS的一些知识&lt;/p&gt;</summary>
    
    
    
    <category term="Http" scheme="https://juntengma.github.io/categories/Http/"/>
    
    
    <category term="Http" scheme="https://juntengma.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://juntengma.github.io/2020/10/30/%E7%AE%97%E6%B3%95/"/>
    <id>https://juntengma.github.io/2020/10/30/%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-30T03:39:39.217Z</published>
    <updated>2020-10-30T11:14:46.209Z</updated>
    
    <content type="html"><![CDATA[<p>复习做的几个算法练习题/…</p><a id="more"></a><p>一、不借助临时变量，进行两个整数的交换</p><pre><code>let a = 1, b = 2;[a, b] = [b, a]console.log(a, b);</code></pre><p>二、字符串查找：请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。<br>🌰:</p><pre><code>a=&#39;34&#39;;b=&#39;1234567&#39;; // 返回 2a=&#39;35&#39;;b=&#39;1234567&#39;; // 返回 -1a=&#39;355&#39;;b=&#39;12354355&#39;; // 返回 5isContain(a,b);</code></pre><p>三、统计一个字符串出现最多的字母：给出一段英文连续的英文字符窜，找出重复出现次数最多的字母。<br>🌰:</p><pre><code>输入 ： afjghdfraaaasdenas输出 ： a</code></pre><pre><code>function hasMost(str) &#123;  let counts = &#123;&#125;  for (let item of str) &#123;    counts[`$&#123;item&#125;`] = 0    for (let j of str) &#123;      if (j === item) &#123;        counts[`$&#123;item&#125;`] = counts[`$&#123;item&#125;`] + 1;      &#125;    &#125;  &#125;  getMax(counts)&#125;function getMax(counts) &#123;  let maxValue = 0  let maxItem = &#39;&#39;  for (let item in counts) &#123;    if (counts[item] &gt; maxValue) &#123;      maxValue = counts[item]      maxItem = item    &#125;  &#125;  console.log(maxItem, maxValue)&#125;</code></pre><p>四、找出下列正数组的最大差值<br>🌰:</p><pre><code>输入 [10,5,11,7,8,9]输出 6</code></pre><pre><code>function getDifferenceValue(arr) &#123;  let maxNum = null, minNum = null  arr.forEach(item =&gt; &#123;    !maxNum ? maxNum = item : !minNum ? minNum = item : null    item &gt; maxNum      ? maxNum = item      : item &lt; minNum        ? minNum = item        : minNum  &#125;)  console.log(maxNum, minNum)  console.log(maxNum - minNum)&#125;</code></pre><p>五、斐波那契数列：1、1、2、3、5、8、13、21。输入n，输出数列中第n位数的值。<br>🌰:</p><pre><code>function getValue(num) &#123;  if (num &lt; 2) &#123;    return 1  &#125; else &#123;    return (getValue(num - 1) + getValue(num - 2))  &#125;&#125;</code></pre><p>六、用js实现二分查找：二分查找的前提是有序数组</p><pre><code>🌰:将要查找的值每次与中间值比较，大于中间值，则在右边进行相同的查找，小于中间值则在左边进行比较查找，找到返回索引值，没找到返回-1。</code></pre><p>var missingNumber = function (nums) {<br>  let left = 0, right = nums.length - 1;<br>  while (left &lt;= right) {<br>    let mid = Math.floor((left + right) / 2);<br>    if (mid === nums[mid]) {<br>      left = mid + 1;<br>    } else if (mid &lt; nums[mid]) {<br>      right = mid - 1;<br>    }<br>  }<br>  return left;<br>};</p><p>```<br>七、数组去重</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习做的几个算法练习题/…&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://juntengma.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Http各版本特性及其区别</title>
    <link href="https://juntengma.github.io/2020/10/29/Http%E7%89%88%E6%9C%AC%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7/"/>
    <id>https://juntengma.github.io/2020/10/29/Http%E7%89%88%E6%9C%AC%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7/</id>
    <published>2020-10-29T08:21:42.848Z</published>
    <updated>2020-10-30T11:15:50.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP各版本特性及区别"><a href="#HTTP各版本特性及区别" class="headerlink" title="HTTP各版本特性及区别"></a>HTTP各版本特性及区别</h3><a id="more"></a><p>本文参考:<br><a href="https://juejin.im/post/6844903923136856078">https://juejin.im/post/6844903923136856078</a><br><a href="https://segmentfault.com/a/1190000019891825">https://segmentfault.com/a/1190000019891825</a></p><p>HTTP 是基于 TCP/IP 协议的一个应用层协议，是现代互联网的一个基础协议。规定了客户端与服务端之间的通信格式以及所占用的服务端口80(HTTPS是443)。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>HTTP 协议从开始立项到现在一共经历了 4 个版本:</p><pre><code>HTTP 0.9 -&gt; HTTP 1.0 -&gt; HTTP 1.1 -&gt; HTTP 2</code></pre><h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h4><p>HTTP 0.9 是一个最古老的版本</p><p><strong>只支持GET请求方式</strong>：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息<br>没有请求头概念：所以不能在请求中指定版本号，<strong>服务端也只具有返回 HTML字符串的能力</strong><br><strong>服务端相响应之后，立即关闭TCP连接</strong></p><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h4><p>随着 HTTP 1.0 的发布，这个版本:</p><p>请求方式<strong>新增了POST，DELETE，PUT，HEADER等方式</strong><br>增添了<strong>请求头</strong>和<strong>响应头</strong>的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)<br>扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输<br>在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。</p><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p>一个简单请求的头信息</p><pre><code>GET / HTTP/1.0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */*</code></pre><p>浏览器控制台reponse headers<br><img src="https://s1.ax1x.com/2020/10/30/BtJAlF.png"></p><p>可以看到在请求方法之后有 请求资源的位置 + 请求协议版本，之后是一些客户端的信息配置</p><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p>一个简单响应的头信息(v1.0)</p><pre><code>HTTP/1.0 200 OKContent-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMT// 这是一个空行...数据内容</code></pre><p>浏览器控制台request headers<br><img src="https://s1.ax1x.com/2020/10/30/BtJfhV.png"></p><p>服务端的响应头第一个就是 请求协议版本，后面紧跟着是这次请求的状态码、以及状态码的描述，之后的内容是一些关于返回内容的描述。</p><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p>在 HTTP 1.0 的时候，任何的资源都可以被传输，传输的格式呢也是多种多样的，客户端在收到响应体的内容的时候就是根据这个 Content-Type 去进行解析的。所以<strong>服务端返回时候</strong>必须带着这个字段。<br><img src="https://s1.ax1x.com/2020/10/30/BtYKBj.png"><br>一些常见的 Content-Type 可以参考 对照表。 这些 Content-Type 有一个总称叫做<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a></p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>无状态：服务器不跟踪不记录请求过的状态</li><li><strong>无连接</strong>：<strong>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接）</strong></li></ul><h6 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h6><p>对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录</p><h6 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h6><p>无连接导致的性能缺陷有两种：</p><ul><li><strong>无法复用连接</strong><br>每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低</li><li><strong>队头阻塞</strong><br>HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</li></ul><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h4><p>  HTTP 1.1 是在 1.0 发布之后的半年就推出了，完善了 1.0 版本。目前也还有很多的互联网项目基于 HTTP 1.1 在向外提供服务。</p><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><p>长连接：新增Connection字段，可以设置keep-alive值保持连接不断开<br>管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回<br>缓存处理：新增字段cache-control<br>断点传输</p><h6 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h6><p>HTTP 1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据.</p><p>B站首页，就有keep-alive，因为他们也有IM的成分在里面。需要大量复用TCP连接～<br><img src="https://s1.ax1x.com/2020/10/30/Btt4L4.png"></p><h6 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h6><p>基于长连接的基础，我们先看没有管道化请求响应：</p><p>tcp没有断开，用的同一个通道</p><pre><code>--&gt; 请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3</code></pre><p>管道化的请求响应：</p><pre><code>--&gt; 请求1 --&gt; 请求2 --&gt; 请求3 --&gt; 响应1 --&gt; 响应2 --&gt; 响应3</code></pre><p>即使服务器先准备好响应2,也是按照请求顺序先返回响应1</p><p>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p><h6 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理:"></a>缓存处理:</h6><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。 通过设置字段cache-control来控制缓存。</p><p><strong>怎么解决解决队头阻塞的问题?</strong></p><blockquote><p>实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个TCP的会话。<br>也就是说，上图我们看到的并行，其实是不同的TCP连接上的HTTP请求和响应。这也就是我们所熟悉的浏览器对同域下并行加载6~8个资源的限制。而这，才是真正的并行！</p></blockquote><p><strong>浏览器同域名请求的最大并发数限制</strong></p><blockquote><p>当我们在浏览网页的时候，对浏览速度有一个重要的影响因素，就是浏览器的并发数量。并发数量简单通俗的讲就是，当浏览器网页的时候同时工作的进行数量。</p></blockquote><ul><li><p>HTTP客户端一般对同一个服务器的并发连接个数都是有限制的。<br>实际上，浏览器确实使用并行连接，但它们将并行连接的总数限制为少量（<strong>通常为四个</strong>）。服务器可以自由地关闭来自特定客户端的过多连接。</p></li><li><p>一些主流浏览器对HTTP 1.1和HTTP 1.0的最大并发连接数目，可以参考如下表格：</p></li></ul><p><img src="https://s1.ax1x.com/2020/10/30/BtcGjA.png"></p><h6 id="断点传输"><a href="#断点传输" class="headerlink" title="断点传输"></a>断点传输</h6><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p><h5 id="Http-1-1的致命缺点："><a href="#Http-1-1的致命缺点：" class="headerlink" title="Http 1.1的致命缺点："></a>Http 1.1的致命缺点：</h5><p>1.明文传输<br>2.其实还是没有解决无状态连接的<br>3.当有多个请求同时被挂起的时候,就会拥塞请求通道，导致后面请求无法发送<br>4.臃肿的消息首部:HTTP/1.1能压缩请求内容,但是消息首部不能压缩;在现今请求中,消息首部占请求绝大部分(甚至是全部)也较为常见.</p><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h4><h5 id="特性-2"><a href="#特性-2" class="headerlink" title="特性:"></a>特性:</h5><h6 id="二进制帧封装"><a href="#二进制帧封装" class="headerlink" title="二进制帧封装:"></a>二进制帧封装:</h6><p>HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率</p><h6 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用:"></a>多路复用:</h6><blockquote><p>所有的请求都是通过一个 TCP 连接并发完成。<br>HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。</p><p>同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。</p><p>即：HTTP2.0对于同一域名下所有请求都是基于流的，不管对于同一域名访问多少文件，也只建立一路连接。优先级高的流会被优先发送。图片请求的优先级要低于 CSS 和 SCRIPT，这个设计可以确保重要的东西可以被优先加载完</p></blockquote><h6 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩:"></a>头部压缩:</h6><p>由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源，</p><p>HTTPS 和 HTTP</p><ul><li>HTTPS 协议需要申请证书</li><li>HTTP 和 HTTPS 使用端口不一样，前者是80，后者是443</li><li>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li><li>HTTPS 可以有效的防止运营商劫持</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;HTTP各版本特性及区别&quot;&gt;&lt;a href=&quot;#HTTP各版本特性及区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP各版本特性及区别&quot;&gt;&lt;/a&gt;HTTP各版本特性及区别&lt;/h3&gt;</summary>
    
    
    
    <category term="Http" scheme="https://juntengma.github.io/categories/Http/"/>
    
    
    <category term="Http" scheme="https://juntengma.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>防抖节流及其应用场景</title>
    <link href="https://juntengma.github.io/2020/10/29/JavaScript%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>https://juntengma.github.io/2020/10/29/JavaScript%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2020-10-29T02:30:59.717Z</published>
    <updated>2020-10-29T07:40:03.647Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​    复习一下防抖节流及其应用场景</p></blockquote><a id="more"></a><h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><p>在事件被触发的n秒后再执行回调,如果在这n秒内又被触发,则重新计时</p><pre><code>function debounse(fun, delay) &#123;    let timer;    // 设置一个 timer    return function (args) &#123;      let _this = this      // 取debounce执行作用域的this      let _args = args      clearTimeout(timer)      timer = setTimeout(function () &#123;        fun.call(_this, args);      &#125;, delay);    &#125;  &#125;</code></pre><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p><pre><code>function throttle(fun, delay) &#123;    let last, deferTimer    return function (args) &#123;      let _this = this      let _args = arguments      let now = +new Date()      if (last &amp;&amp; now &lt; last + delay) &#123;        clearTimeout(deferTimer)        deferTimer = setTimeout(function () &#123;          last = now          fun.apply(_this, _args)        &#125;, delay)      &#125; else &#123;        last = now        fun.apply(_this, _args)      &#125;    &#125;  &#125;</code></pre><h3 id="demo"><a href="#demo" class="headerlink" title="demo:"></a>demo:</h3><h5 id="模拟ajax请求"><a href="#模拟ajax请求" class="headerlink" title="模拟ajax请求"></a>模拟ajax请求</h5><pre><code>function ajax(params) &#123;    console.log(&#39;ajax request : &#39; + params)&#125;</code></pre><h5 id="未加入节流"><a href="#未加入节流" class="headerlink" title="未加入节流:"></a>未加入节流:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252be5c94d6b?imageslim"></p><h5 id="加入防抖"><a href="#加入防抖" class="headerlink" title="加入防抖:"></a>加入防抖:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4b429b56?imageslim"></p><h5 id="加入节流"><a href="#加入节流" class="headerlink" title="加入节流:"></a>加入节流:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4c1a9686?imageslim"></p><h3 id="demo代码"><a href="#demo代码" class="headerlink" title="demo代码"></a>demo代码</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  没有防抖的Input &lt;input type=&quot;text&quot; class=&quot;unDebounce&quot;&gt;  &lt;br&gt;  加入防抖的Input &lt;input type=&quot;text&quot; class=&quot;debounce&quot;&gt;  &lt;br&gt;  加入截留的Input &lt;input type=&quot;text&quot; class=&quot;htrottle&quot;&gt;&lt;/body&gt;&lt;script&gt;  function ajax(params) &#123;    console.log(&#39;ajax request : &#39; + params)  &#125;  let inputValue0 = document.querySelector(&#39;.unDebounce&#39;)  inputValue0.addEventListener(&#39;keyup&#39;, function (e) &#123;    ajax(e.target.value)  &#125;)  /**********************防抖********************************/  function debounse(fun, delay) &#123;    let timer;    // 设置一个 timer    return function (args) &#123;      let _this = this      // 取debounce执行作用域的this      let _args = args      clearTimeout(timer)      timer = setTimeout(function () &#123;        fun.call(_this, args);      &#125;, delay);    &#125;  &#125;  let inputValue1 = document.querySelector(&#39;.debounce&#39;)  let debounse_ajax = debounse(ajax, 500)  inputValue1.addEventListener(&#39;keyup&#39;, function (e) &#123;    debounse_ajax(e.target.value)  &#125;)  /**********************节流********************************/  function throttle(fun, delay) &#123;    let last, deferTimer    return function (args) &#123;      let _this = this      let _args = arguments      let now = +new Date()      if (last &amp;&amp; now &lt; last + delay) &#123;        clearTimeout(deferTimer)        deferTimer = setTimeout(function () &#123;          last = now          fun.apply(_this, _args)        &#125;, delay)      &#125; else &#123;        last = now        fun.apply(_this, _args)      &#125;    &#125;  &#125;  let inputValue2 = document.querySelector(&#39;.htrottle&#39;)  let htrottle_ajax = throttle(ajax, 2000)  inputValue2.addEventListener(&#39;keyup&#39;, function (e) &#123;    htrottle_ajax(e.target.value)  &#125;)&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;​    复习一下防抖节流及其应用场景&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="防抖节流" scheme="https://juntengma.github.io/tags/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>JSON-Server</title>
    <link href="https://juntengma.github.io/2020/10/28/Json-server/"/>
    <id>https://juntengma.github.io/2020/10/28/Json-server/</id>
    <published>2020-10-28T11:04:41.772Z</published>
    <updated>2020-10-29T07:41:14.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h1><p>json-server 是什么？如何使用？</p><blockquote><p>json-server 是一个 npm 管理的包，可以提供前端提供mock的功能。</p></blockquote><a id="more"></a><h2 id="json-server-的使用"><a href="#json-server-的使用" class="headerlink" title="json-server 的使用"></a>json-server 的使用</h2><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1/安装"></a>1/安装</h4><p>全局安装:</p><pre><code>- yarn global add json-server- npm install -g json-server </code></pre><h4 id="2-提供一个json数据的文件"><a href="#2-提供一个json数据的文件" class="headerlink" title="2.提供一个json数据的文件"></a>2.提供一个json数据的文件</h4><h4 id="3-使用json-server命令开启一个端口服务"><a href="#3-使用json-server命令开启一个端口服务" class="headerlink" title="3.使用json-server命令开启一个端口服务"></a>3.使用json-server命令开启一个端口服务</h4><pre><code>json-server --watch --port 3000 test.json</code></pre><h4 id="4-接口的使用"><a href="#4-接口的使用" class="headerlink" title="4.接口的使用:"></a>4.接口的使用:</h4><blockquote><ol><li>列表</li></ol></blockquote><blockquote><ol start="2"><li>详情</li></ol></blockquote><blockquote><ol start="3"><li>分页</li></ol></blockquote><blockquote><ol start="4"><li>排序</li></ol></blockquote><blockquote><ol start="5"><li>全局查询<br>需要使用第三方接口调试工具的(postman)</li></ol></blockquote><blockquote><ol start="6"><li>提供 增加（post）、</li></ol></blockquote><blockquote><ol start="7"><li>删除(delete)、</li></ol></blockquote><blockquote><ol start="8"><li>更新(put)</li></ol></blockquote><p>我们常见的接口：都是 get 或者 post 请求一个 url 地址即可。<br>json-server 除了常见的 get 或者 post ，还提供了诸如 put 、delete 这样的HTTP请求方式，<strong>对于这种使用 http请求方式 + 请求url地址 形成的 api ，我们一般叫做 RESTFul 风格的api</strong>, <em>RESTFul 风格的api底层遵循的是 REST 架构这种协议。</em></p><p>倒叙:<a href="http://localhost:3000/news?sort=id&amp;order=desc">http://localhost:3000/news?sort=id&amp;order=desc</a> </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;json-server&quot;&gt;&lt;a href=&quot;#json-server&quot; class=&quot;headerlink&quot; title=&quot;json-server&quot;&gt;&lt;/a&gt;json-server&lt;/h1&gt;&lt;p&gt;json-server 是什么？如何使用？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;json-server 是一个 npm 管理的包，可以提供前端提供mock的功能。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Json-server" scheme="https://juntengma.github.io/categories/Json-server/"/>
    
    
    <category term="Json-server" scheme="https://juntengma.github.io/tags/Json-server/"/>
    
  </entry>
  
  <entry>
    <title>JSONP跨域请求及其原理</title>
    <link href="https://juntengma.github.io/2020/10/28/JsonP/"/>
    <id>https://juntengma.github.io/2020/10/28/JsonP/</id>
    <published>2020-10-28T10:46:25.938Z</published>
    <updated>2020-10-29T08:12:22.160Z</updated>
    
    <content type="html"><![CDATA[<p>JSONP及其原理</p><a id="more"></a><h5 id="1、JSONP的产生"><a href="#1、JSONP的产生" class="headerlink" title="1、JSONP的产生"></a>1、JSONP的产生</h5><p><strong>背景:</strong></p><ul><li><p>因为浏览器同源策略限制,AJAX跨域请求不到信息</p></li><li><p>Web页面上面调用js文件不受是否跨域影响(类似的还有<code>&lt;script&gt;</code>,<code>&lt;IMG&gt;</code>,<code>&lt;iframe&gt;</code>)</p></li><li><p>于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、Web socket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；</p></li><li><p>恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被JS原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</p></li><li><p>客户端在对JSON文件调用成功之后,也就获得了自己所需要的数据,剩下的就是按自己的需求进行处理和展现了</p></li><li><p>为了方便客户使用数据,逐渐形成了一种非正式传输协议—JSONP.</p><blockquote><p>该协议允许用户传递一个callback参数给服务端,然后服务端返回数据时会将这个callback参数坐会函数名来包裹JSON数据,这样客户端就可以随意订制自己的函数来自动处理返回函数了</p></blockquote></li></ul><h5 id="2、JSONP弊端"><a href="#2、JSONP弊端" class="headerlink" title="2、JSONP弊端"></a>2、JSONP弊端</h5><ul><li>只能发送get请求</li><li>需要服务端配合</li></ul><h5 id="3、JSON流程"><a href="#3、JSON流程" class="headerlink" title="3、JSON流程"></a>3、JSON流程</h5><ul><li>先定义好全局函数</li><li>动态创建script标签</li><li>给服务器提供事先创建好的容器</li><li>服务器获取容器</li><li>将内容填充进容器</li></ul><h5 id="4、-代码实现-https-github-com-JuntengMa-JavaScript-tree-master-JsonP"><a href="#4、-代码实现-https-github-com-JuntengMa-JavaScript-tree-master-JsonP" class="headerlink" title="4、[代码实现]:https://github.com/JuntengMa/JavaScript/tree/master/JsonP"></a>4、[代码实现]:<a href="https://github.com/JuntengMa/JavaScript/tree/master/JsonP">https://github.com/JuntengMa/JavaScript/tree/master/JsonP</a></h5>]]></content>
    
    
    <summary type="html">&lt;p&gt;JSONP及其原理&lt;/p&gt;</summary>
    
    
    
    <category term="JSONP" scheme="https://juntengma.github.io/categories/JSONP/"/>
    
    
    <category term="JSONP" scheme="https://juntengma.github.io/tags/JSONP/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="https://juntengma.github.io/2020/10/28/Ajax/"/>
    <id>https://juntengma.github.io/2020/10/28/Ajax/</id>
    <published>2020-10-28T08:18:31.341Z</published>
    <updated>2020-10-30T11:16:15.122Z</updated>
    
    <content type="html"><![CDATA[<p>AJAX复习一下~</p><a id="more"></a><h5 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h5><h5 id="01-ajax是什么"><a href="#01-ajax是什么" class="headerlink" title="01-ajax是什么"></a>01-ajax是什么</h5><blockquote><p>​    JavaScript执行异步网络请求</p></blockquote><p><img src="https://s1.ax1x.com/2020/10/28/B3MoX8.png"></p><h5 id="02-ajax原理"><a href="#02-ajax原理" class="headerlink" title="02-ajax原理"></a>02-ajax原理</h5><p><strong>现在浏览器AJAX主要依靠XMLHttpRequest对象实现</strong></p><p><img src="https://s1.ax1x.com/2020/10/28/B3l0sK.png"></p><h5 id="03-创建ajax"><a href="#03-创建ajax" class="headerlink" title="03 - 创建ajax"></a>03 - 创建ajax</h5><h6 id="1-创建Ajax核心对象XMLHttpRequest"><a href="#1-创建Ajax核心对象XMLHttpRequest" class="headerlink" title="1/创建Ajax核心对象XMLHttpRequest"></a>1/创建Ajax核心对象XMLHttpRequest</h6><pre><code>var xhr = null ;if(window.XMLHttpRequest)&#123;    xhr = new XMLHttpRequest()&#125;else&#123;    xhr = new ActiveXobject(&quot;Microsoft.XMLHTTP&quot;)&#125;</code></pre><h6 id="2-向服务器发送请求"><a href="#2-向服务器发送请求" class="headerlink" title="2/向服务器发送请求"></a>2/向服务器发送请求</h6><pre><code>xhr.open(method,url,async:boolean)xhr.send(string); //POST请求时候采用string参数,否则不需要带参数</code></pre><ul><li><strong>method</strong> : GET/POST</li><li>**url:**请求链接(位置)</li><li>**async:**是否异步</li></ul><pre><code>xhr.open(&quot;POST&quot;,&quot;test.html&quot;,true);  xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);  xhr.send(&quot;fname=Henry&amp;lname=Ford&quot;);  //post请求参数放在send里面，即请求体</code></pre><h6 id="3-服务器响应处理-区分同步-异步情况"><a href="#3-服务器响应处理-区分同步-异步情况" class="headerlink" title="3/服务器响应处理(区分同步/异步情况)"></a>3/服务器响应处理(区分同步/异步情况)</h6><ul><li>responseText:获得字符串形式的响应数据</li><li>ResponseXML:获得XML形式的响应数据</li></ul><p>👹同步处理数据</p><pre><code>1. xhr.open(&quot;GET&quot;,&quot;info.txt&quot;,false);  2. xhr.send();  3. document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText; //获取数据直接显示在页面上</code></pre><p>👺异步处理数据(要在请求状态改变事件中处理。)</p><pre><code>1. xhr.onreadystatechange=function()  &#123; 2.    if (xhr.readyState==4 &amp;&amp;xhr.status==200)  &#123; 3.       document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText;  4.      &#125;5.    &#125; </code></pre><h6 id="4-什么是readyState"><a href="#4-什么是readyState" class="headerlink" title="4/什么是readyState?"></a>4/什么是readyState?</h6><p>readyState是XMLHttpRequest对象的一个属性,用来表示当前XMLHttpRequest对象处于什么状态</p><ul><li>0 : 未初始化,尚未调用xhr.open()方法</li><li>1 : 启动,已经调用xhr.open放大,但是未send</li><li>2 : 发送,已经调用xhr.send方法,但是还没有收到响应</li><li>3 : 接收,已经接收到部分响应数据</li><li>4 : 完成,已经接收到全部响应数据,并且可以在客户端使用</li></ul><h6 id="05-GET和POST请求数据区别"><a href="#05-GET和POST请求数据区别" class="headerlink" title="05/GET和POST请求数据区别"></a>05/GET和POST请求数据区别</h6><ul><li>get请求,参数在url中显示,post请求放在send里面</li><li>get请求发送数据量小,Post请求发送数据量比较大</li><li>get请求安全性低,会被缓存,POST反之</li></ul><h5 id="04-AJAX代码"><a href="#04-AJAX代码" class="headerlink" title="04/AJAX代码"></a>04/AJAX代码</h5><pre><code>function verificationParams(requestInfo) &#123;    //地址不能为空    if (!requestInfo.url) &#123;        throw new Error(&#39;输入请求地址&#39;)    &#125;    //判断是异步是否合规    if (typeof requestInfo.async !== &#39;boolean&#39;) &#123;        throw new Error(&#39;async只接受boolean类型数据&#39;)    &#125;    //请求方式    if (!(requestInfo.type.toUpperCase() === &#39;GET&#39; || requestInfo.type.toUpperCase() === &#39;post&#39;)) &#123;        throw new Error(&#39;请求方式有误&#39;)    &#125;&#125;function ajax(params) &#123;    //默认参数对象    let requestInfo=&#123;        type: &#39;GET&#39;,//请求方式        url:&#39;&#39;,        data:&#39;&#39;,//请求参数        datatype:&#39;string&#39;, //数据类型        async:true,//异步还是同步        callBack:function()&#123;&#125; //处理函数        &#125;    for(let item in params)&#123;        requestInfo[item] = params[item]    &#125;    verificationParams(requestInfo)    const &#123; type, url, data, datatype, async, callBack &#125; = requestInfo    //数据类型转换    let str=&#39;&#39;    let dataType = Object.prototype.toString.call(data)    if (dataType===&#39;[object String]&#39;)&#123;        str = data.replace(/,/g,&#39;&amp;&#39;)    &#125; else if (dataType===&#39;[object Object]&#39;)&#123;        for(let attr in data)&#123;            str+=attr+&#39;=&#39;+data[attr]+&#39;&amp;&#39;        &#125;        str=str.slice(0,-1)    &#125;    let xhr = new XMLHttpRequest()    if(type.toUpperCase()===&#39;GET&#39;)&#123;        xhr.open(type.toUpperCase(),url+&#39;?&#39;+str,async)        xhr.send()    &#125;else&#123;        xhr.open(type.toUpperCase(),url,async)        xhr.setRequestHeader(&#39;content-type&#39;, &#39;application/x-www-form-urlencoded&#39;)        xhr.send(str)    &#125;    xhr.onload=function()&#123;        if(datatype===&#39;json&#39;)&#123;            callBack(eval(&#39;(&#39;+xhr.responseText+&#39;)&#39;))        &#125;else&#123;            callBack(xhr.responseText)        &#125;    &#125;&#125;function Ajax(params)&#123;    let promise=new Promise(function(resolve,reject)&#123;        ajax(&#123;            url:params.url,            type:params.type.toUpperCase() || &#39;GET&#39;,            data:params.data ||&#39;&#39;,            datatype:params.datatype || &#39;string&#39;,            async:params.async || true,            callBack:function(res)&#123;                resolve(res)            &#125;        &#125;)    &#125;)    return promise&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;AJAX复习一下~&lt;/p&gt;</summary>
    
    
    
    <category term="Ajax" scheme="https://juntengma.github.io/categories/Ajax/"/>
    
    <category term="Axios" scheme="https://juntengma.github.io/categories/Ajax/Axios/"/>
    
    
    <category term="Ajax" scheme="https://juntengma.github.io/tags/Ajax/"/>
    
    <category term="Axios" scheme="https://juntengma.github.io/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>盒模型,BFC</title>
    <link href="https://juntengma.github.io/2020/10/28/Css%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <id>https://juntengma.github.io/2020/10/28/Css%E7%9B%92%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-10-28T07:57:01.036Z</published>
    <updated>2020-10-29T07:36:20.410Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>   关于盒模型的一些总结</p></blockquote><a id="more"></a><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><h5 id="标准盒模型-box-sizing-content-box"><a href="#标准盒模型-box-sizing-content-box" class="headerlink" title="标准盒模型(box-sizing:content-box)"></a>标准盒模型(box-sizing:content-box)</h5><pre><code>width = content width;height = content height;</code></pre><h5 id="怪异盒模型-box-sizing-border-box"><a href="#怪异盒模型-box-sizing-border-box" class="headerlink" title="怪异盒模型(box-sizing:border-box)"></a>怪异盒模型(box-sizing:border-box)</h5><pre><code>width = content width + padding + border;height = content height + padding + border;</code></pre><h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><h5 id="01-什么是BFC"><a href="#01-什么是BFC" class="headerlink" title="01/什么是BFC?"></a>01/什么是BFC?</h5><p>块级格式化上下文</p><p>BFC是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><h5 id="02-建立BFC"><a href="#02-建立BFC" class="headerlink" title="02/建立BFC"></a>02/建立BFC</h5><ul><li>浮动</li><li>绝对定位</li><li>行内块元素</li><li>表格单元</li><li>弹性盒</li><li>overflow不为visible</li></ul><h5 id="03-BFC应用场景"><a href="#03-BFC应用场景" class="headerlink" title="03/BFC应用场景"></a>03/BFC应用场景</h5><ul><li>清除浮动</li><li>阻止元素被浮动元素覆盖</li><li>实现两列自适应布局</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;   关于盒模型的一些总结&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Css" scheme="https://juntengma.github.io/categories/Css/"/>
    
    <category term="盒模型" scheme="https://juntengma.github.io/categories/Css/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="BFC" scheme="https://juntengma.github.io/categories/Css/%E7%9B%92%E6%A8%A1%E5%9E%8B/BFC/"/>
    
    
    <category term="Css" scheme="https://juntengma.github.io/tags/Css/"/>
    
    <category term="盒模型" scheme="https://juntengma.github.io/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="BFC" scheme="https://juntengma.github.io/tags/BFC/"/>
    
  </entry>
  
  <entry>
    <title>DOM事件 , 事件流</title>
    <link href="https://juntengma.github.io/2020/10/28/JavaScriptDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <id>https://juntengma.github.io/2020/10/28/JavaScriptDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</id>
    <published>2020-10-28T01:52:53.368Z</published>
    <updated>2020-10-29T07:31:46.752Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DOM事件, 事件流</p></blockquote><a id="more"></a><h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><blockquote><p>事件是指JavaScript与HTML交互的基础.要实现用户与页面的交互,先要对目标元素绑定特定的事件,设置事件处理函数,用户触发事件,事件处理函数执行,产生交互效果</p></blockquote><h4 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h4><p>DOM 级别分为四个级别：DOM0 级、DOM1 级、DOM2 级、DOM3 级；<br><img src="https://s1.ax1x.com/2020/10/28/B1JoY4.md.jpg" alt="B1JoY4.md.jpg"></p><p>DOM事件分为三个级别:<br>DOM0 级事件</p><pre><code>&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;/button&gt;&lt;script&gt;    var btn = document.getElementById(&#39;btn&#39;)    btn.onclick = function() &#123;        console.log(&#39;Hello World&#39;)    &#125;    // btn.onclick = null // 解绑事件&lt;/script&gt;</code></pre><blockquote><p>   缺点：无法设置多个事件处理函数</p></blockquote><p>DOM2 级事件</p><pre><code>&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;/button&gt;&lt;script&gt;    var btn = document.getElementById(&#39;btn&#39;);        btn.addEventListener(&#39;click&#39;, showFn, false)    btn.addEventListener(&#39;click&#39;, showFn2, false)    // btn.removeEventListener(&#39;click&#39;, showFn, false) // 解绑事件     function showFn() &#123;        alert(&#39;Hello World&#39;);    &#125;     function showFn2() &#123;        alert(&#39;Hello World2&#39;);    &#125; &lt;/script&gt;</code></pre><blockquote><p>可以为事件设置多个事件处理函数，可以通过第三个参数 ( useCapture ) 设置在什么阶段执行事件处理函数，默认是 false， 即在事件冒泡阶段执行事件处理函数。</p></blockquote><blockquote><p>需要注意的是在 IE8 及以下版本需要用 attachEvent 和 detachEvent 实现，只有两个参数，事件名需要以 on 开头，只支持在事件冒泡阶段执行事件处理函数。</p></blockquote><p>DOM3 级事件</p><blockquote><p>DOM3 级事件是在 DOM2 级事件的基础上添加了更多的事件类型，允许自定义事件。</p></blockquote><p>UI事件，当用户与页面上的元素交互时触发，如：load、scroll<br>焦点事件，当元素获得或失去焦点时触发，如：blur、focus<br>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup<br>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel<br>文本事件，当在文档中输入文本时触发，如：textInput<br>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress<br>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart<br>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</p><pre><code>// 自定义事件var event = new Event(&#39;test&#39;)// 给元素绑定事件domElement.addEventListener(&#39;test&#39;, function() &#123;    console.log(&#39;event test&#39;)&#125;,)// 触发事件setTimeout(function() &#123;    domElement.dispatchEvent(event)&#125;, 1000)</code></pre><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><blockquote><p>事件流又称为事件传播，描述的是从<strong>页面中接收事件的顺序</strong>。</p><p>DOM2 级事件规定事件流包括三个阶段: </p><ul><li>事件捕获(capturing phase)</li><li>目标事件(target phase)</li><li>事件冒泡(bubbling phase)</li></ul><p>发生的顺序是：事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段</p></blockquote><p><img src="https://s1.ax1x.com/2020/10/28/B1tIz9.png" alt="B1tIz9.png"></p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><blockquote><p>​    事件起始元素逐级向上传播</p></blockquote><pre><code>&lt;style&gt;  #parent &#123;      width: 200px;      height: 200px;      background-color: green;  &#125;  #child &#123;      width: 100px;      height: 100px;      background-color: yellow;  &#125;&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt;  &lt;div id=&quot;child&quot;&gt;目标元素&lt;/div&gt;  父级元素&lt;/div&gt;&lt;script&gt;  var parent = document.getElementById(&#39;parent&#39;)  var child = document.getElementById(&#39;child&#39;)  parent.addEventListener(&#39;click&#39;, function(e) &#123;      console.log(&#39;parent bubbling&#39;)  &#125;, false)  child.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;target bubbling&#39;)  &#125;, false)  document.body.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;body bubbling&#39;)  &#125;, false)  document.documentElement.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;html bubbling&#39;)  &#125;, false)  document.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;document bubbling&#39;)  &#125;, false)  window.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;window bubbling&#39;)  &#125;, false)&lt;/script&gt;</code></pre><p>运行结果：</p><p><img src="https://s1.ax1x.com/2020/10/28/B1UStU.gif" alt="B1UStU.gif"></p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><blockquote><p>​    事件按 window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素 的方向向下层元素传递。</p></blockquote><pre><code>&lt;style&gt;  #parent &#123;      width: 200px;      height: 200px;      background-color: green;  &#125;  #child &#123;      width: 100px;      height: 100px;      background-color: yellow;  &#125;&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt;  &lt;div id=&quot;child&quot;&gt;目标元素&lt;/div&gt;  父级元素&lt;/div&gt;&lt;script&gt;  var parent = document.getElementById(&#39;parent&#39;)  var child = document.getElementById(&#39;child&#39;)  parent.addEventListener(&#39;click&#39;, function(e) &#123;      console.log(&#39;parent capture&#39;)  &#125;, true)  child.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;target capture&#39;)  &#125;, true)  document.body.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;body capture&#39;)  &#125;, true)  document.documentElement.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;html capture&#39;)  &#125;, true)  document.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;document capture&#39;)  &#125;, true)  window.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;window capture&#39;)  &#125;, true)&lt;/script&gt;</code></pre><p>运行结果:</p><p><img src="https://s1.ax1x.com/2020/10/28/B1UCp4.gif" alt="B1UCp4.gif"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;DOM事件, 事件流&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="DOM事件事件流" scheme="https://juntengma.github.io/tags/DOM%E4%BA%8B%E4%BB%B6%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>原型,原型链</title>
    <link href="https://juntengma.github.io/2020/10/26/JavaScript%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://juntengma.github.io/2020/10/26/JavaScript%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-10-26T14:36:07.474Z</published>
    <updated>2020-10-29T07:31:56.436Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​    原型原型链</p></blockquote><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;​    原型原型链&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="原型,原型链" scheme="https://juntengma.github.io/categories/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>浏览器解析js流程</title>
    <link href="https://juntengma.github.io/2020/10/26/JavaScript%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/"/>
    <id>https://juntengma.github.io/2020/10/26/JavaScript%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/</id>
    <published>2020-10-26T10:14:39.943Z</published>
    <updated>2020-10-29T03:49:55.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>浏览器解析js流程</p></blockquote><a id="more"></a><h4 id="JS解析"><a href="#JS解析" class="headerlink" title="JS解析"></a>JS解析</h4><p><a href="https://imgchr.com/i/BufjDe"><img src="https://s1.ax1x.com/2020/10/26/BufjDe.png" alt="BufjDe.png"></a></p><p>js解析是由浏览器的就是解析引擎完成的.</p><p>js是单线程运行,也就是说同时只能做一件事,所有任务都需要排队,</p><p>为了解决某些任务比较耗时,需要一种机制来使其可以执行排在后面的任务,就出现了同步任务和异步任务</p><p>JS执行机制可以看做一个主线程加上一个任务队列.</p><p>同步任务就是主线程上面执行的任务 , 异步任务就是放在任务队列的任务</p><p>所有的同步任务都在主线程上面执行,形成一个执行栈</p><p>异步任务有了运行结果就会在任务队列中放置一个事件,脚本运行时依次运行执行栈,然后会从任务队列中提取事件,</p><p>运行任务队列中的任务,该过程是不断重复的,所以又叫做事件循环(Event loop)</p><ul><li>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。</li><li>请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。</li><li>原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。</li><li>CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;浏览器解析js流程&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="浏览器" scheme="https://juntengma.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="https://juntengma.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面加载发生了什么</title>
    <link href="https://juntengma.github.io/2020/10/26/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>https://juntengma.github.io/2020/10/26/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2020-10-26T06:38:03.324Z</published>
    <updated>2020-10-30T09:19:48.004Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从输入URL到页面加载发生了什么</p></blockquote><a id="more"></a><p>总体来说分为以下几个过程:</p><ul><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ul><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS解析的过程就是在寻找哪台机器上有你需要的资源的全过程.<br>当你在浏览器中输入一个地址时,将网址转换为IP的过程叫做DNS解析</p><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS解析本质上是一个递归查询的过程<br><a href="https://imgchr.com/i/BuniZV"><img src="https://s1.ax1x.com/2020/10/26/BuniZV.png" alt="BuniZV.png"></a></p><p>上图是查找<code>www.google.com</code>这个网址的过程</p><ol><li>在<code>本地域名服务器</code>中查询IP地址–&gt;无</li><li><code>本地域名服务器</code>向<code>根域名服务器</code>发送请求–&gt;无</li><li><code>本地域名服务器</code> 向<code>COM顶级域名服务器</code>发送请求–&gt;无</li><li>……</li><li>最后本地服务器得到Google的IP的字号并缓存到本地,功下次使用</li></ol><p>由上可以看出网址解析是一个 从右到左的过程:<br><code>com</code> –&gt; <code>google.com</code> –&gt; <code>www.google.com</code><br>根域名服务器呢?<br>默认情况下所有网址最后一位都是. , 即<code>www.google.com.</code>,方便用户一般都会省略,浏览器在请求DNS的时候会自动加上,<br>即NDS解析流程:<br><code>.</code>–&gt;<code>com.</code>–&gt;<code>google.com.</code>–&gt;<code>www.google.com.</code></p><h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3><ul><li>HTTP报文是包裹在tcp报文中发送的,服务端的吼道TCP报文时会解包提取出HTTP报文,但是该过程存在一定风险,HTTP报文是明文,如果中间被截取的话会存在一些信息泄露的风险</li><li>HTTPS协议本质就是HTTP+SSL,在HTTP报文进入TCP报文之前,先使用SSL报文进行加密.从网络层的结构看它位于HTTP协议与TCP协议之间<br><a href="https://imgchr.com/i/BunpMn"><img src="https://s1.ax1x.com/2020/10/26/BunpMn.png" alt="BunpMn.png"></a></li></ul><p><strong>HTTPS过程</strong><br>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TSL/SSL握手),在握手的过程中将确立对方家里传输数据的密码信息.TLS/SSL使用了非对称加密,对称加密以及hash等.</p><p>HTTPS相对于HTTP,虽然提供了安全保证,但势必会造成一些时间上的损耗,如握手和加密等过程,使用前需要做好安全和性能方面的权衡<br><strong>HTTP请求</strong><br>http请求主要发生在客户端.发送http请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080,HTTPS协议443)<br>http请求报文由三部分组成</p><ul><li>请求行 ( 常用方法有get,post,put,delete…等)</li><li>请求报头(请求报头允许客户端向度武器传递请求的附加信息和客户端自身的信息)</li><li>请求正文(客户端向服务端传递的数据)<h3 id="服务器处理请求并返回HTTP报文"><a href="#服务器处理请求并返回HTTP报文" class="headerlink" title="服务器处理请求并返回HTTP报文"></a>服务器处理请求并返回HTTP报文</h3>HTTP响应报文也是由三部分组成: <strong>状态码</strong>, <strong>响应报头</strong>和<strong>响应报文</strong>。</li></ul><p><strong>状态码</strong><br>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p><ul><li>1xx:指示信息 - 表示请求已接收,继续处理</li><li>2xx:成功,表示请求已被成功接收,理解,处理</li><li>3xx:重定向 -  要完成请求必须进行更进一步的操作</li><li>4xx:客户端错误 - 请求有语法错误或请求无法实现.</li><li>5xx:服务端错误 - 服务器未能实现合法请求</li></ul><p><strong>常见错误码:</strong></p><ul><li>200:请求成功</li><li>204:无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>301:永久移动。请求的资源已被永久的重定向到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302:临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>304:未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>400:客户端请求的语法错误，服务器无法理解</li><li>401:请求要求用户的身份认证</li><li>403:服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404:服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>422:请求格式正确，但是由于含有语义错误，无法响应。</li><li>500:服务器内部错误，无法完成请求</li></ul><h3 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h3><p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。</p><p>`<a href="https://imgchr.com/i/BufqgK"><img src="https://s1.ax1x.com/2020/10/26/BufqgK.png" alt="BufqgK.png"></a></p><p>浏览器是一个边解析边渲染的过程.</p><p>首先在浏览器解析HTML文件构建DOM树,然后解析css文件构建渲染树,等到渲染完成后,浏览器开封市布局渲染树并将其绘制到屏幕上.</p><p>该过程涉及到两个概念 : <strong>重绘</strong>,<strong>回流</strong></p><ul><li>**回流:**DOM节点中的各个元素都是以盒模型的形式存在,需要浏览器来计算其位置和大小等,该过程叫做回流</li><li>**重绘:**当盒模型的位置,大小以及其他属性,如颜色,字体等确定下来之后,浏览器就开始绘制内容,该过程叫做重绘</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从输入URL到页面加载发生了什么&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="浏览器" scheme="https://juntengma.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="https://juntengma.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>[object Object]</title>
    <link href="https://juntengma.github.io/2020/10/26/typeScript/"/>
    <id>https://juntengma.github.io/2020/10/26/typeScript/</id>
    <published>2020-10-26T04:23:04.617Z</published>
    <updated>2020-10-29T04:31:47.705Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>webpack配置</title>
    <link href="https://juntengma.github.io/2020/10/19/webpack/"/>
    <id>https://juntengma.github.io/2020/10/19/webpack/</id>
    <published>2020-10-19T11:42:26.340Z</published>
    <updated>2020-10-29T04:31:54.133Z</updated>
    
    <content type="html"><![CDATA[<p>webpack基本配置</p><a id="more"></a><h3 id="1-什么是-webpack"><a href="#1-什么是-webpack" class="headerlink" title="1. 什么是 webpack"></a>1. 什么是 webpack</h3><blockquote><p>webpack 是一个现代 javaScript 应用程序的静态模块打包器, 分析项目结构，处理模块化依赖，转换成为浏览器 可运行的代码。</p></blockquote><h3 id="2-webpack-用来做什么"><a href="#2-webpack-用来做什么" class="headerlink" title="2. webpack 用来做什么"></a>2. webpack 用来做什么</h3><blockquote><ul><li>代码转换: TypeScript 编译成 JavaScript、SCSS,LESS 编译成 CSS。</li><li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片。</li><li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li></ul></blockquote><h3 id="3-webpack安装"><a href="#3-webpack安装" class="headerlink" title="3.webpack安装"></a>3.webpack安装</h3><pre><code>//全局安装webpack及webpack-cli模块yarn global add webpack webpack--cli//本地安装项目模块（一般本地安装，防止本地和全局版本不一致）yarn add webpack webpack-cli -dev(-D)//打包命令npx webpack</code></pre><h3 id="4-插件"><a href="#4-插件" class="headerlink" title="4.插件"></a>4.插件</h3><h4 id="1-webpack-dev-server"><a href="#1-webpack-dev-server" class="headerlink" title="1. webpack-dev-server"></a>1. webpack-dev-server</h4><pre><code class="node">devServer: &#123;//这里做开发服务器配置    port: 3000,    contentBase: path.join(__dirname, &#39;dist&#39;),//_dirname：表示在当前目录    compress: true,//启动gzip压缩&#125;</code></pre><h4 id="2-HtmlWebpackPlugin"><a href="#2-HtmlWebpackPlugin" class="headerlink" title="2.  HtmlWebpackPlugin"></a>2.  HtmlWebpackPlugin</h4><pre><code>const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);new HtmlWebpackPlugin(&#123;  template: &#39;./src/index.html&#39;,  filename: &#39;index.html&#39;,  minify: &#123;//用于对文件进行压缩    removeAttributeQuotes: true,// 移除属性的引号    collapseWhitespace: true,    removeComments: true,    removeRedundantAttributes: true,    removeScriptTypeAttributes: true,    removeStyleLinkTypeAttributes: true,    useShortDoctype: true  &#125;,  hash: true&#125;)</code></pre><h4 id="3-热更新"><a href="#3-热更新" class="headerlink" title="3.  热更新"></a>3.  热更新</h4><pre><code>new webpack.HotModuleReplacementPlugin(),</code></pre><h4 id="4-打包分析插件"><a href="#4-打包分析插件" class="headerlink" title="4. 打包分析插件"></a>4. 打包分析插件</h4><pre><code>https://github.com/webpack-contrib/webpack-bundle-analyzernew BundleAnalyzerPlugin(),</code></pre><h4 id="5-开启进度条"><a href="#5-开启进度条" class="headerlink" title="5.  开启进度条"></a>5.  开启进度条</h4><pre><code>const ProgressBarPlugin = require(&#39;progress-bar-webpack-plugin&#39;);new ProgressBarPlugin(),</code></pre><h4 id="6-打包时长测试"><a href="#6-打包时长测试" class="headerlink" title="6. 打包时长测试"></a>6. 打包时长测试</h4><pre><code>const SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);const smp = new SpeedMeasurePlugin();module.exports = smp.wrap(&#123;&#125;);</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;webpack基本配置&lt;/p&gt;</summary>
    
    
    
    <category term="Webpack" scheme="https://juntengma.github.io/categories/Webpack/"/>
    
    
    <category term="Webpack" scheme="https://juntengma.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>浏览器同源策略</title>
    <link href="https://juntengma.github.io/2020/09/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    <id>https://juntengma.github.io/2020/09/29/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/</id>
    <published>2020-09-29T07:10:38.805Z</published>
    <updated>2020-10-30T11:16:47.218Z</updated>
    
    <content type="html"><![CDATA[<p>关于同源策略的一点总结~</p><a id="more"></a><h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><h5 id="01、什么是同源策略"><a href="#01、什么是同源策略" class="headerlink" title="01、什么是同源策略"></a>01、什么是同源策略</h5><blockquote><p>同源策略是浏览器安全的基石</p><p>同源：</p><ul><li>协议相同</li><li>域名相同</li><li>端口相同</li></ul><p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。</p><p>它的同源情况如下：</p><ul><li><code>http://www.example.com/dir2/other.html</code>：同源</li><li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li><li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li><li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li></ul></blockquote><h5 id="02、同源策略目的"><a href="#02、同源策略目的" class="headerlink" title="02、同源策略目的"></a>02、同源策略目的</h5><blockquote><p>同源策略目的，是为了保证用户信息安全，防止恶意网站窃取数据</p></blockquote><h5 id="03、同源策略限制范围"><a href="#03、同源策略限制范围" class="headerlink" title="03、同源策略限制范围"></a>03、同源策略限制范围</h5><blockquote><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取</li><li>DOM无法获得</li><li>AJAX请求不能发送</li></ul></blockquote><h5 id="04、规避同源策略方案"><a href="#04、规避同源策略方案" class="headerlink" title="04、规避同源策略方案"></a>04、规避同源策略方案</h5><blockquote><ul><li>JSONP</li><li>WebSocket</li><li>CORS</li></ul></blockquote><h5 id="05、JSONP"><a href="#05、JSONP" class="headerlink" title="05、JSONP"></a>05、JSONP</h5><blockquote><ul><li><p>什么是JSONP<br>JSONP是服务器与客户端跨原通信的常用方案。最大特点就是简单适用，老式浏览器全部支持，服务器改造小</p></li><li><p>原理</p><p>网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，该方法不受同源策略限制，服务器收到请求之后，将数据放在指定的名字回调函数中传回来</p></li></ul></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于同源策略的一点总结~&lt;/p&gt;</summary>
    
    
    
    <category term="同源策略" scheme="https://juntengma.github.io/categories/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    
    <category term="浏览器" scheme="https://juntengma.github.io/categories/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="https://juntengma.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    <category term="同源策略" scheme="https://juntengma.github.io/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>Axios二次封装</title>
    <link href="https://juntengma.github.io/2020/09/27/Axios/"/>
    <id>https://juntengma.github.io/2020/09/27/Axios/</id>
    <published>2020-09-27T13:04:10.758Z</published>
    <updated>2020-10-28T07:49:54.280Z</updated>
    
    <content type="html"><![CDATA[<hr><a id="more"></a><h3 id="01-新建src-api文件夹"><a href="#01-新建src-api文件夹" class="headerlink" title="01-新建src/api文件夹"></a>01-新建src/api文件夹</h3><pre><code>api - ajax.js - index.js</code></pre><h3 id="02-新建axios-js文件"><a href="#02-新建axios-js文件" class="headerlink" title="02-新建axios.js文件"></a>02-新建axios.js文件</h3><pre><code class="js">import axios from &#39;axios&#39;//封装ajaxexport default function ajax(url=&#39;&#39;,params=&#123;&#125;,type=&#39;GET&#39;)&#123;  let promise;  type = type.toUpperCase()  return new Promise(((resolve, reject) =&gt; &#123;    //1.判断请求方式    if (type===&#39;GET&#39;)&#123;      //1.1拼接字符串      let str = &#39;&#39;;      Object.keys(params).forEach((value,index) =&gt; &#123;        if (index+1===Object.keys(params).length)&#123;          str+=value+&#39;=&#39;+params[value];        &#125;else&#123;          str+=value+&#39;=&#39;+params[value]+&#39;&amp;&#39;;        &#125;      &#125;);      //1.2完整路径      url+=&#39;?&#39;+str;      //1.3发送get请求      promise = axios.get(url);    &#125;else if(type===&#39;POST&#39;)&#123;      //1.3发送post请求      promise = axios.post(url,params);    &#125;    //2.返回请求结果    promise.then((response)=&gt;&#123;      resolve(response.data);    &#125;).catch((error)=&gt;&#123;      reject(error);    &#125;);  &#125;))&#125;</code></pre><h3 id="03-新建index-js文件"><a href="#03-新建index-js文件" class="headerlink" title="03-新建index.js文件"></a>03-新建index.js文件</h3><pre><code>import ajax from &#39;./ajax&#39;//发送请求export const getPhoneCode = (phone)=&gt;ajax(&#39;/api/getPhoneCode&#39;,&#123;phone&#125;);</code></pre><h3 id="04-api调用"><a href="#04-api调用" class="headerlink" title="04-api调用"></a>04-api调用</h3><pre><code>import &#123; xxxxx &#125; from &#39;api/index.js (文件路径)&#39;</code></pre>]]></content>
    
    
    <summary type="html">&lt;hr&gt;</summary>
    
    
    
    <category term="Ajax" scheme="https://juntengma.github.io/categories/Ajax/"/>
    
    <category term="Axios" scheme="https://juntengma.github.io/categories/Ajax/Axios/"/>
    
    
    <category term="Ajax" scheme="https://juntengma.github.io/tags/Ajax/"/>
    
    <category term="Axios" scheme="https://juntengma.github.io/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>React父组件调用子组件</title>
    <link href="https://juntengma.github.io/2020/09/25/React-%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6/"/>
    <id>https://juntengma.github.io/2020/09/25/React-%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6/</id>
    <published>2020-09-25T08:37:00.658Z</published>
    <updated>2020-10-30T11:19:27.024Z</updated>
    
    <content type="html"><![CDATA[<p>React父组件调用子组件方案</p><a id="more"></a><h2 id="方案一：-ref控制"><a href="#方案一：-ref控制" class="headerlink" title="方案一： ref控制"></a>方案一： ref控制</h2><h4 id="Parent-Component-Parent-tsx"><a href="#Parent-Component-Parent-tsx" class="headerlink" title="Parent Component ( Parent.tsx )"></a>Parent Component ( Parent.tsx )</h4><pre><code>import * as React from &#39;react&#39;;import &#123; ChildA &#125; from &#39;./ChildA&#39;;//多个子组件时可以先定义如下组件：class Childrens extends React.Component&lt;any, any&gt; &#123;  _childA: any;  _childB: any;  _childC: any;&#125;export class Parent extends Childrens &#123;  //调用子组件方式：  get_childA_sum = () =&gt; &#123;    this._childA.sum(1, 2)  &#125;  render() &#123;    const children = &#123;      on_childA_ref: ref =&gt; &#123;        this._childA = ref;      &#125;,      on_childB_ref: ref =&gt; &#123;        this._childB = ref;      &#125;,      on_childC_ref: ref =&gt; &#123;        this._childC = ref;      &#125;,    &#125;    return (      &lt;div&gt;        &lt;button onClick=&#123;() =&gt; this.get_childA_sum()&#125;&gt; SumA &lt;/button&gt;        &lt;ChildA _childA=&#123;children.on_childA_ref&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></pre><h4 id="Children-Component-ChildA-tsx"><a href="#Children-Component-ChildA-tsx" class="headerlink" title="Children Component  (ChildA.tsx)"></a>Children Component  (ChildA.tsx)</h4><pre><code>import * as React from &#39;react&#39;;interface ChildAProps &#123;  _childA:Function;&#125;export class ChildA extends React.Component&lt;ChildAProps, any&gt; &#123;  componentDidMount() &#123;        this.props._childA(this)    &#125;  sum = (a , b) =&gt; &#123;    alert(a+b)  &#125;  render()&#123;    return(      &lt;div&gt;        组件A      &lt;/div&gt;    )  &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;React父组件调用子组件方案&lt;/p&gt;</summary>
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    <category term="TypeScript" scheme="https://juntengma.github.io/categories/React/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript获取元素位置</title>
    <link href="https://juntengma.github.io/2020/09/24/JavaScript%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%9D%90%E6%A0%87%E9%97%AE%E9%A2%98/"/>
    <id>https://juntengma.github.io/2020/09/24/JavaScript%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%9D%90%E6%A0%87%E9%97%AE%E9%A2%98/</id>
    <published>2020-09-24T11:52:43.097Z</published>
    <updated>2020-10-29T04:34:36.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js获取元素相对于父级元素的高度"><a href="#js获取元素相对于父级元素的高度" class="headerlink" title="js获取元素相对于父级元素的高度"></a>js获取元素相对于父级元素的高度</h2><a id="more"></a><h4 id="1-offsetLeft-、offsetTop"><a href="#1-offsetLeft-、offsetTop" class="headerlink" title="1. offsetLeft 、offsetTop"></a>1. offsetLeft 、offsetTop</h4><p>offsetLeft/offsetTop -  用于获取子元素相对于父元素的位移（左位移、上位移）</p><h4 id="2-offsetWidth、offsetHeight"><a href="#2-offsetWidth、offsetHeight" class="headerlink" title="2. offsetWidth、offsetHeight"></a>2. offsetWidth、offsetHeight</h4><p>offsetWidth/offsetHeight - 用于获取元素的可见宽度和可见高度</p><h4 id="3-clientX-、clientY"><a href="#3-clientX-、clientY" class="headerlink" title="3. clientX 、clientY"></a>3. clientX 、clientY</h4><p>用于获取鼠标坐标（相对于页面的坐标）</p><p>var event = event || window.event;</p><ul><li>event.clientX</li><li>event.clientY</li></ul><h4 id="4-offsetLeft与style-left的区别"><a href="#4-offsetLeft与style-left的区别" class="headerlink" title="4.offsetLeft与style.left的区别"></a>4.offsetLeft与style.left的区别</h4><ol><li>    <ul><li>style.left返回的是字符串      //30px</li><li>offsetLeft返回的是数值        //30</li></ul></li><li>    <ul><li>style.left可读可写</li><li>offsetLeft只读</li></ul></li><li>     <ul><li>style.left的值需事先定义，否则取到的值为空</li><li>offsetLeft不需提前定义，直接获取</li></ul></li></ol><h4 id="5-兼容问题"><a href="#5-兼容问题" class="headerlink" title="5.兼容问题"></a>5.兼容问题</h4><pre><code>chrome：e.pageX——相对整个页面的坐标e.layerX——相对当前坐标系的border左上角开始的坐标e.offsetX——相对当前坐标系的border左上角开始的坐标e.clientX——相对可视区域的坐标e.x——相对可视区域的坐标ff：e.pageX——相对整个页面的坐标e.layerX——相对当前坐标系的border左上角开始的坐标e.offsetX——无e.clientX——相对可视区域的坐标e.x——无opera：e.pageX——相对整个页面的坐标e.layerX——无e.offsetX——相对当前坐标系的内容区域左上角开始的坐标e.clientX——相对可视区域的坐标e.x——相对可视区域的坐标safari：（这个和chrome是一样的）e.pageX——相对整个页面的坐标e.layerX——相对当前坐标系的border左上角开始的坐标e.offsetX——相对当前坐标系的border左上角开始的坐标e.clientX——相对可视区域的坐标e.x——相对可视区域的坐标IE9：e.pageX——相对整个页面的坐标e.layerX——相对当前坐标系的border左上角开始的坐标 + 滚动条滚过的距离（这个NB轰轰了····=。=）e.offsetX——相对当前坐标系的内容区域左上角开始的坐标e.clientX——相对可视区域的坐标e.x——相对当前坐标系的border左上角开始IE8：e.pageX——无e.layerX——无e.offsetX——相对当前坐标系的内容区域左上角开始的坐标e.clientX——相对可视区域的坐标e.x——相对当前坐标系的border左上角开始IE7：e.pageX——无e.layerX——无e.offsetX——相对当前坐标系的内容区域左上角开始的坐标e.clientX——相对可视区域的坐标e.x——相对当前坐标系的border左上角开始IE6：e.pageX——无e.layerX——无e.offsetX——相对当前坐标系的内容区域左上角开始的坐标e.clientX——相对可视区域的坐标e.x——相对当前坐标系的border左上角开始</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;js获取元素相对于父级元素的高度&quot;&gt;&lt;a href=&quot;#js获取元素相对于父级元素的高度&quot; class=&quot;headerlink&quot; title=&quot;js获取元素相对于父级元素的高度&quot;&gt;&lt;/a&gt;js获取元素相对于父级元素的高度&lt;/h2&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React-富文本框(braft-editor)</title>
    <link href="https://juntengma.github.io/2020/09/24/React-richText/"/>
    <id>https://juntengma.github.io/2020/09/24/React-richText/</id>
    <published>2020-09-24T01:40:54.594Z</published>
    <updated>2020-10-29T04:31:41.849Z</updated>
    
    <content type="html"><![CDATA[<h2 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h2><a id="more"></a><p><a href="https://www.yuque.com/braft-editor/be/gz44tn#wx1vkv">https://www.yuque.com/braft-editor/be/gz44tn#wx1vkv</a></p><pre><code>import React, &#123; Component &#125; from &#39;react&#39;;// 引入编辑器组件import BraftEditor from &#39;braft-editor&#39;;// 引入编辑器样式import &#39;braft-editor/dist/index.css&#39;;import &#123; UploadFn &#125; from &#39;./UploadFn&#39;;export class RichText extends Component &#123;    constructor() &#123;        super();        this.state = &#123;            editorState: BraftEditor.createEditorState(null),        &#125;;        RichText.submitContent = this.submitContent.bind(this);    &#125;    async componentDidMount() &#123;        // 假设此处从服务端获取html格式的编辑器内容        let htmlContent = this.props.htmlContent || null;        // 使用BraftEditor.createEditorState将html字符串转换为编辑器需要的editorStat        this.setState(&#123;            editorState: BraftEditor.createEditorState(htmlContent),        &#125;);    &#125;    componentWillReceiveProps(nextProps) &#123;        if (nextProps.htmlContent !== this.state.htmlContent) &#123;            this.setState(&#123;                editorState: BraftEditor.createEditorState(nextProps.htmlContent),            &#125;);        &#125;    &#125;    submitContent = async () =&gt; &#123;        // 在编辑器获得焦点时按下ctrl+s会执行此方法        // 编辑器内容提交到服务端之前，可直接调用editorState.toHTML()来获取HTML格式的内容        const htmlContent = this.state.editorState.toHTML();        return htmlContent;    &#125;;    handleEditorChange = editorState =&gt; &#123;        this.setState(&#123; editorState &#125;);    &#125;;    render() &#123;        return (            &lt;BraftEditor                value=&#123;this.state.editorState&#125;                onChange=&#123;this.handleEditorChange&#125;                onSave=&#123;this.submitContent&#125;                onBlur=&#123;() =&gt; &#123;                    const htmlContent = this.state.editorState.toHTML();                &#125;&#125;                // excludeControls=&#123;[&#39;options&#39;]&#125;                media=&#123;&#123; uploadFn: UploadFn &#125;&#125;            /&gt;        );    &#125;&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;富文本编辑器&quot;&gt;&lt;a href=&quot;#富文本编辑器&quot; class=&quot;headerlink&quot; title=&quot;富文本编辑器&quot;&gt;&lt;/a&gt;富文本编辑器&lt;/h2&gt;</summary>
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://juntengma.github.io/tags/React/"/>
    
  </entry>
  
</feed>
