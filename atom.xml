<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>June&#39;s Blog</title>
  
  
  <link href="https://juntengma.github.io/atom.xml" rel="self"/>
  
  <link href="https://juntengma.github.io/"/>
  <updated>2020-11-09T09:55:44.370Z</updated>
  <id>https://juntengma.github.io/</id>
  
  <author>
    <name>June</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://juntengma.github.io/2020/11/09/JavaScript/JavaScript-promise/"/>
    <id>https://juntengma.github.io/2020/11/09/JavaScript/JavaScript-promise/</id>
    <published>2020-11-09T09:53:53.461Z</published>
    <updated>2020-11-09T09:55:44.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><h4 id="1-什么是promise"><a href="#1-什么是promise" class="headerlink" title="1.什么是promise?"></a>1.什么是promise?</h4><p> console.dir(Promise)<br> Promise是一个构造函数,身上有all,reject,resolve几个方法,prototype上有then,catch等方法</p><blockquote><p>Promise对象是一个代理对象(代理一个值),被代理的值再Promise对象创建时可能是未知的.它允许你为异步操作的成功和失败分别绑定相应的处理方法.<br>似的异步方法可以像同步方法一样返回值,但并不是立即返回最终执行结果,而是一个<strong>能代表未来出现的结果的Promise对象</strong>???</p></blockquote><h4 id="2-promise怎么创建"><a href="#2-promise怎么创建" class="headerlink" title="2.promise怎么创建?"></a>2.promise怎么创建?</h4><pre><code class="js">var p = new Promise(function(resolve,reject))&#123;         //做异步操作         setTimeout(()=&gt;&#123;        resolve(&#39;一些数据信息&#39;)&#125;,10)                    </code></pre><h4 id="3-promise的三种状态"><a href="#3-promise的三种状态" class="headerlink" title="3.promise的三种状态"></a>3.promise的三种状态</h4><p>promise是异步操作,所以只有操作结果才可以改变promise状态</p><blockquote><p>01-pending : 待定</p><p>02-fulfilled : 已解决/已实现</p><p>03-rejected:已拒绝/未实现</p><p>状态改变:</p><p>pending—&gt;fulfiled<br>pending—&gt;rejected</p></blockquote><p>​                        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;promise&quot;&gt;&lt;a href=&quot;#promise&quot; class=&quot;headerlink&quot; title=&quot;promise&quot;&gt;&lt;/a&gt;promise&lt;/h1&gt;&lt;h4 id=&quot;1-什么是promise&quot;&gt;&lt;a href=&quot;#1-什么是promise&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript处理异步函数几种方案</title>
    <link href="https://juntengma.github.io/2020/11/09/JavaScript/JavaScript-%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
    <id>https://juntengma.github.io/2020/11/09/JavaScript/JavaScript-%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88/</id>
    <published>2020-11-09T09:53:53.397Z</published>
    <updated>2020-11-10T04:02:30.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS处理异步函数几种方案"><a href="#JS处理异步函数几种方案" class="headerlink" title="JS处理异步函数几种方案"></a>JS处理异步函数几种方案</h1><h4 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1.回调函数"></a>1.回调函数</h4><p>顾名思义: 将一个函数作为参数传入另外一个函数中,等父级函数执行完再执行回调函数</p><pre><code class="js">function f1(callBack)&#123;    console.log(&quot;hello&quot;)    let data = &quot;world&quot;    callBack(data)&#125;f1((data)=&gt;console.log(data))// hello// world</code></pre><p>回调函数优缺点:</p><blockquote><p>优点: 简单方便,适用于<strong>只有一个异步的操作</strong><br>缺点:如果嵌套层级过深,会形成回调地狱,耦合度过强</p></blockquote><pre><code class="js">getData(&#39;x&#39;,()=&gt;&#123;    //callBack函数体    getData2(&#39;y&#39;,()=&gt;&#123;        //callBack函数体        getData3(&#39;z&#39;,()=&gt;&#123;            //callBack函数体            ...        &#125;)    &#125;)&#125;)</code></pre><h4 id="2-Promise对象-async-await-最常用-终极解决方案"><a href="#2-Promise对象-async-await-最常用-终极解决方案" class="headerlink" title="2.Promise对象+async+await(最常用,终极解决方案)"></a>2.Promise对象+async+await(最常用,终极解决方案)</h4><ul><li><p>promise严格来说是一种模式,可以来管理异步代码</p></li><li><p>什么是Promise?</p><blockquote><p>Promise是解决异步编程的一种方案</p></blockquote></li><li><p>优点:</p><blockquote><p>可以解决回调地狱问题,且Promise只有resolve 和 reject 两种状态</p></blockquote></li><li><p>常用API:</p><blockquote><p>resolve : 返回异步操作成功结果<br>reject    : 返回异步操作失败结果<br>then      : 执行Promise状态为成功的操作<br>catch     :执行Promise状态为失败的操作<br>finally    :不管Promise是否成功都执行的操作</p></blockquote></li><li><p>使用:</p><pre><code class="js">    const p  = new Promise((resolve,reject)=&gt;&#123;        //异步操作        if(success)&#123;            resolve(&#39;some message&#39;)        &#125;else&#123;            reject(err)        &#125;    &#125;)    p.then(res=&gt;&#123;        //resolve数据    &#125;).catch(err=&gt;&#123;        //rejects数据    &#125;).finally(()=&gt;&#123;        //执行一些操作    &#125;)</code></pre></li><li><p>使用案例2: 封装nodejs的request模块</p><pre><code class="js">const request = require(&quot;request&quot;);const requestData = (uri) =&gt; &#123;    return new Promise((resolve, reject) =&gt; &#123;        request(&#123;            uri        &#125;, (err, res, body) =&gt; &#123;            resolve(&#123;                err,                res,                body            &#125;)        &#125;)    &#125;)&#125;;//使用let url = &quot;https://imgcache.qq.com/wss/security//ssl/build/ssl-444feca18a7857546ff9b39bbc95a17c.js&quot;;(async() =&gt; &#123;    let &#123;        err,        res,        body    &#125; = await requestData(url)    console.log(res)&#125;)()</code></pre></li></ul><h4 id="3-事件绑定"><a href="#3-事件绑定" class="headerlink" title="3.事件绑定"></a>3.事件绑定</h4><p>事件绑定的方法有三种</p><p>一，事件监听，<br>二，对象.on方法，<br>三，直接在行内写<br>事件监听有两种方法，</p><blockquote><ul><li>addlisenerevent</li><li>attachevent</li></ul></blockquote><p>两种事件监听的区别:<br>addeventlistener参数个数一般是三个，参数书写（事件类型）不写on执行顺序为：顺序注册倒序执行，兼容非IE7.8，最后一个参数是TRUE或FALSE，TRUE为捕获，FALSE为冒泡，默认FALSE<br>attachevent参数个数为两个，参数书写不写on，执行顺序：顺序注册倒序执行，兼容ie78</p><h4 id="4-Generator函数"><a href="#4-Generator函数" class="headerlink" title="4.Generator函数"></a>4.Generator函数</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS处理异步函数几种方案&quot;&gt;&lt;a href=&quot;#JS处理异步函数几种方案&quot; class=&quot;headerlink&quot; title=&quot;JS处理异步函数几种方案&quot;&gt;&lt;/a&gt;JS处理异步函数几种方案&lt;/h1&gt;&lt;h4 id=&quot;1-回调函数&quot;&gt;&lt;a href=&quot;#1-回调函数&quot;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React学习</title>
    <link href="https://juntengma.github.io/2020/11/09/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://juntengma.github.io/2020/11/09/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-11-09T08:58:59.845Z</published>
    <updated>2020-11-10T10:30:02.421Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React基础知识汇总"><a href="#React基础知识汇总" class="headerlink" title="React基础知识汇总"></a>React基础知识汇总</h4><a id="more"></a><h4 id="01-生命周期"><a href="#01-生命周期" class="headerlink" title="01 / 生命周期"></a>01 / 生命周期</h4><h5 id="react15生命周期"><a href="#react15生命周期" class="headerlink" title="react15生命周期"></a>react15生命周期<img src="https://s1.ax1x.com/2020/11/10/BLFB1P.png"></h5><p>React的生命周期就是组件从初始化到卸载到全过程，可以分为以下几个阶段</p><ul><li>初始化阶段(<ul><li><strong>constructor()</strong>, </li><li><strong>componentWillMount</strong>(),</li><li><strong>render</strong>(), </li><li><strong>componentDidMount</strong>()</li></ul></li><li>更新阶段<ul><li><strong>componentWillReceiveProps</strong>(),</li><li><strong>shouldComponentUpdate</strong>(), </li><li><strong>componentWillUpdate</strong>(), </li><li><strong>render</strong>(), </li><li><strong>componentDidUpdate</strong>()</li></ul></li><li>卸载阶段<ul><li><strong>componentWillUnmont</strong>()</li></ul></li></ul><p>这里需要注意的是更新阶段，componentWillReceiveProps是由父组件触发的更新，只要父组件更新，子组件的该生命周期就会被执行，跟props无关。同是，shouldComponentUpdate可以用来做性能优化</p><h5 id="react16生命周期"><a href="#react16生命周期" class="headerlink" title="react16生命周期"></a>react16生命周期</h5><p><img src="https://s1.ax1x.com/2020/11/10/BLkabF.png"></p><p>在React16的生命周期中，去掉了曾经的<strong>componentWillMount</strong>和<strong>componentWillUpdate</strong>，使用<strong>getDerivedStateFromProps</strong>代替这两个方法。同时在更新阶段的render方法和componentDidUpdate之间，新增了一个<strong>getSnapshotBeforeUpdate</strong>方法。接下来就来详细了解一下React这么做的原理以及这些新增生命周期的具体使用</p><h5 id="react15和react16的区别"><a href="#react15和react16的区别" class="headerlink" title="react15和react16的区别"></a>react15和react16的区别</h5><ul><li><h6 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLu3c9.png"></p><ul><li><p><code>-</code>    componentWillMount()</p></li><li><p><code>+</code>    getDerivedStateFromProps()</p><ol><li><p>getDerivedStateFromProps() 主要用于替换 componentWillReceiveProps() 的</p></li><li><p>getDerivedStateFromProps是一个静态方法 , 需要使用static声明</p></li><li><p>getDerivedStateFromProps 接收两个参数, 父组件传递过来的props和自身state</p></li><li><p>必须返回一个对象格式的返回值，否则控制台会被警告</p></li><li><p>该返回值会被用来更新现有state(并不会覆盖原有State，只做定向更新，如果原来State中没有该属性，则新增)，如果没有需要更新的时候，请记得返回一个null</p><pre><code>static getDerivedStateFromProps(props,state)&#123;  return newState&#125;</code></pre></li></ol></li></ul></li><li><h6 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLMPMj.png"></p><ul><li><code>-</code>componentWillReceiveProps()</li><li><code>+</code>getDerivedStateFormProps()</li><li><code>-</code>componentWillupdate()</li><li><code>+</code>getSnapshotBetforeupdate()</li></ul></li></ul><p>React16中也去掉了componentWillUpdate方法，新增了getSnapshotBrforeUpdate方法，这个方法在render方法之后，componentDidUpdate之前被执行，即真实DOM更新之前（获取更新前的真实DOM和更新前后的State&amp;props信息）。该方法需要一个返回值，作为componentDidUpdate的第三个参数。</p><ul><li><h6 id="componentWillReceiveProps-和getDerivedStateFormProps-区别"><a href="#componentWillReceiveProps-和getDerivedStateFormProps-区别" class="headerlink" title="componentWillReceiveProps()和getDerivedStateFormProps()区别"></a>componentWillReceiveProps()和getDerivedStateFormProps()区别</h6></li></ul><table><thead><tr><th>getDerivedStateFormProps( props , state )</th><th>componentWillReceiveProps( nextPorps )</th></tr></thead><tbody><tr><td>使用static 声明: <code>static getDerivedStateFormProps( props , state )&#123;&#125;</code></td><td>直接声明: <code>componentWillReceiveProps( nextPorps )&#123;&#125;</code></td></tr><tr><td><strong>在组件挂载阶段即可执行,父组件更新执行</strong></td><td><strong>只在父组件更新的时候执行</strong></td></tr><tr><td>接收两个参数:  props  ,  state</td><td>接收一个参数( nextPorps )</td></tr><tr><td><strong>必须返回一个对象格式的返回值 或 null</strong></td><td><strong>可以直接更新state状态</strong></td></tr></tbody></table><p><strong>demo:</strong></p><pre><code>  static getDerivedStateFromProps(props, state) &#123;    if (props.age !== state.age) &#123;      return &#123; age: props.age &#125;      // 类似setStae      // this.setState(&#123;      //   age: props.age      // &#125;);    &#125;    return null  &#125;</code></pre><pre><code>  componentWillReceiveProps(nextporps) &#123;    if (nextporps.age !== this.state.age) &#123;      this.setState(&#123;        age: nextporps.age       &#125;);    &#125;  &#125;</code></pre><h4 id="02-Virtual-Dom"><a href="#02-Virtual-Dom" class="headerlink" title="02 / Virtual Dom"></a>02 / Virtual Dom</h4><p><img src="https://s1.ax1x.com/2020/11/09/BH1gUK.png"></p><ul><li><p>什么是Virtual Dom?</p><ul><li>在原生的<code>JavaScript</code>程序中，我们直接对<code>DOM</code>进行创建和更改，而<code>DOM</code>元素通过我们监听的事件和我们的应用程序进行通讯。</li><li><code>React</code>会先将你的代码转换成一个<code>JavaScript</code>对象，然后这个<code>JavaScript</code>对象再转换成真实<code>DOM</code>。这个<code>JavaScript</code>对象就是所谓的虚拟<code>DOM</code>。</li><li>当我们需要创建或更新元素时，<code>React</code>首先会让这个<code>VitrualDom</code>对象进行创建和更改，然后再将<code>VitrualDom</code>对象渲染成真实<code>DOM</code>；</li><li>当我们需要对<code>DOM</code>进行事件监听时，首先对<code>VitrualDom</code>进行事件监听，<code>VitrualDom</code>会代理原生的<code>DOM</code>事件从而做出响应。</li></ul></li><li><p>为什么使用虚拟dom?</p><ul><li><p>可以提高开发效率</p><pre><code>使用JavaScript，我们在编写应用程序时的关注点在于如何更新DOM。使用React，你只需要告诉React你想让视图处于什么状态，React则通过VitrualDom确保DOM与该状态相匹配。你不必自己去完成属性操作、事件处理、DOM更新，React会替你完成这一切。这让我们更关注我们的业务逻辑而非DOM操作，这一点即可大大提升我们的开发效率。</code></pre></li><li><p>性能提升?(有一些矛盾)</p><pre><code>- 直接说虚拟DOM可以提升性能这种说法是很片面的,直接操作dom非常耗费性能这一点毋庸置疑,但是react同样也无法避免操作dom-    如果是首次渲染,virtualDom不具有任何优势,甚至要进行更多的计算和耗费更多的内存- virtualDOm优势在于diff算法和批量处理策略,在react页面更新之前,已经提前计算好了如何更新和渲染dom,减少重绘回流,因此可以理解为提升了性能</code></pre></li><li><p>跨浏览器兼容</p><pre><code>virtualDom自己实现了一套事件机制,模拟了事件捕获和冒泡的过程,采用了事件代理和批量更新的方法,可以抹平各浏览器事件处理不兼容的问题</code></pre></li></ul></li><li><p>React组件的渲染流程</p><ul><li><p>使用<code>React.createElement</code>或<code>JSX</code>编写<code>React</code>组件，<code>Babel</code>帮助我们把所有的<code>JSX </code>代码最后都会转换成<code>React.createElement(...) </code>格式</p><ul><li><p>JSX编写</p><pre><code>class Hello extends Component &#123;  render() &#123;    return &lt;div&gt;Hello ConardLi&lt;/div&gt;;  &#125;&#125;</code></pre></li><li><p><code>React.createElement</code>编写</p><pre><code>class Hello extends Component &#123;  render() &#123;    return React.createElement(&#39;div&#39;, null, `Hello ConardLi`);  &#125;&#125;</code></pre></li><li><p><code>Babel</code>转化demo</p><pre><code>&lt;div&gt;  &lt;img src=&quot;avatar.png&quot; className=&quot;profile&quot; /&gt;  &lt;Hello /&gt;&lt;/div&gt;;</code></pre><pre><code>React.createElement(&quot;div&quot;, null,     React.createElement(&quot;img&quot;, &#123;      src: &quot;avatar.png&quot;,      className: &quot;profile&quot;    &#125;),     React.createElement(Hello, null));</code></pre></li></ul></li><li><p><code>createElement</code>函数对<code>key</code>和<code>ref</code>等特殊的<code>props</code>进行处理，并获取<code>defaultProps</code>对默认<code>props</code>进行赋值，并且对传入的孩子节点进行处理，最终构造成一个<code>ReactElement</code>对象（所谓的虚拟<code>DOM</code>）。</p></li><li><p><code>ReactDOM.render</code>将生成好的虚拟<code>DOM</code>渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实<code>DOM</code>。</p></li></ul></li></ul><p>​    </p><ul><li><p>virtualDom的组成</p><p>即<code>ReactElement</code>element对象，我们的组件最终会被渲染成下面的结构</p><ul><li><code>type</code>：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或<code>class</code>）</li><li><code>key</code>：组件的唯一标识，用于<code>Diff</code>算法</li><li><code>ref</code>：用于访问原生<code>dom</code>节点</li><li><code>props</code>：传入组件的<code>props</code>，<code>chidren</code>是<code>props</code>中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点）</li><li><code>owner</code>：当前正在构建的<code>Component</code>所属的<code>Component</code></li><li><code>self</code>：（非生产环境）指定当前位于哪个组件实例</li><li><code>_source</code>：（非生产环境）指定调试代码来自的文件(<code>fileName</code>)和代码行数(<code>lineNumber</code>)</li></ul><p>例如;</p><pre><code>&lt;div class=&quot;title&quot;&gt;      &lt;span&gt;Hello ConardLi&lt;/span&gt;      &lt;ul&gt;        &lt;li&gt;苹果&lt;/li&gt;        &lt;li&gt;橘子&lt;/li&gt;      &lt;/ul&gt;&lt;/div&gt;</code></pre><pre><code>const VitrualDom = &#123;  type: &#39;div&#39;,  props: &#123; class: &#39;title&#39; &#125;,  children: [    &#123;      type: &#39;span&#39;,      children: &#39;Hello ConardLi&#39;    &#125;,    &#123;      type: &#39;ul&#39;,      children: [        &#123; type: &#39;li&#39;, children: &#39;苹果&#39; &#125;,        &#123; type: &#39;li&#39;, children: &#39;橘子&#39; &#125;      ]    &#125;  ]&#125;</code></pre></li></ul><h4 id="03-diff算法"><a href="#03-diff算法" class="headerlink" title="03 / diff算法"></a>03 / diff算法</h4><h4 id="04-fiber架构"><a href="#04-fiber架构" class="headerlink" title="04 / fiber架构"></a>04 / fiber架构</h4><blockquote><p>fiber架构是React16对核心算法的一次重构</p><p>Fiber使原本同步渲染变为异步</p></blockquote><h5 id="4-1-React历史算法的风险"><a href="#4-1-React历史算法的风险" class="headerlink" title="4.1 React历史算法的风险"></a><strong>4.1 React历史算法的风险</strong></h5><blockquote><p>React16之前,组件每次更新都会触发React去构建一棵新的虚拟DOM树,通过与上一次虚拟DOM的diff对比,实现DOM的定更新</p><p>该过程是是一个递归的过程,调用栈非常深,只有最低层的返回了,才能逐层返回.</p><p>这个过程漫长且不可打断,同步一旦开始,就会牢牢抓住线程,直到递归完成,这个过程浏览器除了渲染不会再做其他事情,无法处理用户交互状态,页面可能会卡死</p></blockquote><h5 id="4-2-Fiber是怎样处理渲染的？"><a href="#4-2-Fiber是怎样处理渲染的？" class="headerlink" title="4.2 Fiber是怎样处理渲染的？"></a><strong>4.2 Fiber是怎样处理渲染的？</strong></h5><blockquote><p>Fiber 会将一个大的更新任务拆解为许多个小任务。</p><p>每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。</p><p>在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”</p></blockquote><h5 id="4-3-说回生命周期"><a href="#4-3-说回生命周期" class="headerlink" title="4.3 说回生命周期"></a><strong>4.3 说回生命周期</strong></h5><p>在最开始给出生命周期图的时候，细心的同学会发现，在下面这张图的左边，React又将生命周期划分了如下三个阶段</p><p><img src="https://s1.ax1x.com/2020/11/10/BL0HNF.png"></p><p>render：纯净且没有副作用，可能会被暂停或者终止，重新启动<br>Pre-commit阶段：可以读取DOM<br>commit阶段：可以使用DOM，运行副作用，安排更新</p>]]></content>
    
    
    <summary type="html">&lt;center&gt;“基于 XLSX 封装的  Excel 并解析为 JSON格式数据的组件”&lt;/center&gt;</summary>
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://juntengma.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础知识综合</title>
    <link href="https://juntengma.github.io/2020/11/09/JavaScript/01%20-%20JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://juntengma.github.io/2020/11/09/JavaScript/01%20-%20JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-11-09T07:07:36.926Z</published>
    <updated>2020-11-10T03:59:51.538Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h4 id="01-JS数据类型-6-1"><a href="#01-JS数据类型-6-1" class="headerlink" title="01 / JS数据类型(6+1)"></a>01 / JS数据类型(6+1)</h4><p><strong>基本数据类型:</strong></p><pre><code>- null- undefined- number- string- boolean- symbol:代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。</code></pre><p><strong>引用数据类型:</strong></p><p>引用数据类型指的是object类型,其他如Array,Date等数据类型都可以理解为Object的子类</p><pre><code>object =  [   Array,   Date,   Math,   ...]</code></pre><p><strong>基本数据类型和引用数据类型区别:</strong></p><ul><li>基本数据类型在内存中占固定大小的空间,因此被保存在栈中</li><li>引用类型值是对象，保存在 <strong>堆内存</strong> 中。包含引用类型值的变量实际包含并非对象本身，而是指向该对象的指针。一个变量从另一个变量复制引用类型的值时，复制的也是指向该对象的指针。</li></ul><h4 id="02-什么是堆-栈"><a href="#02-什么是堆-栈" class="headerlink" title="02 / 什么是堆/栈?"></a>02 / 什么是堆/栈?</h4><p>堆栈概念存在于<strong>数据结构</strong>和<strong>操作系统</strong>内存中</p><ul><li><p>在数据结构中:</p><ul><li>栈中的数据存取方式为先进后出</li><li>堆是一个优先队列,按照优先级来进行排序的,优先级可以按照大小来规定</li></ul></li><li><p>操作系统中 ,内存被分为栈区和堆区:</p><ul><li>栈区的内存由编译器自动分配释放,存放函数的参数值,局部变量值等</li></ul></li><li><p>堆内存一般由程序员释放,若没有手动释放则程序结束时由垃圾回收机制回收</p></li></ul><h4 id="03-什么是JavaSctipt垃圾回收机制"><a href="#03-什么是JavaSctipt垃圾回收机制" class="headerlink" title="03 / 什么是JavaSctipt垃圾回收机制?"></a>03 / 什么是JavaSctipt垃圾回收机制?</h4><ul><li><p><strong>为什么要垃圾回收?</strong></p><pre><code class="html">随着前端业务需求的不断增多，相比以前，我们会占用更多的内存。但是内存并不是无限的，而对于那些我们不再需要的变量、对象该怎么处理呢？这里就是垃圾回收机制的作用</code></pre></li><li><p><strong>垃圾回收机制的特点:</strong></p><p>垃圾回收机制，会定期对那些我们不再使用的变量、对象所占用的内存进行释放</p><pre><code>原理:    + 找出那些不再使用的变量，然后释放其占用的内存。    + 垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。</code></pre></li><li><p><strong>垃圾回收的方式有哪些?</strong></p><ul><li><p>标记清除</p><ul><li><p>当变量进入环境时,就将其标记为”进入环境”,此时”进入环境”的变量是不可以被回收的”</p></li><li><p>当变量离开环境时,就将其标记为”离开环境”,此时”离开环境”的变量可以被回收</p><pre><code>function func () &#123;      const a = 1    const b = 2      // 函数执行时，a b 分别被标记 进入环境&#125;func() // 函数执行结束，a b 被标记 离开环境，被回收</code></pre></li></ul></li><li><p>引用计数</p><ul><li><p>统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收</p><pre><code>function func1 () &#123;      const c = &#123;&#125; // 引用类型变量 c的引用计数为 0      let d = c // c 被 d 引用 c的引用计数为 1      let e = c // c 被 e 引用 c的引用计数为 2      d = &#123;&#125; // d 不再引用c c的引用计数减为 1      e = null // e 不再引用 c c的引用计数减为 0 将被回收&#125;</code></pre></li><li><p>但是引用计数的方式，有一个相对明显的缺点——<strong>循环引用</strong></p><pre><code>function func5 () &#123;      let f = &#123;&#125;      let g = &#123;&#125;      f.prop = g      g.prop = f      // 由于 f 和 g 互相引用，计数永远不可能为 0&#125;</code></pre></li><li><p>像上面这种情况就需要<strong>手动将变量的内存释放</strong></p><pre><code>f.prop = nullg.prop = null</code></pre><p>参考:</p><pre><code> [&lt;&lt;javascript 垃圾回收机制&gt;&gt;](https://juejin.im/post/6844903652331618312)     [&lt;&lt;JavaScript 垃圾回收机制&gt;&gt;](https://juejin.im/post/6844903858972409869#heading-3)</code></pre></li></ul></li></ul></li></ul><h4 id="04-什么是循环引用"><a href="#04-什么是循环引用" class="headerlink" title="04 / 什么是循环引用 ?"></a>04 / 什么是循环引用 ?</h4><p>当对象 1 中的某个属性指向对象 2，对象 2 中的某个属性指向对象 1 就会出现循环引用(最简单的例子)</p><pre><code>  function circularReference() &#123;      let obj1 = &#123; &#125;;      let obj2 = &#123; &#125;;      obj1.a = obj2;      obj2.b = obj1;  &#125;</code></pre><h4 id="05-内存泄露"><a href="#05-内存泄露" class="headerlink" title="05 / 内存泄露"></a>05 / 内存泄露</h4><ul><li><p>什么是内存泄露?</p><pre><code>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</code></pre></li><li><p>常见的内存泄露有哪些?</p><ul><li><p>全局变量(在非严格模式下当引用未声明的变量时，会在全局对象中创建一个新变量。)</p><pre><code class="js">function foo（arg）&#123;     bar =“some text”; // bar将泄漏到全局.&#125;</code></pre></li><li><p>被遗忘的定时器和回调函数</p></li><li><p>DOM引用</p></li><li><p>闭包</p></li></ul></li></ul><h4 id="06-JavaScript可执行上下文"><a href="#06-JavaScript可执行上下文" class="headerlink" title="06 /  JavaScript可执行上下文"></a>06 /  JavaScript可执行上下文</h4><p><a href="/2020/11/03/JavaScript/03%20-%20JavaScript-作用域&可执行上下文/" target="_blank">&lt;&lt;JavaScript可执行上下文&gt;&gt;</a></p><h4 id="07-JavaScript在浏览器中执行顺序"><a href="#07-JavaScript在浏览器中执行顺序" class="headerlink" title="07 /  JavaScript在浏览器中执行顺序"></a>07 /  JavaScript在浏览器中执行顺序</h4><p><a href="/2020/11/03/JavaScript/03%20-%20JavaScript-作用域&可执行上下文/" target="_blank">&lt;&lt;JavaScript在浏览器中执行顺序&gt;&gt;</a></p><h4 id="08-从输入url到页面加载过程"><a href="#08-从输入url到页面加载过程" class="headerlink" title="08 /  从输入url到页面加载过程"></a>08 /  从输入url到页面加载过程</h4><p><a href="/2020/11/03/JavaScript/03%20-%20JavaScript-作用域&可执行上下文/" target="_blank">&lt;&lt;从输入url到页面加载过程&gt;&gt;</a></p><h4 id="09-内部属性-class-是什么"><a href="#09-内部属性-class-是什么" class="headerlink" title="09 / 内部属性[[class]]是什么"></a>09 / 内部属性[[class]]是什么</h4><p>所有typeof返回Object的对象都有一个内部属性.可以通过以下代码查看</p><pre><code>Object.prototype.toString.call(Array)  //&quot;[object Function]&quot;</code></pre><h4 id="10-Js内置对象都有哪些"><a href="#10-Js内置对象都有哪些" class="headerlink" title="10 / Js内置对象都有哪些"></a>10 / Js内置对象都有哪些</h4><pre><code>js内置对象主要是只在程序执行前存在全局作用域里面的由js定义的一些全局属性,函数和用来实例化其他对象的构造函数对象.一般我们经常用到的全局函数变量值 NaN , undefined ,全局函数: parseInt() , paeseFloat()用来实例化的全局构造函数: Date , Object 等</code></pre><h4 id="11-原型原型链"><a href="#11-原型原型链" class="headerlink" title="11 / 原型原型链"></a>11 / 原型原型链</h4><p><a href="">&lt;&lt;JavaScript原型原型链&gt;&gt;</a></p><h4 id="12-闭包"><a href="#12-闭包" class="headerlink" title="12 / 闭包"></a>12 / 闭包</h4><pre><code>闭包是指内部函数可以访问其所在的外部函数中声明的参数和变量;创建闭包最常用的方法是在一个函数内创建另外一个函数,创建的函数可以访问父级函数的局部变量;闭包主要有两个用途:1/ 使我们可以在函数外部访问到函数内部的变量,通过这个方法,我们可以在函数外部调用闭包函数,在函数外部访问到函数内部变量2/ 使已经运行过的函数上下文的变量对象继续保存在内存中,不被垃圾回收机制释放内存,但是操作不当可能会造成内存泄露</code></pre><h4 id="13-继承"><a href="#13-继承" class="headerlink" title="13 / 继承"></a>13 / 继承</h4><pre><code>继承实现方式:- 原型链继承- 构造函数继承- 组合继承(原型链+构造函数继承)- 原型式继承- 寄生式继承- 寄生组合式继承</code></pre><p><a href="https://github.com/mqyqingfeng/Blog/issues/16">&lt;&lt;JavaScript深入之继承的多种方式和优缺点&gt;&gt;</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h4 id=&quot;01-JS数据类型-6-1&quot;&gt;&lt;a href=&quot;#01-JS数据类型-6-1&quot; class=&quot;headerlink&quot; title=&quot;01 / JS数据类型(6+1)&quot;&gt;&lt;/a&gt;01 / JS数据类型(6+1)&lt;/h4&gt;&lt;p&gt;&lt;strong</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://juntengma.github.io/2020/11/09/JavaScript/08%20-%20JavaScript-%E9%97%AD%E5%8C%85/"/>
    <id>https://juntengma.github.io/2020/11/09/JavaScript/08%20-%20JavaScript-%E9%97%AD%E5%8C%85/</id>
    <published>2020-11-09T06:39:32.085Z</published>
    <updated>2020-11-10T04:02:04.533Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0/前置知识:"></a>0/前置知识:</h4><p><a href="https://juntengma.github.io/2020/11/03/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F/">&lt;&lt;JavaScript作用域&amp;可执行上下文&gt;&gt;</a></p><h4 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1/什么是闭包?"></a>1/什么是闭包?</h4><pre><code>- 内部函数可以访问其所在的外部函数中声明的参数和变量- 闭包找到的是同一地址中,父级函数中对应变量最终的值</code></pre><h4 id="2-闭包的特点"><a href="#2-闭包的特点" class="headerlink" title="2/闭包的特点"></a>2/闭包的特点</h4><pre><code>- 让外部访问函数内部变量成为可能；-    局部变量会常驻在内存中；- 可以避免使用全局变量，防止全局变量污染；- 可能会造成内存泄露</code></pre><h4 id="3-实际使用案例"><a href="#3-实际使用案例" class="headerlink" title="3/实际使用案例"></a>3/实际使用案例</h4><ul><li><p>函数防抖节流</p><pre><code>function debounce(fun, delay) &#123;  let timer  return function (args) &#123;    let _this = this    let _args = args      clearTimeout(timer)    timer = setTimeout(() =&gt; &#123;        fun.call(_this, _args)    &#125;, delay);  &#125;&#125;</code></pre></li><li><p>使用闭包设计单例模式</p><pre><code>class CreateUser &#123;    constructor(name) &#123;        this.name = name;        this.getName();    &#125;    getName() &#123;         return this.name;    &#125;&#125;// 代理实现单例模式var ProxyMode = (function() &#123;    var instance = null;    return function(name) &#123;        if(!instance) &#123;            instance = new CreateUser(name);        &#125;        return instance;    &#125;&#125;)();// 测试单体模式的实例var a = ProxyMode(&quot;aaa&quot;);var b = ProxyMode(&quot;bbb&quot;);// 因为单体模式是只实例化一次，所以下面的实例是相等的console.log(a === b);    //true</code></pre></li><li><p>为多个组件独立属性</p><p>假如我现在要在页面中使用echarts画6个线状图，需要6个容器 </p><p>需要为每个容器元素声明一个独立id,不然会混乱</p><pre><code> constructor()&#123; this.state = &#123;id: &quot;EchartsLine&quot;+Util.clourse()&#125;; &#125;  componentDidMount() &#123;      this.myEChart =echarts.init(document.getElementById(this.state.id));//不同id  &#125;</code></pre><pre><code>&lt;div id=&#123;this.state.id&#125; className=&#39;echarts-line&#39;&gt;&lt;/div&gt;</code></pre><pre><code>clourse()&#123;    let clourse = (function()&#123;        var a = 1;        return function()&#123;            return a++;        &#125;    &#125;)(this);    this.clourse = clourse;&#125;//使用数字命名 不用害怕被篡改</code></pre></li><li><p>设置私有变量</p><pre><code>let _width = Symbol();    class Private &#123;        constructor(s) &#123;            this[_width] = s        &#125;        foo() &#123;            console.log(this[_width])        &#125;    var p = new Private(&quot;50&quot;);    p.foo();    console.log(p[_width]);//可以拿到</code></pre><pre><code> //赋值到闭包里    let sque = (function () &#123;        let _width = Symbol();        class Squery &#123;            constructor(s) &#123;                this[_width] = s            &#125;            foo() &#123;                console.log(this[_width])            &#125;        &#125;        return Squery    &#125;)();    let ss = new sque(20);    ss.foo();    console.log(ss[_width])</code></pre></li><li><p>拿到正确的值（老掉牙的问题了😝）</p><pre><code>for(var i=0;i&lt;10;i++)&#123;    setTimeout(function()&#123;        console.log(i)//10个10    &#125;,1000)&#125;</code></pre><pre><code>for(var i=0;i&lt;10;i++)&#123;((j)=&gt;&#123;  setTimeout(function()&#123;        console.log(j)//1-10    &#125;,1000)&#125;)(i)&#125;</code></pre><p>原理是 声明了10个自执行函数，保存当时的值到内部</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h4 id=&quot;0-前置知识&quot;&gt;&lt;a href=&quot;#0-前置知识&quot; class=&quot;headerlink&quot; title=&quot;0/前置知识:&quot;&gt;&lt;/a&gt;0/前置知识:&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://juntengma.github</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="闭包" scheme="https://juntengma.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期函数</title>
    <link href="https://juntengma.github.io/2020/11/06/React/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://juntengma.github.io/2020/11/06/React/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-11-06T07:28:31.113Z</published>
    <updated>2020-11-10T04:07:29.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​    温故而知新<del>~</del></p><p>​    越基础,越重要哦~</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/06/Bf52x1.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;​    温故而知新&lt;del&gt;~&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;​    越基础,越重要哦~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/06/Bf52x1.jpg&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://juntengma.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React-Hook学习</title>
    <link href="https://juntengma.github.io/2020/11/06/React/React-hooks/"/>
    <id>https://juntengma.github.io/2020/11/06/React/React-hooks/</id>
    <published>2020-11-06T06:49:51.445Z</published>
    <updated>2020-11-06T07:26:51.011Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直都知道Hook这个新技术,但是工作过程中几乎没有用到,最近刚好有时间来学习一下<del>~</del></p></blockquote><a id="more"></a><h3 id="01-什么是Hook"><a href="#01-什么是Hook" class="headerlink" title="01/什么是Hook?"></a>01/什么是Hook?</h3><p>Hook是react16.8新增特性,可以在不编写class的情况下使用state以及其他React特性</p><h3 id="02-什么是Hook"><a href="#02-什么是Hook" class="headerlink" title="02/什么是Hook?"></a>02/什么是Hook?</h3><ul><li>Hook顾名思义是钩子的意思,它可以使函数组件中可以勾入React-State以及生命周期特性等等.</li><li>Hook不能在class组件中使用</li></ul><h3 id="03-Hook内置组件"><a href="#03-Hook内置组件" class="headerlink" title="03/Hook内置组件"></a>03/Hook内置组件</h3><ul><li><p><strong>useState</strong>    (用于操控state)</p><ul><li><p><strong>使用:</strong></p><pre><code>const [stateName , stateChangeFun] = useState(初始值)</code></pre><pre><code>const [count , setCount] = useState(0)&lt;Button onClick=&#123;()=&gt;setCount(count++)&#125;&gt;Click&lt;/Button&gt;    </code></pre></li></ul></li><li><p><strong>useEffect</strong></p><p>Effect Hook 可以让我们在react中执行副作用操作</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一直都知道Hook这个新技术,但是工作过程中几乎没有用到,最近刚好有时间来学习一下&lt;del&gt;~&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="Hook" scheme="https://juntengma.github.io/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击</title>
    <link href="https://juntengma.github.io/2020/11/04/Safe/CSRF%E6%94%BB%E5%87%BB/"/>
    <id>https://juntengma.github.io/2020/11/04/Safe/CSRF%E6%94%BB%E5%87%BB/</id>
    <published>2020-11-04T07:53:26.651Z</published>
    <updated>2020-11-10T04:08:37.994Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击</title>
    <link href="https://juntengma.github.io/2020/11/04/Safe/XSS%E6%94%BB%E5%87%BB/"/>
    <id>https://juntengma.github.io/2020/11/04/Safe/XSS%E6%94%BB%E5%87%BB/</id>
    <published>2020-11-04T07:53:15.118Z</published>
    <updated>2020-11-04T09:48:21.387Z</updated>
    
    <content type="html"><![CDATA[<p>前端知识回顾之 - XSS攻击</p><a id="more"></a><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><h4 id="1-什么是xss攻击"><a href="#1-什么是xss攻击" class="headerlink" title="1.什么是xss攻击"></a>1.什么是xss攻击</h4><ul><li>xss攻击即跨站脚本攻击,是一种恶意代码注入攻击,攻击者通过在网站上面注入恶意代码,使之在浏览器上面运行,从而获取用户的敏感信息如cookie等</li><li>xss的本质是因为网站没有对恶意代码进行过滤, 与正常代码混在一起,但是浏览器不能识别代码哪些可信哪些不可信,从而导致了恶意代码的执行.</li></ul><h4 id="2-XSS攻击分类"><a href="#2-XSS攻击分类" class="headerlink" title="2.XSS攻击分类"></a>2.XSS攻击分类</h4><ul><li><p>存储型</p><blockquote><p>存储型XSS攻击是将恶意代码提交到网站服务器中,当用户请求数据的时候,服务器将恶意代码拼接到HTML里面后返回,导致恶意代码的执行</p></blockquote></li><li><p>反射型</p><blockquote><p>反射型指的是某些通过url参数获取数据的网站,攻击者构建特殊的url,当服务器收到请求之后,从url中获取数据,并将其拼接为html后返回,从而导致了恶意代码的执行</p></blockquote></li><li><p>DOM型</p><blockquote><p>DOM型XSS攻击指的是攻击者构建了特殊的URL,当用户打开了网站之后,js脚本从url中获取数据,从而导致了恶意代码的执行</p></blockquote></li></ul><h4 id="3-如何预防XSS攻击"><a href="#3-如何预防XSS攻击" class="headerlink" title="3.如何预防XSS攻击"></a>3.如何预防XSS攻击</h4><p>​    预防XSS攻击主要有两个方案</p><ul><li><p>恶意代码提交的时候(不可靠)</p><blockquote><p>当数据即将存入数据库的时候进行转义,但是数据库的数据可能在多个地方使用,有些地方不需要转义,由于我们无法判断这些数据最后的使用场景,所以该方法是<strong>不可靠的</strong></p></blockquote></li><li><p>浏览器执行之前</p><blockquote><ul><li>使用纯前端的方式,不用服务器拼接HTML返回    </li><li>对需要插入的HTML进行充分的转义</li></ul></blockquote></li><li><p>对于DOM性XSS攻击还有以下几种方式</p><blockquote><ul><li>CSP,CSP本质是简历一个白名单,告诉浏览器哪些外部资源是可以加载和执行,从而防止恶意代码的注入攻击</li><li>对敏感信息进行保护,比如cookie使用http-only,禁止脚本获取cookie</li><li>使用验证码,防止脚本伪装用户进行操作</li></ul></blockquote></li></ul><h4 id="4-什么是CSP"><a href="#4-什么是CSP" class="headerlink" title="4.什么是CSP"></a>4.什么是CSP</h4><p>​    CSP指的是内容安全侧策略</p><p>​    他的本质是建立一个白名单,告诉浏览器哪些外部资源可以加在和执行.</p><p>​    <strong>开启SCP方式:</strong></p><ul><li>一种是设置 HTTP 首部中的 <code>Content-Security-Policy</code></li><li>一种是设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ul><p>详细资料可以参考： <a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端知识回顾之 - XSS攻击&lt;/p&gt;</summary>
    
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript作用域&amp;可执行上下文</title>
    <link href="https://juntengma.github.io/2020/11/03/JavaScript/03%20-%20JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://juntengma.github.io/2020/11/03/JavaScript/03%20-%20JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2020-11-03T09:42:08.975Z</published>
    <updated>2020-11-10T04:01:06.271Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript深入 - 作用域相关问题</p><a id="more"></a><h3 id="01-什么是作用域"><a href="#01-什么是作用域" class="headerlink" title="01 / 什么是作用域?"></a>01 / 什么是作用域?</h3><p>作用域是指程序源代码中定义变量的区域</p><ul><li>作用域规定了查找变量,也就是当前执行代码对变量的访问权限</li><li>JavaScript采用词法作用域(静态作用域)</li></ul><h3 id="02-词法作用域和静态作用域的区别"><a href="#02-词法作用域和静态作用域的区别" class="headerlink" title="02 / 词法作用域和静态作用域的区别?"></a>02 / 词法作用域和静态作用域的区别?</h3><ul><li>静态作用域:    函数的作用域在函数定义的时候就已经决定了</li><li>动态作用域:    函数的作用域在函数调用的时候才决定</li></ul><h3 id="03-JS代码执行顺序是什么"><a href="#03-JS代码执行顺序是什么" class="headerlink" title="03 / JS代码执行顺序是什么"></a>03 / JS代码执行顺序是什么</h3><p>JavaScript代码是逐行执行的 , 但是js引擎并非一行一行的解析执行程序,而是一段一段的分析执行,为什么是分段执行的呢?又按什么规则来分段的呢?这里我们需要再了解一下什么是<strong>可执行代码</strong></p><h3 id="04-可执行代码"><a href="#04-可执行代码" class="headerlink" title="04 / 可执行代码"></a>04 / 可执行代码</h3><p>可执行代码有三种,全局代码,函数代码,eval代码,当执行到可执行代码的时候,就会进行准备一些工作 . 这个准备工作就是<strong>执行上下文</strong></p><ul><li>全局代码</li><li>函数代码</li><li>eval代码(evla()函数可以将传入的字符串当做 JavaScript 代码进行执行)</li></ul><h3 id="05-执行上下文栈"><a href="#05-执行上下文栈" class="headerlink" title="05 / 执行上下文栈"></a>05 / 执行上下文栈</h3><p>为了管理js中大量的可执行上下文,JavaScript引擎创建了<strong>执行上下文栈</strong>来管理可执行上下文</p><ul><li><p>当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext.</p><pre><code>const ECStack  = [        globalContext ]</code></pre></li></ul><ul><li><p>当函数开始执行的时候,同样生成一个可以执行上下文并压入可执行上下文栈,当函数执行完毕的时候,再从执行上下文栈中弹出</p><pre><code>const ECStack  = [    eval()    function()    globalContext ]</code></pre></li></ul><h2 id="06-什么是堆栈"><a href="#06-什么是堆栈" class="headerlink" title="06 / 什么是堆栈"></a>06 / 什么是堆栈</h2><p>堆栈概念存在于<strong>数据结构</strong>和<strong>操作系统</strong>内存中</p><ul><li><p>在数据结构中:</p><ul><li>栈中的数据存取方式为先进后出</li><li>堆是一个优先队列,按照优先级来进行排序的,优先级可以按照大小来规定</li></ul></li><li><p>操作系统中: </p><p><strong>内存被分为栈区和堆区</strong></p><ul><li>栈区的内存由编译器自动分配释放,存放函数的参数值,局部变量值等</li><li>堆内存一般由程序员释放,若没有手动释放则程序结束时由垃圾回收机制回收</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;JavaScript深入 - 作用域相关问题&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="作用域&amp;可执行上下文" scheme="https://juntengma.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://juntengma.github.io/2020/11/02/JavaScript/JavaScript-ES6/"/>
    <id>https://juntengma.github.io/2020/11/02/JavaScript/JavaScript-ES6/</id>
    <published>2020-11-02T08:41:06.847Z</published>
    <updated>2020-11-02T09:48:38.394Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h4 id="ES6是什么"><a href="#ES6是什么" class="headerlink" title="ES6是什么"></a>ES6是什么</h4><p>es6是ECMA为JavaScript订制的第6个版本,2015年6月发行,涵盖了2015 - 2020</p><h4 id="ES6特性"><a href="#ES6特性" class="headerlink" title="ES6特性"></a>ES6特性</h4><ul><li>表达式<ul><li>[声明 (let/const)](#### 声明)</li><li>解构赋值</li></ul></li><li>内置对象<ul><li>字符串扩展</li><li>数值扩展</li><li>对象扩展</li><li>数组扩展</li><li>函数扩展</li><li>正则扩展</li><li>Symbol / set /Map / Proxy /Reflect</li></ul></li><li>语句与运算<ul><li>class</li><li>Module</li><li>Iterator</li></ul></li><li>异步编程<ul><li>Promise</li><li>Generator</li><li>Async</li></ul></li></ul><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><ul><li>let (声明变量,类似var,但是只在代码块中有效)<ul><li>let声明的变量只在所处于的块级有效；</li><li>let没有‘变量提升’的特性，而是‘暂时性死区（temporal dead zone）’特性</li></ul></li><li>const (声明常量)<ul><li>声明恒定变量，声明的同时就必须赋值，否则会报错</li></ul></li></ul><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域:"></a>块级作用域:</h4><h5 id="ES6之前"><a href="#ES6之前" class="headerlink" title="ES6之前"></a>ES6之前</h5><ul><li>全局作用域</li><li>函数作用域</li></ul><p>因此会产生变量提升的问题</p><pre><code>function func()&#123;    console.log(test);    var test = 1;&#125;;func();//undefind在进入func之前,所有通过var声明的变量提前声明并赋予undefinded值</code></pre><h5 id="ES6-1"><a href="#ES6-1" class="headerlink" title="ES6"></a>ES6</h5><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul><pre><code>function f1() &#123;  let n = 5;  if (true) &#123;    let n = 10;  &#125;  console.log(n); // 5&#125;function f1() &#123;  var n = 5;  if (true) &#123;    var n = 10;  &#125;  console.log(n); // 10&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h4 id=&quot;ES6是什么&quot;&gt;&lt;a href=&quot;#ES6是什么&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="https://juntengma.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>for-in &amp; for-of的区别 和 map-for &amp; Each区别</title>
    <link href="https://juntengma.github.io/2020/11/02/JavaScript/forIn-forOF-Map-forEach%E5%8C%BA%E5%88%AB/"/>
    <id>https://juntengma.github.io/2020/11/02/JavaScript/forIn-forOF-Map-forEach%E5%8C%BA%E5%88%AB/</id>
    <published>2020-11-02T07:52:25.395Z</published>
    <updated>2020-11-10T04:02:20.891Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><ul><li>遍历一个对象的除<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>以外的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举</a>属性, <strong>用于遍历对象</strong></li><li>for…in循环出的是key</li></ul><pre><code>const obj = &#123;    name: &#39;哇塞&#39;,    age: 18&#125;for(let item in obj)&#123;    console.log(item)&#125;// Output://name//age</code></pre><h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><ul><li><strong>用于遍历数组</strong></li><li>for-of 是ES6引入属性</li><li>for-of不能用来遍例普通对象,需要和Obect.keys()搭配使用</li><li>for…of循环出的是value</li></ul><pre><code>let aArray = [&#39;a&#39;,123,&#123;a:&#39;1&#39;,b:&#39;2&#39;&#125;]</code></pre><p>结论:</p><ul><li>推荐在<strong>循环对象</strong>属性的时候，使用<strong>for…in</strong></li><li>在<strong>遍历数组</strong>的时候的时候使用<strong>for…of</strong>。</li><li>for…in循环出的是key，for…of循环出的是value</li><li>注意，for…of是ES6新引入的特性。修复了ES5引入的for…in的不足</li><li>for…of不能循环普通的对象，需要通过和Object.keys()搭配使用</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h3 id=&quot;for-in&quot;&gt;&lt;a href=&quot;#for-in&quot; class=&quot;headerlink&quot; title=&quot;for-in&quot;&gt;&lt;/a&gt;for-in&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;遍历一个对象的除&lt;a href=&quot;https://deve</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>深拷贝浅拷贝</title>
    <link href="https://juntengma.github.io/2020/11/02/JavaScript/JavaScript-%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://juntengma.github.io/2020/11/02/JavaScript/JavaScript-%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-11-02T07:28:19.796Z</published>
    <updated>2020-11-10T04:02:35.834Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><a href="https://juejin.im/post/6844903929705136141">https://juejin.im/post/6844903929705136141</a></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。</p><p>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><p>浅拷贝只拷贝一层属性,无法拷贝引用数据类型</p><ul><li><code>Object.assign(&#123;&#125;,obj)</code>浅拷贝object</li><li><code>newobj = &#123;...obj2&#125;</code>  展开运算符浅拷贝</li><li><code>Object.fromEntries( Object.entriens(obj) ) </code>通过生成迭代器,在通过迭代器生成对象</li><li><code>Object.create(&#123;&#125;,Object.getOwnPropertyDescriptors(obj))</code></li></ul><p><strong>简单浅拷贝:</strong></p><pre><code>function clone(target)&#123;    let cloneTarget=&#123;&#125;;    for(let key in target)&#123;        cloneTarget[key] = target[key]    &#125;    return cloneTarget&#125;</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><ul><li><code>JSON.parse(JSON.stringfy( obj ))</code>通过<strong>JSON的2次转换深拷贝obj</strong><ul><li>无法拷贝<code>undefined</code>与<code>symbol</code>属性</li><li>无法拷贝<strong>循环引用</strong>对象</li></ul></li><li>loadsh:<a href="http://lodash.think2011.net/cloneDeep"><em>.cloneDeep</em></a></li></ul><p>简单深拷贝(可以处理<strong>原始数据类型 + Object</strong>):</p><ul><li>如果是原始类型，无需继续拷贝，直接返回</li><li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行深拷贝后依次添加到新对象上。</li></ul><pre><code>function smpleDeepCopy(target) &#123;  let type = typeof target  if (type === &quot;object&quot;) &#123;    let copy = &#123;&#125;;    for (let key in target) &#123;      copy[key] = smpleDeepCopy(target[key])    &#125;    return copy  &#125;  return target&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903929705136141&quot;&gt;https://juejin.im/post/6844903929705136141&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;浅拷贝&quot;</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="深拷贝浅拷贝" scheme="https://juntengma.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>Https及其加密原理</title>
    <link href="https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https/"/>
    <id>https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https/</id>
    <published>2020-10-30T08:59:24.175Z</published>
    <updated>2020-11-10T04:06:07.552Z</updated>
    
    <content type="html"><![CDATA[<p>Https协议及其加密原理</p><a id="more"></a><h2 id="1-http-协议存在的一些问题"><a href="#1-http-协议存在的一些问题" class="headerlink" title="1/http 协议存在的一些问题"></a>1/http 协议存在的一些问题</h2><ul><li>http报文明文发送,可能会被第三方窃听</li><li>http报文可能会被第三方截取之后修改通信内容,接收方没有办法发现报文内容的修改</li><li>http还存在认证问题,第三方可以冒充他人参与通信</li></ul><h2 id="2-Https简介"><a href="#2-Https简介" class="headerlink" title="2/Https简介"></a>2/Https简介</h2><ul><li>HTTPS指的是超文本传输安全协议,HTTPS是基于HTTTP协议的,不过它会使用TLS/SSL来对数据进行加密,即Http+TLS/SSL</li><li>使用TLS和SSL协议,所有的信息都是加密的,第三方没有办法窃听,并且他提供了一种校验机制,信息一旦被篡改,通信双方立刻就会发现</li><li>它还配备了身份证书,防止身份被冒充的情况出现</li></ul><h2 id="3-SSL加密方式"><a href="#3-SSL加密方式" class="headerlink" title="3/SSL加密方式"></a>3/SSL加密方式</h2><ul><li><p>对称加密</p><p><img src="https://s1.ax1x.com/2020/11/10/Bqe2dS.png"></p><pre><code>对称加密即客户端和服务端同时约定同一种秘钥,客户端发送信息给服务端使用该秘钥加密,服务端收到信息后在用秘钥解密,整个流程类似下面这个例子:期末考试,小明找小红希望数学考试的时候小红可以帮他,两个人考试前约定了一把秘钥:小红把所有的答案都加上250;小红把答案通过秘钥加密: 15 + 250 = 265 --&gt; 偷偷的丢给小明小明通过秘钥解密: 265- 250 = 15 ---&gt; 小明得到正确答案</code></pre><ul><li>对称加密加密效率高速度快</li><li>但是该加密方式存在一些漏洞,假如别人获取到了加密方式,然后再用该方案来解密,那数据信息岂不是还是可以被截取修改,因此出现了非对称加密的方案</li></ul></li><li><p>非对称加密</p><p>非对称加密就是有两把密钥，公钥和私钥。私钥自己藏着，不告诉任何人；而公钥可以公开给别人。</p><p><img src="https://s1.ax1x.com/2020/11/10/Bqe7LV.png"></p><pre><code>非对称加密即通信双方各自有一个秘钥和公钥,公钥用来对信息进行加密,私钥用来对信息进行解密;通信的时候, 公钥是随着信息一起发送给对方的,即公钥是公开的, 但是私钥是不会公开的假如A发送信息给B:- A把自己发送的信息连同公钥(加密方式)一起发送给B,- B方收到信息和公钥的时候,把返回的信息通过A的公钥对信息进行加密- 返回信息给A的同时把自己的公钥和密文一起发送给A- A收到B的加密信息之后,再通过自己的私钥对信息进行解密,如果还需要和B进行通信,再用B的公钥加密即可</code></pre><ul><li>非对称加密相对于对称加密安全度是高了一点,但是如果拦截方把数据拦截下来,将自己的数据用拦截下来的公钥加密后返回给发送方,放松方并不能识别出来是不是目标通信对象发来的信息,因此还需要<strong>数字签名</strong>来作保障</li></ul></li></ul><h2 id="4-数字签名"><a href="#4-数字签名" class="headerlink" title="4/数字签名"></a>4/数字签名</h2><p>数字签名是附加在报文上面的特殊加密校验码.可以防止报文被篡改,如果恶意攻击在传输过程中篡改了报文,那么校验的时候就不再匹配,因此可以确认报文被篡改;</p><p><strong>数字签名加密过程:</strong></p><ul><li>发送端将报文通过算法（比如通过HASH函数）提取为定长的摘要；</li><li>发送端将摘要应用签名算法，以私有密钥作为参数生成一个签名；</li><li>计算得出签名后，将签名附加在报文末端发送给接收方；</li><li>接收端收到报文后，对签名进行检查。接收端通过公开密钥解码签名。然后比对报文生成的摘要是否与签名一致便可判断报文是否被篡改。</li></ul><p><strong>数字证书:</strong></p><p>数字证书是由权威机构给某网站颁发的一种认可凭证。它主要包含一些认证信息，比如：对象的名称（服务器、组织、个人等）、过期时间、证书颁发者、来自证书发布者的数字签名。</p><p><img src="https://s1.ax1x.com/2020/11/10/BqM3Bq.png"></p><p>上面的图片就是<a href="http://www.google.com的证书./">www.google.com的证书。</a></p><p>我们可以看到在上面讲到数字签名的时候，似乎就可以保证报文的安全了。为什么还需要数字证书呢？这个设想一下这个场景：比如某人A把发送到浏览器的公有密钥进行了替换，同时A在给浏览器发送报文时使用自己的私有密钥对报文进行数字签名，那么浏览器就不能确认报文是否来自于真实服务器。这个时候就可以使用数字证书进行验证，因为数字证书中保存了真实服务器的信息。</p><h2 id="5-HTTPS的工作流程"><a href="#5-HTTPS的工作流程" class="headerlink" title="5/HTTPS的工作流程"></a>5/HTTPS的工作流程</h2><p><strong>建立安全传输</strong><br>在TCP连接建立完成以后，在HTTPS协议中，客户端和服务端会初始化SSL层，也就是安全层。</p><p><strong>SSL握手</strong><br>在发送报文之前，客户端和服务端会进行一次SSL握手，在这个过程中主要完成以下工作：</p><ul><li><p>交换协议版本号；</p></li><li><p>选择一个两端都了解的密码；</p></li><li><p>对两端的身份进行认证；</p></li><li><p>生成临时会话密钥，以便加密信道（建立完安全通道后，传输报文时使用对称加密）；</p></li></ul><p>在SSL会进行很多工作，处理交换一些必要的信息之外，还会对身份进行认证。</p><p>这里的认证是通过数字证书进行的，在客户端获取证书后，会采用相应的算法对服务端的身份信息进行验证：</p><ul><li><p>日期检测：客户端会检查证书的有效期是否合法；</p></li><li><p>签名颁布者可信度检测：浏览器会附带一个签名颁发机构的授信列表，如果浏览器收到了位置的颁发机构签发的证书，那么它会显示一条警告信息；</p></li><li><p>签名检测：客户端对签名使用签名颁发机构的公开密钥，然后将其与校验码比较，以便验证证书是否合法；</p></li><li><p>站点身份检测：客户端验证数字证书中的域名是否与服务端的域名匹配；</p></li></ul><p>身份认证完成后，客户端与服务端进行密码协商，确定本次连接采用哪种加密算法进行通信。</p><p><strong>开始通信</strong><br>SSL握手完成后，就完成建立了HTTPS通道，客户端与服务端就会根据协商的加密算法进行通信。</p><p>整个HTTPS的工作流程可以总结如下：</p><p><img src="https://s1.ax1x.com/2020/11/10/BqM7Uf.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6/总结"></a>6/总结</h2><p>相较于HTTP协议，HTTPS确保了报文的机密性以及完整性。HTTPS确保这些的依赖就是SSL/TSL协议，SSL/TSL安全协议搭配数字证书保证了报文在传输过程中的绝对安全。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Https协议及其加密原理&lt;/p&gt;</summary>
    
    
    
    <category term="Http&amp;Https" scheme="https://juntengma.github.io/categories/Http-Https/"/>
    
    
    <category term="Https" scheme="https://juntengma.github.io/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>Http</title>
    <link href="https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%99%A8%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%99%A8%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2020-10-30T08:49:32.136Z</published>
    <updated>2020-11-10T04:06:05.285Z</updated>
    
    <content type="html"><![CDATA[<p>HTTPS的一些知识</p><a id="more"></a><h3 id="1-什么是HTTP协议"><a href="#1-什么是HTTP协议" class="headerlink" title="1/什么是HTTP协议"></a>1/什么是HTTP协议</h3><ul><li>HTTP协议是超文本传输协议的简称,规定了服务端和客户端(前后端)通信方式以及占用的接口</li><li>HTTP协议是一个局域TCP/IP通信协议来传输数据的</li></ul><h3 id="2-HTTP协议的特性"><a href="#2-HTTP协议的特性" class="headerlink" title="2/HTTP协议的特性"></a>2/HTTP协议的特性</h3><ul><li>HTTP协议支持客户端/服务端模式,也是一种请求/响应模式的协议</li><li>简单快速,客户端向服务器请求服务时,只需要提供请求方法和URL.常用的有 GET,PSOT,DELETE,HEAD等</li><li>无连接:HTTP协议规定浏览器和服务端只能保持短暂的链接,浏览器的每次请求都需要与服务器建立一个TCP链接,服务器处理完成后立即断开TCP链接</li><li>无状态:无状态是指服务器不跟踪也不记录请求过的状态,后续如果需要前面的信息,必须重传.</li><li>但是可以借助cookie和session记住来做身份认证和状态记录</li></ul><h3 id="3-HTTP报文组成"><a href="#3-HTTP报文组成" class="headerlink" title="3/HTTP报文组成"></a>3/HTTP报文组成</h3><h4 id="请求报问"><a href="#请求报问" class="headerlink" title="请求报问"></a>请求报问</h4><ul><li>请求行</li><li>请求头(Request Header)</li><li>请求正文</li></ul><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul><li>状态行</li><li>响应头(Response Header)</li><li>响应正文</li></ul><h3 id="4-常见请求方法"><a href="#4-常见请求方法" class="headerlink" title="4/常见请求方法"></a>4/常见请求方法</h3><ul><li>GET</li><li>HEAD:类似GET请求,但是返回的响应中没有具体内容,用于获取报头</li><li>POST</li><li>PUT:从客户端向服务器传送的数据取代指定的文档的内容</li><li>DELETE:请求服务器删除指定页面</li></ul><h3 id="5-响应状态码"><a href="#5-响应状态码" class="headerlink" title="5/响应状态码"></a>5/响应状态码</h3><p>状态码分类：</p><ul><li>1XX- 信息型，服务器收到请求，需要请求者继续操作。</li><li>2XX- 成功型，请求成功收到，理解并处理。</li><li>3XX - 重定向，需要进一步的操作以完成请求。</li><li>4XX - 客户端错误，请求包含语法错误或无法完成请求。</li><li>5XX - 服务器错误，服务器在处理请求的过程中发生了错误。</li></ul><h3 id="6-常见状态码"><a href="#6-常见状态码" class="headerlink" title="6/常见状态码"></a>6/常见状态码</h3><ul><li>200:请求成功</li><li>204:无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>301:永久重定向，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302:临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>304:未修改。所请求的资源未修改，服务器不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>400:客户端请求的语法错误，服务器无法理解</li><li>401:请求要求用户的身份认证</li><li>403:服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404:服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>422:请求格式正确，但是由于含有语义错误，无法响应。</li><li>500:服务器内部错误，无法完成请求</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;HTTPS的一些知识&lt;/p&gt;</summary>
    
    
    
    <category term="Http&amp;Https" scheme="https://juntengma.github.io/categories/Http-Https/"/>
    
    
    <category term="Http" scheme="https://juntengma.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://juntengma.github.io/2020/10/30/%E7%AE%97%E6%B3%95/"/>
    <id>https://juntengma.github.io/2020/10/30/%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-30T03:39:39.217Z</published>
    <updated>2020-11-10T04:09:22.850Z</updated>
    
    <content type="html"><![CDATA[<p>复习做的几个算法练习题/…</p><a id="more"></a><p>一、不借助临时变量，进行两个整数的交换</p><pre><code>let a = 1, b = 2;[a, b] = [b, a]console.log(a, b);</code></pre><p>二、字符串查找：请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。<br>🌰:</p><pre><code>a=&#39;34&#39;;b=&#39;1234567&#39;; // 返回 2a=&#39;35&#39;;b=&#39;1234567&#39;; // 返回 -1a=&#39;355&#39;;b=&#39;12354355&#39;; // 返回 5isContain(a,b);</code></pre><p>三、统计一个字符串出现最多的字母：给出一段英文连续的英文字符窜，找出重复出现次数最多的字母。<br>🌰:</p><pre><code>输入 ： afjghdfraaaasdenas输出 ： a</code></pre><pre><code>function hasMost(str) &#123;  let counts = &#123;&#125;  for (let item of str) &#123;    counts[`$&#123;item&#125;`] = 0    for (let j of str) &#123;      if (j === item) &#123;        counts[`$&#123;item&#125;`] = counts[`$&#123;item&#125;`] + 1;      &#125;    &#125;  &#125;  getMax(counts)&#125;function getMax(counts) &#123;  let maxValue = 0  let maxItem = &#39;&#39;  for (let item in counts) &#123;    if (counts[item] &gt; maxValue) &#123;      maxValue = counts[item]      maxItem = item    &#125;  &#125;  console.log(maxItem, maxValue)&#125;</code></pre><p>四、找出下列正数组的最大差值<br>🌰:</p><pre><code>输入 [10,5,11,7,8,9]输出 6</code></pre><pre><code>function getDifferenceValue(arr) &#123;  let maxNum = null, minNum = null  arr.forEach(item =&gt; &#123;    !maxNum ? maxNum = item : !minNum ? minNum = item : null    item &gt; maxNum      ? maxNum = item      : item &lt; minNum        ? minNum = item        : minNum  &#125;)  console.log(maxNum, minNum)  console.log(maxNum - minNum)&#125;</code></pre><p>五、斐波那契数列：1、1、2、3、5、8、13、21。输入n，输出数列中第n位数的值。<br>🌰:</p><pre><code>function getValue(num) &#123;  if (num &lt; 2) &#123;    return 1  &#125; else &#123;    return (getValue(num - 1) + getValue(num - 2))  &#125;&#125;</code></pre><p>六、用js实现二分查找：二分查找的前提是有序数组</p><pre><code>🌰:将要查找的值每次与中间值比较，大于中间值，则在右边进行相同的查找，小于中间值则在左边进行比较查找，找到返回索引值，没找到返回-1。</code></pre><p>var missingNumber = function (nums) {<br>  let left = 0, right = nums.length - 1;<br>  while (left &lt;= right) {<br>    let mid = Math.floor((left + right) / 2);<br>    if (mid === nums[mid]) {<br>      left = mid + 1;<br>    } else if (mid &lt; nums[mid]) {<br>      right = mid - 1;<br>    }<br>  }<br>  return left;<br>};</p><p>```<br>七、数组去重</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习做的几个算法练习题/…&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://juntengma.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://juntengma.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Http各版本特性及其区别</title>
    <link href="https://juntengma.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E7%89%88%E6%9C%AC%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7/"/>
    <id>https://juntengma.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E7%89%88%E6%9C%AC%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7/</id>
    <published>2020-10-29T08:21:42.848Z</published>
    <updated>2020-11-10T04:06:00.823Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP各版本特性及区别"><a href="#HTTP各版本特性及区别" class="headerlink" title="HTTP各版本特性及区别"></a>HTTP各版本特性及区别</h3><a id="more"></a><p>本文参考:<br><a href="https://juejin.im/post/6844903923136856078">https://juejin.im/post/6844903923136856078</a><br><a href="https://segmentfault.com/a/1190000019891825">https://segmentfault.com/a/1190000019891825</a></p><p>HTTP 是基于 TCP/IP 协议的一个应用层协议，是现代互联网的一个基础协议。规定了客户端与服务端之间的通信格式以及所占用的服务端口80(HTTPS是443)。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>HTTP 协议从开始立项到现在一共经历了 4 个版本:</p><pre><code>HTTP 0.9 -&gt; HTTP 1.0 -&gt; HTTP 1.1 -&gt; HTTP 2</code></pre><h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h4><p>HTTP 0.9 是一个最古老的版本</p><p><strong>只支持GET请求方式</strong>：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息<br>没有请求头概念：所以不能在请求中指定版本号，<strong>服务端也只具有返回 HTML字符串的能力</strong><br><strong>服务端相响应之后，立即关闭TCP连接</strong></p><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h4><p>随着 HTTP 1.0 的发布，这个版本:</p><p>请求方式<strong>新增了POST，DELETE，PUT，HEADER等方式</strong><br>增添了<strong>请求头</strong>和<strong>响应头</strong>的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)<br>扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输<br>在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。</p><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p>一个简单请求的头信息</p><pre><code>GET / HTTP/1.0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */*</code></pre><p>浏览器控制台reponse headers<br><img src="https://s1.ax1x.com/2020/10/30/BtJAlF.png"></p><p>可以看到在请求方法之后有 请求资源的位置 + 请求协议版本，之后是一些客户端的信息配置</p><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p>一个简单响应的头信息(v1.0)</p><pre><code>HTTP/1.0 200 OKContent-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMT// 这是一个空行...数据内容</code></pre><p>浏览器控制台request headers<br><img src="https://s1.ax1x.com/2020/10/30/BtJfhV.png"></p><p>服务端的响应头第一个就是 请求协议版本，后面紧跟着是这次请求的状态码、以及状态码的描述，之后的内容是一些关于返回内容的描述。</p><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p>在 HTTP 1.0 的时候，任何的资源都可以被传输，传输的格式呢也是多种多样的，客户端在收到响应体的内容的时候就是根据这个 Content-Type 去进行解析的。所以<strong>服务端返回时候</strong>必须带着这个字段。<br><img src="https://s1.ax1x.com/2020/10/30/BtYKBj.png"><br>一些常见的 Content-Type 可以参考 对照表。 这些 Content-Type 有一个总称叫做<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a></p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>无状态：服务器不跟踪不记录请求过的状态</li><li><strong>无连接</strong>：<strong>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接）</strong></li></ul><h6 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h6><p>对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录</p><h6 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h6><p>无连接导致的性能缺陷有两种：</p><ul><li><strong>无法复用连接</strong><br>每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低</li><li><strong>队头阻塞</strong><br>HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</li></ul><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h4><p>  HTTP 1.1 是在 1.0 发布之后的半年就推出了，完善了 1.0 版本。目前也还有很多的互联网项目基于 HTTP 1.1 在向外提供服务。</p><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><p>长连接：新增Connection字段，可以设置keep-alive值保持连接不断开<br>管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回<br>缓存处理：新增字段cache-control<br>断点传输</p><h6 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h6><p>HTTP 1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据.</p><p>B站首页，就有keep-alive，因为他们也有IM的成分在里面。需要大量复用TCP连接～<br><img src="https://s1.ax1x.com/2020/10/30/Btt4L4.png"></p><h6 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h6><p>基于长连接的基础，我们先看没有管道化请求响应：</p><p>tcp没有断开，用的同一个通道</p><pre><code>--&gt; 请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3</code></pre><p>管道化的请求响应：</p><pre><code>--&gt; 请求1 --&gt; 请求2 --&gt; 请求3 --&gt; 响应1 --&gt; 响应2 --&gt; 响应3</code></pre><p>即使服务器先准备好响应2,也是按照请求顺序先返回响应1</p><p>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p><h6 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理:"></a>缓存处理:</h6><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。 通过设置字段cache-control来控制缓存。</p><p><strong>怎么解决解决队头阻塞的问题?</strong></p><blockquote><p>实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个TCP的会话。<br>也就是说，上图我们看到的并行，其实是不同的TCP连接上的HTTP请求和响应。这也就是我们所熟悉的浏览器对同域下并行加载6~8个资源的限制。而这，才是真正的并行！</p></blockquote><p><strong>浏览器同域名请求的最大并发数限制</strong></p><blockquote><p>当我们在浏览网页的时候，对浏览速度有一个重要的影响因素，就是浏览器的并发数量。并发数量简单通俗的讲就是，当浏览器网页的时候同时工作的进行数量。</p></blockquote><ul><li><p>HTTP客户端一般对同一个服务器的并发连接个数都是有限制的。<br>实际上，浏览器确实使用并行连接，但它们将并行连接的总数限制为少量（<strong>通常为四个</strong>）。服务器可以自由地关闭来自特定客户端的过多连接。</p></li><li><p>一些主流浏览器对HTTP 1.1和HTTP 1.0的最大并发连接数目，可以参考如下表格：</p></li></ul><p><img src="https://s1.ax1x.com/2020/10/30/BtcGjA.png"></p><h6 id="断点传输"><a href="#断点传输" class="headerlink" title="断点传输"></a>断点传输</h6><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p><h5 id="Http-1-1的致命缺点："><a href="#Http-1-1的致命缺点：" class="headerlink" title="Http 1.1的致命缺点："></a>Http 1.1的致命缺点：</h5><p>1.明文传输<br>2.其实还是没有解决无状态连接的<br>3.当有多个请求同时被挂起的时候,就会拥塞请求通道，导致后面请求无法发送<br>4.臃肿的消息首部:HTTP/1.1能压缩请求内容,但是消息首部不能压缩;在现今请求中,消息首部占请求绝大部分(甚至是全部)也较为常见.</p><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h4><h5 id="特性-2"><a href="#特性-2" class="headerlink" title="特性:"></a>特性:</h5><h6 id="二进制帧封装"><a href="#二进制帧封装" class="headerlink" title="二进制帧封装:"></a>二进制帧封装:</h6><p>HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率</p><h6 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用:"></a>多路复用:</h6><blockquote><p>所有的请求都是通过一个 TCP 连接并发完成。<br>HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。</p><p>同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。</p><p>即：HTTP2.0对于同一域名下所有请求都是基于流的，不管对于同一域名访问多少文件，也只建立一路连接。优先级高的流会被优先发送。图片请求的优先级要低于 CSS 和 SCRIPT，这个设计可以确保重要的东西可以被优先加载完</p></blockquote><h6 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩:"></a>头部压缩:</h6><p>由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源，</p><p>HTTPS 和 HTTP</p><ul><li>HTTPS 协议需要申请证书</li><li>HTTP 和 HTTPS 使用端口不一样，前者是80，后者是443</li><li>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li><li>HTTPS 可以有效的防止运营商劫持</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;HTTP各版本特性及区别&quot;&gt;&lt;a href=&quot;#HTTP各版本特性及区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP各版本特性及区别&quot;&gt;&lt;/a&gt;HTTP各版本特性及区别&lt;/h3&gt;</summary>
    
    
    
    <category term="Http&amp;Https" scheme="https://juntengma.github.io/categories/Http-Https/"/>
    
    
    <category term="Http" scheme="https://juntengma.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>防抖节流及其应用场景</title>
    <link href="https://juntengma.github.io/2020/10/29/JavaScript/08.1%20-%20JavaScript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>https://juntengma.github.io/2020/10/29/JavaScript/08.1%20-%20JavaScript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2020-10-29T02:30:59.717Z</published>
    <updated>2020-11-09T09:58:39.304Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​    复习一下防抖节流及其应用场景</p></blockquote><a id="more"></a><h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><p>在事件被触发的n秒后再执行回调,如果在这n秒内又被触发,则重新计时</p><pre><code>function debounse(fun, delay) &#123;    let timer;    // 设置一个 timer    return function (args) &#123;      let _this = this      let _args = args      clearTimeout(timer)      timer = setTimeout(function () &#123;        fun.call(_this, _args);      &#125;, delay);    &#125;  &#125;</code></pre><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p><pre><code>function throttle(fun, delay) &#123;    let last, timer    return function (args) &#123;      let _this = this      let _args = args      let now = +new Date()      if (last &amp;&amp; now &lt; last + delay) &#123;        clearTimeout(timer)        timer = setTimeout(function () &#123;          last = now          fun.apply(_this, _args)        &#125;, delay)      &#125; else &#123;        last = now        fun.apply(_this, _args)      &#125;    &#125;  &#125;</code></pre><h3 id="demo"><a href="#demo" class="headerlink" title="demo:"></a>demo:</h3><h5 id="模拟ajax请求"><a href="#模拟ajax请求" class="headerlink" title="模拟ajax请求"></a>模拟ajax请求</h5><pre><code>function ajax(params) &#123;    console.log(&#39;ajax request : &#39; + params)&#125;</code></pre><h5 id="普通input"><a href="#普通input" class="headerlink" title="普通input:"></a>普通input:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252be5c94d6b?imageslim"></p><h5 id="加入防抖"><a href="#加入防抖" class="headerlink" title="加入防抖:"></a>加入防抖:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4b429b56?imageslim"></p><h5 id="加入节流"><a href="#加入节流" class="headerlink" title="加入节流:"></a>加入节流:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4c1a9686?imageslim"></p><h3 id="demo代码"><a href="#demo代码" class="headerlink" title="demo代码"></a>demo代码</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  没有防抖的Input &lt;input type=&quot;text&quot; class=&quot;unDebounce&quot;&gt;  &lt;br&gt;  加入防抖的Input &lt;input type=&quot;text&quot; class=&quot;debounce&quot;&gt;  &lt;br&gt;  加入截留的Input &lt;input type=&quot;text&quot; class=&quot;htrottle&quot;&gt;&lt;/body&gt;&lt;script&gt;  function ajax(params) &#123;    console.log(&#39;ajax request : &#39; + params)  &#125;  let inputValue0 = document.querySelector(&#39;.unDebounce&#39;)  inputValue0.addEventListener(&#39;keyup&#39;, function (e) &#123;    ajax(e.target.value)  &#125;)  /**********************防抖********************************/  function debounse(fun, delay) &#123;    let timer;    // 设置一个 timer    return function (args) &#123;      let _this = this      // 取debounce执行作用域的this      let _args = args      clearTimeout(timer)      timer = setTimeout(function () &#123;        fun.call(_this, args);      &#125;, delay);    &#125;  &#125;  let inputValue1 = document.querySelector(&#39;.debounce&#39;)  let debounse_ajax = debounse(ajax, 500)  inputValue1.addEventListener(&#39;keyup&#39;, function (e) &#123;    debounse_ajax(e.target.value)  &#125;)  /**********************节流********************************/  function throttle(fun, delay) &#123;    let last, timer    return function (args) &#123;      let _this = this      let _args = args      let now = +new Date()      if (last &amp;&amp; now &lt; last + delay) &#123;        clearTimeout(timer)        timer = setTimeout(function () &#123;          last = now          fun.apply(_this, _args)        &#125;, delay)      &#125; else &#123;        last = now        fun.apply(_this, _args)      &#125;    &#125;  &#125;  let inputValue2 = document.querySelector(&#39;.htrottle&#39;)  let htrottle_ajax = throttle(ajax, 2000)  inputValue2.addEventListener(&#39;keyup&#39;, function (e) &#123;    htrottle_ajax(e.target.value)  &#125;)&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;​    复习一下防抖节流及其应用场景&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="防抖节流" scheme="https://juntengma.github.io/tags/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>JsonServer</title>
    <link href="https://juntengma.github.io/2020/10/28/%E5%B7%A5%E5%85%B7/Json-server/"/>
    <id>https://juntengma.github.io/2020/10/28/%E5%B7%A5%E5%85%B7/Json-server/</id>
    <published>2020-10-28T11:04:41.772Z</published>
    <updated>2020-11-10T04:06:48.549Z</updated>
    
    <content type="html"><![CDATA[<h1 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h1><p>json-server 是什么？如何使用？</p><blockquote><p>json-server 是一个 npm 管理的包，可以提供前端提供mock的功能。</p></blockquote><a id="more"></a><h2 id="json-server-的使用"><a href="#json-server-的使用" class="headerlink" title="json-server 的使用"></a>json-server 的使用</h2><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1/安装"></a>1/安装</h4><p>全局安装:</p><pre><code>- yarn global add json-server- npm install -g json-server </code></pre><h4 id="2-提供一个json数据的文件"><a href="#2-提供一个json数据的文件" class="headerlink" title="2.提供一个json数据的文件"></a>2.提供一个json数据的文件</h4><h4 id="3-使用json-server命令开启一个端口服务"><a href="#3-使用json-server命令开启一个端口服务" class="headerlink" title="3.使用json-server命令开启一个端口服务"></a>3.使用json-server命令开启一个端口服务</h4><pre><code>json-server --watch --port 3000 test.json</code></pre><h4 id="4-接口的使用"><a href="#4-接口的使用" class="headerlink" title="4.接口的使用:"></a>4.接口的使用:</h4><blockquote><ol><li>列表</li></ol></blockquote><blockquote><ol start="2"><li>详情</li></ol></blockquote><blockquote><ol start="3"><li>分页</li></ol></blockquote><blockquote><ol start="4"><li>排序</li></ol></blockquote><blockquote><ol start="5"><li>全局查询<br>需要使用第三方接口调试工具的(postman)</li></ol></blockquote><blockquote><ol start="6"><li>提供 增加（post）、</li></ol></blockquote><blockquote><ol start="7"><li>删除(delete)、</li></ol></blockquote><blockquote><ol start="8"><li>更新(put)</li></ol></blockquote><p>我们常见的接口：都是 get 或者 post 请求一个 url 地址即可。<br>json-server 除了常见的 get 或者 post ，还提供了诸如 put 、delete 这样的HTTP请求方式，<strong>对于这种使用 http请求方式 + 请求url地址 形成的 api ，我们一般叫做 RESTFul 风格的api</strong>, <em>RESTFul 风格的api底层遵循的是 REST 架构这种协议。</em></p><p>倒叙:<a href="http://localhost:3000/news?sort=id&amp;order=desc">http://localhost:3000/news?sort=id&amp;order=desc</a> </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;json-server&quot;&gt;&lt;a href=&quot;#json-server&quot; class=&quot;headerlink&quot; title=&quot;json-server&quot;&gt;&lt;/a&gt;json-server&lt;/h1&gt;&lt;p&gt;json-server 是什么？如何使用？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;json-server 是一个 npm 管理的包，可以提供前端提供mock的功能。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="tools" scheme="https://juntengma.github.io/categories/tools/"/>
    
    
    <category term="JsonServer" scheme="https://juntengma.github.io/tags/JsonServer/"/>
    
  </entry>
  
  <entry>
    <title>JSONP跨域请求及其原理</title>
    <link href="https://juntengma.github.io/2020/10/28/Ajax/JsonP/"/>
    <id>https://juntengma.github.io/2020/10/28/Ajax/JsonP/</id>
    <published>2020-10-28T10:46:25.938Z</published>
    <updated>2020-11-10T04:05:25.820Z</updated>
    
    <content type="html"><![CDATA[<p>JSONP及其原理</p><a id="more"></a><h5 id="1、JSONP的产生"><a href="#1、JSONP的产生" class="headerlink" title="1、JSONP的产生"></a>1、JSONP的产生</h5><p><strong>背景:</strong></p><ul><li><p>因为浏览器同源策略限制,AJAX跨域请求不到信息</p></li><li><p>Web页面上面调用js文件不受是否跨域影响(类似的还有<code>&lt;script&gt;</code>,<code>&lt;IMG&gt;</code>,<code>&lt;iframe&gt;</code>)</p></li><li><p>于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、Web socket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；</p></li><li><p>恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被JS原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</p></li><li><p>客户端在对JSON文件调用成功之后,也就获得了自己所需要的数据,剩下的就是按自己的需求进行处理和展现了</p></li><li><p>为了方便客户使用数据,逐渐形成了一种非正式传输协议—JSONP.</p><blockquote><p>该协议允许用户传递一个callback参数给服务端,然后服务端返回数据时会将这个callback参数坐会函数名来包裹JSON数据,这样客户端就可以随意订制自己的函数来自动处理返回函数了</p></blockquote></li></ul><h5 id="2、JSONP弊端"><a href="#2、JSONP弊端" class="headerlink" title="2、JSONP弊端"></a>2、JSONP弊端</h5><ul><li>只能发送get请求</li><li>需要服务端配合</li></ul><h5 id="3、JSON流程"><a href="#3、JSON流程" class="headerlink" title="3、JSON流程"></a>3、JSON流程</h5><ul><li>先定义好全局函数</li><li>动态创建script标签</li><li>给服务器提供事先创建好的容器</li><li>服务器获取容器</li><li>将内容填充进容器</li></ul><h5 id="4、-代码实现-https-github-com-JuntengMa-JavaScript-tree-master-JsonP"><a href="#4、-代码实现-https-github-com-JuntengMa-JavaScript-tree-master-JsonP" class="headerlink" title="4、[代码实现]:https://github.com/JuntengMa/JavaScript/tree/master/JsonP"></a>4、[代码实现]:<a href="https://github.com/JuntengMa/JavaScript/tree/master/JsonP">https://github.com/JuntengMa/JavaScript/tree/master/JsonP</a></h5>]]></content>
    
    
    <summary type="html">&lt;p&gt;JSONP及其原理&lt;/p&gt;</summary>
    
    
    
    <category term="Ajax" scheme="https://juntengma.github.io/categories/Ajax/"/>
    
    
    <category term="JSONP" scheme="https://juntengma.github.io/tags/JSONP/"/>
    
  </entry>
  
</feed>
