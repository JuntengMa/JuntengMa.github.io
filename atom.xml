<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>June&#39;s Blog</title>
  
  
  <link href="https://juntengma.github.io/atom.xml" rel="self"/>
  
  <link href="https://juntengma.github.io/"/>
  <updated>2020-11-23T07:59:55.307Z</updated>
  <id>https://juntengma.github.io/</id>
  
  <author>
    <name>June</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自定义webpack配置</title>
    <link href="https://juntengma.github.io/2020/11/23/React/%E8%87%AA%E5%AE%9A%E4%B9%89webpack%E9%85%8D%E7%BD%AE/"/>
    <id>https://juntengma.github.io/2020/11/23/React/%E8%87%AA%E5%AE%9A%E4%B9%89webpack%E9%85%8D%E7%BD%AE/</id>
    <published>2020-11-23T07:29:16.000Z</published>
    <updated>2020-11-23T07:59:55.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="create-react-app-自定义配置webpack"><a href="#create-react-app-自定义配置webpack" class="headerlink" title="create-react-app 自定义配置webpack"></a>create-react-app 自定义配置webpack</h1><h4 id="1、修改webpack配置文件，需要安装-react-app-rewired-customize-cra"><a href="#1、修改webpack配置文件，需要安装-react-app-rewired-customize-cra" class="headerlink" title="1、修改webpack配置文件，需要安装 react-app-rewired customize-cra"></a>1、修改webpack配置文件，需要安装 react-app-rewired customize-cra</h4><pre><code>yarn add react-app-rewired customize-cra -D</code></pre><h4 id="2、修改package-json文件"><a href="#2、修改package-json文件" class="headerlink" title="2、修改package.json文件"></a>2、修改package.json文件</h4><pre><code>&quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;react-app-rewired start&quot;,    &quot;build&quot;: &quot;react-app-rewired build&quot;,    &quot;test&quot;: &quot;react-app-rewired test --env=jsdom&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  &#125;,</code></pre><h4 id="3、在项目根目录新建config-overrides-js"><a href="#3、在项目根目录新建config-overrides-js" class="headerlink" title="3、在项目根目录新建config-overrides.js"></a>3、在项目根目录新建config-overrides.js</h4><pre><code>const &#123; override &#125; = require(&#39;customize-cra&#39;);module.exports = &#123;&#125;;</code></pre><h4 id="4、一些plugins"><a href="#4、一些plugins" class="headerlink" title="4、一些plugins"></a>4、一些plugins</h4><pre><code></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;create-react-app-自定义配置webpack&quot;&gt;&lt;a href=&quot;#create-react-app-自定义配置webpack&quot; class=&quot;headerlink&quot; title=&quot;create-react-app 自定义配置webpack&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://juntengma.github.io/2020/11/19/TypeScript/Untitled/"/>
    <id>https://juntengma.github.io/2020/11/19/TypeScript/Untitled/</id>
    <published>2020-11-19T10:07:00.753Z</published>
    <updated>2020-11-19T10:28:15.521Z</updated>
    
    <content type="html"><![CDATA[<p>面试官你好,我的名字叫马俊腾,是一名web前端开发<br>目前工作3年, 对HTML,js,jq,框架之类的都比较熟悉<br>自己的特点: 心态好, 学习能力强, 对新技术比较敏感,愿意去学习新东西新知识,平时也会写写博客沉淀自身</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试官你好,我的名字叫马俊腾,是一名web前端开发&lt;br&gt;目前工作3年, 对HTML,js,jq,框架之类的都比较熟悉&lt;br&gt;自己的特点: 心态好, 学习能力强, 对新技术比较敏感,愿意去学习新东西新知识,平时也会写写博客沉淀自身&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://juntengma.github.io/2020/11/18/Safe/JWT%E9%89%B4%E6%9D%83/"/>
    <id>https://juntengma.github.io/2020/11/18/Safe/JWT%E9%89%B4%E6%9D%83/</id>
    <published>2020-11-18T02:39:37.578Z</published>
    <updated>2020-11-18T03:46:20.353Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT(JSON Web Token)"></a>JWT(JSON Web Token)</h4><h4 id="01-什么是JWT"><a href="#01-什么是JWT" class="headerlink" title="01/ 什么是JWT"></a>01/ 什么是JWT</h4><ul><li><p>JWT是JSON Web Token的缩写,是一种易用且无状态的鉴权方式</p></li><li><p>用于在各方之间以JSON对象安全传输信息。这些信息可以通过数字签名进行验证和信任。</p></li><li><p>简单来说就是server端把JSON数据经过加密做成Token,以授权给client端</p></li></ul><h4 id="02-栗子"><a href="#02-栗子" class="headerlink" title="02/ 栗子:"></a>02/ 栗子:</h4><p>当Client端登录完成以后，Server端要返回一个7天有效的token，那么对应的Python的样例代码会是这样的：<br>（<a href="https://link.zhihu.com/?target=https://github.com/jpadilla/pyjwt">使用了PyJWT包：pip install pyjwt</a>）</p><pre><code>import timeimport jwtexp = int(time.time()) + 86400 * 7  # 失效时间user = &#39;liriansu&#39;  # 用户表示key = &#39;hunter2&#39;  # 密钥payload = &#123;&#39;exp&#39;: exp, &#39;user&#39;: user&#125;  # JSON 数据token = jwt.encode(payload, key)print(token)# token可能会长这样子# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.EoKoMCjq_zGqUg5HDfqw4EN7EiG6gMjkUZle0uGJDGU</code></pre><p>然后Client端每次在authorization header或者是query string里带上token。<br>Server端收到请求的时候，<br>用<code>payload = jwt.decode(token, key)</code>验证权限就行了。<br>验证通过以后，payload中就是整个JSON数据。<br>理论上你可以往token payload里塞任何<strong>_非敏感</strong>_数据。</p><h4 id="03-使用场景"><a href="#03-使用场景" class="headerlink" title="03 / 使用场景"></a>03 / 使用场景</h4><ul><li><p>鉴权</p><p>用户一旦登录,后续的每个请求都需要携带jwt,允许该用户访问该令牌允许的路由,服务和资源.</p><p>单点登录是当前使用最广泛的JWT的一项功能,因为开销较小,并且能够跨域使用</p></li><li><p>信息交换</p><p>JWT是在各方之间安全传输信息的好方式,因为JWT可以签名：例如使用公钥/私钥对，所以可以确定发件人是他们自称的人。此外，由于使用标头和有效载荷计算签名，因此您还可以验证内容是否未被篡改。</p></li></ul><h4 id="04-JWT结构"><a href="#04-JWT结构" class="headerlink" title="04 /  JWT结构"></a>04 /  JWT结构</h4><p><code> eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.EoKoMCjq_zGqUg5HDfqw4EN7EiG6gMjkUZle0uGJDGU</code></p><p>如上所示,JWT输出的是三个由点分隔的<code>xxxx.yyyy.zzzz</code>Base64-URL字符串，可以在HTML和HTTP环境中轻松传递，</p><p>他们分别代表:</p><ul><li>Header<ul><li>Header通常由两部分组成：令牌的类型，即JWT。和常用的散列算法</li><li>Header部分的JSON被Base64Url编码，形成JWT的第一部分。</li></ul></li><li>Payload<ul><li>存放沟通讯息的地方</li><li>Registered claims（注册声明）</li><li>Public claims（公开声明）</li><li>Private claims（私有声明）</li></ul></li><li>Signature<ul><li>用来验证发送请求者身份，由前两部分加密形成。</li></ul></li></ul><h4 id="04-所以综合来说，"><a href="#04-所以综合来说，" class="headerlink" title="04/ 所以综合来说，"></a>04/ 所以综合来说，</h4><p>假如使用JWT作为鉴权方式，<br>有以下几个特性：</p><ol><li>Client端不用管任何加密/解密，只用存token，在请求里面带上就行了。</li><li>Server端可以实现不依赖外部存储鉴权，所有的数据都丢在token里。</li><li>也就是说鉴权这一步不需要File/MySQL/Redis之类的数据库，也能知道用户身份。</li><li>因为token带失效时间，所以需要在失效前/后再刷新token。</li></ol><h4 id="05-常见问题"><a href="#05-常见问题" class="headerlink" title="05/ 常见问题"></a>05/ 常见问题</h4><h5 id="①-JWT-安全嗎"><a href="#①-JWT-安全嗎" class="headerlink" title="① JWT 安全嗎?"></a>① JWT 安全嗎?</h5><p>Base64编码方式是可逆的，也就是透过编码后发放的Token内容是可以被解析的。一般而言，我们都不建议在有效载荷内放敏感讯息，比如使用者的密码。</p><h5 id="②-JWT-Payload-內容可以被伪造嗎？"><a href="#②-JWT-Payload-內容可以被伪造嗎？" class="headerlink" title="② JWT Payload 內容可以被伪造嗎？"></a>② JWT Payload 內容可以被伪造嗎？</h5><p>JWT其中的一个组成内容为Signature，可以防止通过Base64可逆方法回推有效载荷内容并将其修改。因为Signature是经由Header跟Payload一起Base64组成的。</p><h5 id="③-如果我的-Cookie-被窃取了，那不就表示第三方可以做-CSRF-攻击"><a href="#③-如果我的-Cookie-被窃取了，那不就表示第三方可以做-CSRF-攻击" class="headerlink" title="③ 如果我的 Cookie 被窃取了，那不就表示第三方可以做 CSRF 攻击?"></a>③ 如果我的 Cookie 被窃取了，那不就表示第三方可以做 CSRF 攻击?</h5><p>是的，Cookie丢失，就表示身份就可以被伪造。故官方建议的使用方式是存放在LocalStorage中，并放在请求头中发送。</p><h5 id="④-空间及长度问题？"><a href="#④-空间及长度问题？" class="headerlink" title="④ 空间及长度问题？"></a>④ 空间及长度问题？</h5><p>JWT Token通常长度不会太小，特别是Stateless JWT Token，把所有的数据都编在Token里，很快的就会超过Cookie的大小（4K）或者是URL长度限制。</p><h5 id="⑤-Token失效问题？"><a href="#⑤-Token失效问题？" class="headerlink" title="⑤ Token失效问题？"></a>⑤ Token失效问题？</h5><p>无状态JWT令牌（Stateless JWT Token）发放出去之后，不能通过服务器端让令牌失效，必须等到过期时间过才会失去效用。</p><p>假设在这之间Token被拦截，或者有权限管理身份的差异造成授权Scope修改，都不能阻止发出去的Token失效并要求使用者重新请求新的Token。</p><h4 id="06-JWT使用建议"><a href="#06-JWT使用建议" class="headerlink" title="06/ JWT使用建议"></a>06/ JWT使用建议</h4><ul><li>不要存放敏感信息在Token里。</li><li>Payload中的exp时效不要设定太长。</li><li>开启Only Http预防XSS攻击。</li><li>如果担心重播攻击（replay attacks ）可以增加jti（JWT ID），exp（有效时间） Claim。</li><li>在你的应用程序应用层中增加黑名单机制，必要的时候可以进行Block做阻挡（这是针对掉令牌被第三方使用窃取的手动防御）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;JWT-JSON-Web-Token&quot;&gt;&lt;a href=&quot;#JWT-JSON-Web-Token&quot; class=&quot;headerlink&quot; title=&quot;JWT(JSON Web Token)&quot;&gt;&lt;/a&gt;JWT(JSON Web Token)&lt;/h4&gt;&lt;h4 id=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://juntengma.github.io/2020/11/12/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%89%91%E6%8C%87offer/"/>
    <id>https://juntengma.github.io/2020/11/12/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%89%91%E6%8C%87offer/</id>
    <published>2020-11-12T11:53:26.042Z</published>
    <updated>2020-11-16T02:14:57.811Z</updated>
    
    <content type="html"><![CDATA[<p>[1/二维数组中的查找](#1/ 二维数组中的查找)</p><p>[2/ 替换空格](#2/ 替换空格)</p><h4 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1/ 二维数组中的查找"></a>1/ 二维数组中的查找</h4><blockquote><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>demo:</p><ul><li><p>输入</p><pre><code>7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code></pre></li><li><p>输出</p><pre><code>true</code></pre></li></ul></blockquote><pre><code>function Find(target, array) &#123;  for(let i=0;i&lt;array.length;i++)&#123;    if(array[i].indexOf(target)!==-1)&#123;      return true    &#125;  &#125;  return false&#125;</code></pre><h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2/ 替换空格"></a>2/ 替换空格</h4><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><pre><code>function replaceSpace(str)&#123;  return str.replace(/ /g,&#39;%20&#39;)&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[1/二维数组中的查找](#1/ 二维数组中的查找)&lt;/p&gt;
&lt;p&gt;[2/ 替换空格](#2/ 替换空格)&lt;/p&gt;
&lt;h4 id=&quot;1-二维数组中的查找&quot;&gt;&lt;a href=&quot;#1-二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;1/ 二维数组中的查找</summary>
      
    
    
    
    <category term="算法" scheme="https://juntengma.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://juntengma.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://juntengma.github.io/2020/11/09/JavaScript/09%20-%20JavaScript-Promise/"/>
    <id>https://juntengma.github.io/2020/11/09/JavaScript/09%20-%20JavaScript-Promise/</id>
    <published>2020-11-09T09:53:53.461Z</published>
    <updated>2020-11-17T05:21:51.359Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4> 前端异步处理之 - Promise vs async/await</h4></blockquote><a id="more"></a><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="1-js回调地狱"><a href="#1-js回调地狱" class="headerlink" title="1/ js回调地狱"></a>1/ js回调地狱</h4><blockquote><p>在开发过程中我们经常遇到这种情况: </p><p>异步js或使用回调的js很难直观地得到正确的结果 , 一个异步函数的输出是另外一个异步函数的输入,如果嵌套层数过多，可读性和可以维护性都会变得很差，产生所谓的“回调地狱</p></blockquote><pre><code>let fs = require(&#39;fs&#39;)fs.readFile(&#39;./name.txt&#39;,&#39;utf8&#39;,function(err,data)&#123;  fs.readFile(data, &#39;utf8&#39;,function(err,data)&#123;    fs.readFile(data,&#39;utf8&#39;,function(err,data)&#123;      console.log(data);    &#125;)  &#125;)&#125;)</code></pre><p>总结一下回调地狱出现的原因:</p><ul><li><strong>嵌套调用</strong>，第一个函数的输出往往是第二个函数的输入；<ul><li><strong>处理多个异步请求并发</strong>，开发时往往需要同步请求最终的结果;</li></ul></li></ul><h4 id="2-怎么处理回调地狱"><a href="#2-怎么处理回调地狱" class="headerlink" title="2/ 怎么处理回调地狱"></a>2/ 怎么处理回调地狱</h4><ul><li><strong>消灭嵌套调用</strong>：通过 Promise 的链式调用可以解决(.then())；</li><li><strong>合并多个任务的请求结果</strong>：使用 Promise.all 获取合并多个任务的错误处理。</li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="1-什么是promise"><a href="#1-什么是promise" class="headerlink" title="1.什么是promise?"></a>1.什么是promise?</h4><p><img src="https://s3.ax1x.com/2020/11/13/DS4cZt.png"><br> 如上图所示,Promise是一个构造函数,身上有</p><ul><li><p>all()</p></li><li><p>reject()</p></li><li><p>resolve()几个方法,</p></li></ul><p>prototype上有</p><ul><li>then()</li><li>catch()等方法</li></ul><h4 id="2-Promise的特征"><a href="#2-Promise的特征" class="headerlink" title="2.Promise的特征"></a>2.Promise的特征</h4><ul><li>对象的状态不受外界影响,<code>Promise</code>对象代表一个异步操作，有下面这三种状态,只有异步操作可以决定当前是哪种状态<ul><li>pending(进行中)</li><li>fulfilled(成功)</li><li>rejected(失败)</li></ul></li><li>状态一旦改变, 结果就不再变化,Promise状态只可能会出现下面两种情况<ul><li>pending —&gt; fulfilled</li><li>pending —&gt; rejected</li></ul></li></ul><p><strong><code>Promise</code>的优点：</strong></p><p><strong>可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</strong></p><h4 id="3-Promise怎么创建"><a href="#3-Promise怎么创建" class="headerlink" title="3.Promise怎么创建?"></a>3.Promise怎么创建?</h4><ul><li><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 <code>JavaScript</code> 引擎提供，不用自己部署</li><li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li><li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code>变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li></ul><pre><code class="js">let promise = new Promise((resolve, reject) =&gt; &#123;  //此处执行一些异步操作（调用后台API，定时器等）  if (/*异步操作成功*/) &#123;    resolve(value);  &#125; else &#123;    reject(error)  &#125;&#125;)</code></pre><ul><li><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。</li><li>其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</li></ul><pre><code>promise.then(res=&gt;&#123;    //对于成功回调接受的数据做处理&#125;,err=&gt;&#123;    //对于失败的回调数据做处理&#125;)</code></pre><h4 id="4-实现一个符合PromiseA-规范的Promise"><a href="#4-实现一个符合PromiseA-规范的Promise" class="headerlink" title="4. 实现一个符合PromiseA+规范的Promise"></a>4. 实现一个符合PromiseA+规范的Promise</h4><p>该版本只能简单实现处理同步/异步函数, then的链式调用并没有真正实现…需要再做研究</p><pre><code>//1.先定义三个状态const PENDING = &quot;PENDING&quot;;const FULFILLED = &quot;FULFILLED&quot;;const REJECTED = &quot;REJECTED&quot;;//2.clss实例化一个promiseclass Promise &#123;  constructor(executor) &#123;    this.status = PENDING;    //存放成功状态    this.success = undefined;    //存放失败状态    this.error = undefined;    // 存放成功的回调    this.onResolvedCallbacks = [];    // 存放失败的回调    this.onRejectedCallbacks = [];        //3.实现resolve , reject    let resolve = (value) =&gt; &#123;      if (this.status === PENDING) &#123;        this.status = FULFILLED;        this.success = value;        //这句话的意思是把存储起来的异步回调也执行掉        this.onResolvedCallbacks.forEach(fn =&gt; fn());      &#125;    &#125;    let reject = (error) =&gt; &#123;      if (this.status === PENDING) &#123;        this.status = REJECTED;        this.error = error;        this.onRejectedCallbacks.forEach(fn =&gt; fn());      &#125;    &#125;     //异常捕获    try &#123;      executor(resolve, reject)    &#125; catch (error) &#123;      reject(error)    &#125;  &#125;    //4.实现then方法  then(onFulfilled, onRejected) &#123;    if (this.status === FULFILLED) &#123;      return onFulfilled(this.success)    &#125;    if (this.status === REJECTED) &#123;      return onRejected(this.error)    &#125;    if (this.status === PENDING) &#123;      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行      this.onResolvedCallbacks.push(() =&gt; &#123;        onFulfilled(this.success)      &#125;);      this.onRejectedCallbacks.push(() =&gt; &#123;        onRejected(this.error);      &#125;)    &#125;  &#125;&#125;//测试demolet promise = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(&#39;ok&#39;)  &#125;, 2000)&#125;).then((success) =&gt; &#123;  console.log(&#39;success&#39;, success)&#125;, (error) =&gt; &#123;  console.log(&#39;error&#39;)&#125;)// success ok</code></pre><h4 id="5-async-await"><a href="#5-async-await" class="headerlink" title="5. async/await"></a>5. async/await</h4><blockquote><p>一种相对Promise更为优雅的异步函数处理方案</p></blockquote><p>5.1    什么是async/await</p><ul><li><code>async</code>是异步的意思</li><li><code>await</code>有等待的意思</li><li><code>async</code>用于申明一个<code>function</code>是异步的，而<code>await</code> 用于等待一个异步方法执行完成。</li></ul><p>5.2     使用</p><pre><code>async getAjaxData()&#123;    let res = await sendAjax()&#125;</code></pre><p>5.3 注意事项</p><pre><code>- await操作符等的是一个返回的结果，那么如果是同步的情况，那就直接返回了。- 如果是异步的情况下，await会阻塞整一个流程，直到结果返回之后，才会继续下面的代码。阻塞代码是一个很可怕的事情，而async函数，会被包在一个promise中，异步去执行。所以await只能在async函数中使用，如果在正常程序中使用，会造成整个程序阻塞，得不偿失。</code></pre><h4 id="6-Promise-和-async-await区别"><a href="#6-Promise-和-async-await区别" class="headerlink" title="6.Promise 和 async/await区别"></a>6.Promise 和 async/await区别</h4><p>直接上代码</p><ul><li>Promise版本</li></ul><pre><code>function doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 = 300;    step1(time1)        .then(time2 =&gt; &#123;            return step2(time1, time2)                .then(time3 =&gt; [time1, time2, time3]);        &#125;)        .then(times =&gt; &#123;            const [time1, time2, time3] = times;            return step3(time1, time2, time3);        &#125;)        .then(result =&gt; &#123;            console.log(`result is $&#123;result&#125;`);            console.timeEnd(&quot;doIt&quot;);        &#125;);&#125;doIt();</code></pre><ul><li>async / await 版本</li></ul><pre><code>async function doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 = 300;    const time2 = await step1(time1);    const time3 = await step2(time1, time2);    const result = await step3(time1, time2, time3);    console.log(`result is $&#123;result&#125;`);    console.timeEnd(&quot;doIt&quot;);&#125;doIt();</code></pre><p>更详细的可以参考:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/288384170">&lt;&lt;你不知道的promise&gt;&gt;</a></li><li><a href="https://juejin.im/post/6844903843507994632">&lt;&lt;学习Promise基础及手写Promise&gt;&gt;</a></li><li><a href="https://juejin.im/post/6844903960910757902">&lt;&lt;理解async/await&gt;&gt;</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
前端异步处理之 - Promise vs async/await
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="Promise" scheme="https://juntengma.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript处理异步函数几种方案</title>
    <link href="https://juntengma.github.io/2020/11/09/JavaScript/JavaScript-%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88/"/>
    <id>https://juntengma.github.io/2020/11/09/JavaScript/JavaScript-%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88/</id>
    <published>2020-11-09T09:53:53.397Z</published>
    <updated>2020-11-12T12:32:36.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  for-in & for-of的区别 和 map-for & Each区别</h4></blockquote><a id="more"></a><h1 id="JS处理异步函数几种方案"><a href="#JS处理异步函数几种方案" class="headerlink" title="JS处理异步函数几种方案"></a>JS处理异步函数几种方案</h1><h4 id="1-回调函数"><a href="#1-回调函数" class="headerlink" title="1.回调函数"></a>1.回调函数</h4><p>顾名思义: 将一个函数作为参数传入另外一个函数中,等父级函数执行完再执行回调函数</p><pre><code class="js">function f1(callBack)&#123;    console.log(&quot;hello&quot;)    let data = &quot;world&quot;    callBack(data)&#125;f1((data)=&gt;console.log(data))// hello// world</code></pre><p>回调函数优缺点:</p><blockquote><p>优点: 简单方便,适用于<strong>只有一个异步的操作</strong><br>缺点:如果嵌套层级过深,会形成回调地狱,耦合度过强</p></blockquote><pre><code class="js">getData(&#39;x&#39;,()=&gt;&#123;    //callBack函数体    getData2(&#39;y&#39;,()=&gt;&#123;        //callBack函数体        getData3(&#39;z&#39;,()=&gt;&#123;            //callBack函数体            ...        &#125;)    &#125;)&#125;)</code></pre><h4 id="2-Promise对象-async-await-最常用-终极解决方案"><a href="#2-Promise对象-async-await-最常用-终极解决方案" class="headerlink" title="2.Promise对象+async+await(最常用,终极解决方案)"></a>2.Promise对象+async+await(最常用,终极解决方案)</h4><ul><li><p>promise严格来说是一种模式,可以来管理异步代码</p></li><li><p>什么是Promise?</p><blockquote><p>Promise是解决异步编程的一种方案</p></blockquote></li><li><p>优点:</p><blockquote><p>可以解决回调地狱问题,且Promise只有resolve 和 reject 两种状态</p></blockquote></li><li><p>常用API:</p><blockquote><p>resolve : 返回异步操作成功结果<br>reject    : 返回异步操作失败结果<br>then      : 执行Promise状态为成功的操作<br>catch     :执行Promise状态为失败的操作<br>finally    :不管Promise是否成功都执行的操作</p></blockquote></li><li><p>使用:</p><pre><code class="js">    const p  = new Promise((resolve,reject)=&gt;&#123;        //异步操作        if(success)&#123;            resolve(&#39;some message&#39;)        &#125;else&#123;            reject(err)        &#125;    &#125;)    p.then(res=&gt;&#123;        //resolve数据    &#125;).catch(err=&gt;&#123;        //rejects数据    &#125;).finally(()=&gt;&#123;        //执行一些操作    &#125;)</code></pre></li><li><p>使用案例2: 封装nodejs的request模块</p><pre><code class="js">const request = require(&quot;request&quot;);const requestData = (uri) =&gt; &#123;    return new Promise((resolve, reject) =&gt; &#123;        request(&#123;            uri        &#125;, (err, res, body) =&gt; &#123;            resolve(&#123;                err,                res,                body            &#125;)        &#125;)    &#125;)&#125;;//使用let url = &quot;https://imgcache.qq.com/wss/security//ssl/build/ssl-444feca18a7857546ff9b39bbc95a17c.js&quot;;(async() =&gt; &#123;    let &#123;        err,        res,        body    &#125; = await requestData(url)    console.log(res)&#125;)()</code></pre></li></ul><h4 id="3-事件绑定"><a href="#3-事件绑定" class="headerlink" title="3.事件绑定"></a>3.事件绑定</h4><p>事件绑定的方法有三种</p><p>一，事件监听，<br>二，对象.on方法，<br>三，直接在行内写<br>事件监听有两种方法，</p><blockquote><ul><li>addlisenerevent</li><li>attachevent</li></ul></blockquote><p>两种事件监听的区别:<br>addeventlistener参数个数一般是三个，参数书写（事件类型）不写on执行顺序为：顺序注册倒序执行，兼容非IE7.8，最后一个参数是TRUE或FALSE，TRUE为捕获，FALSE为冒泡，默认FALSE<br>attachevent参数个数为两个，参数书写不写on，执行顺序：顺序注册倒序执行，兼容ie78</p><h4 id="4-Generator函数"><a href="#4-Generator函数" class="headerlink" title="4.Generator函数"></a>4.Generator函数</h4>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 for-in &amp; for-of的区别 和 map-for &amp; Each区别
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>React学习</title>
    <link href="https://juntengma.github.io/2020/11/09/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://juntengma.github.io/2020/11/09/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-11-09T08:58:59.845Z</published>
    <updated>2020-11-20T08:28:28.997Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React基础知识汇总"><a href="#React基础知识汇总" class="headerlink" title="React基础知识汇总"></a>React基础知识汇总</h4><p>[TOC]</p><a id="more"></a><h4 id="01-生命周期"><a href="#01-生命周期" class="headerlink" title="01 / 生命周期"></a>01 / 生命周期</h4><p><strong>react15生命周期</strong><img src="https://s1.ax1x.com/2020/11/10/BLFB1P.png"></p><p>React的生命周期就是组件从初始化到卸载到全过程，可以分为以下几个阶段</p><ul><li>初始化阶段(<ul><li><strong>constructor()</strong>, </li><li><strong>componentWillMount</strong>(),</li><li><strong>render</strong>(), </li><li><strong>componentDidMount</strong>()</li></ul></li><li>更新阶段<ul><li><strong>componentWillReceiveProps</strong>(),</li><li><strong>shouldComponentUpdate</strong>(), </li><li><strong>componentWillUpdate</strong>(), </li><li><strong>render</strong>(), </li><li><strong>componentDidUpdate</strong>()</li></ul></li><li>卸载阶段<ul><li><strong>componentWillUnmont</strong>()</li></ul></li></ul><p>这里需要注意的是更新阶段，componentWillReceiveProps是由父组件触发的更新，只要父组件更新，子组件的该生命周期就会被执行，跟props无关。同是，shouldComponentUpdate可以用来做性能优化</p><p><strong>react16生命周期</strong></p><p><img src="https://s1.ax1x.com/2020/11/10/BLkabF.png"></p><p>在React16的生命周期中，去掉了曾经的<strong>componentWillMount</strong>和<strong>componentWillUpdate</strong>，使用<strong>getDerivedStateFromProps</strong>代替这两个方法。同时在更新阶段的render方法和componentDidUpdate之间，新增了一个<strong>getSnapshotBeforeUpdate</strong>方法。接下来就来详细了解一下React这么做的原理以及这些新增生命周期的具体使用</p><p><strong>react15和react16的区别</strong></p><ul><li><h6 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLu3c9.png"></p><ul><li><p><code>-</code>    componentWillMount()</p></li><li><p><code>+</code>    getDerivedStateFromProps()</p><ol><li><p>getDerivedStateFromProps() 主要用于替换 componentWillReceiveProps() 的</p></li><li><p>getDerivedStateFromProps是一个静态方法 , 需要使用static声明</p></li><li><p>getDerivedStateFromProps 接收两个参数, 父组件传递过来的props和自身state</p></li><li><p>必须返回一个对象格式的返回值，否则控制台会被警告</p></li><li><p>该返回值会被用来更新现有state(并不会覆盖原有State，只做定向更新，如果原来State中没有该属性，则新增)，如果没有需要更新的时候，请记得返回一个null</p><pre><code>static getDerivedStateFromProps(props,state)&#123;  return newState&#125;</code></pre></li></ol></li></ul></li><li><h6 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLMPMj.png"></p><ul><li><code>-</code>componentWillReceiveProps()</li><li><code>+</code>getDerivedStateFormProps()</li><li><code>-</code>componentWillupdate()</li><li><code>+</code>getSnapshotBetforeupdate()</li></ul></li></ul><p>React16中也去掉了componentWillUpdate方法，新增了getSnapshotBeforeUpdate方法，这个方法在render方法之后，componentDidUpdate之前被执行，即真实DOM更新之前（获取更新前的真实DOM和更新前后的State&amp;props信息）。该方法需要一个返回值，作为componentDidUpdate的第三个参数。</p><ul><li><h6 id="componentWillReceiveProps-和getDerivedStateFormProps-区别"><a href="#componentWillReceiveProps-和getDerivedStateFormProps-区别" class="headerlink" title="componentWillReceiveProps()和getDerivedStateFormProps()区别"></a>componentWillReceiveProps()和getDerivedStateFormProps()区别</h6></li></ul><table><thead><tr><th>getDerivedStateFormProps( props , state )</th><th>componentWillReceiveProps( nextPorps )</th></tr></thead><tbody><tr><td>使用static 声明: <code>static getDerivedStateFormProps( props , state )&#123;&#125;</code></td><td>直接声明: <code>componentWillReceiveProps( nextPorps )&#123;&#125;</code></td></tr><tr><td><strong>在组件挂载阶段即可执行,父组件更新执行</strong></td><td><strong>只在父组件更新的时候执行</strong></td></tr><tr><td>接收两个参数:  props  ,  state</td><td>接收一个参数( nextPorps )</td></tr><tr><td><strong>必须返回一个对象格式的返回值 或 null</strong></td><td><strong>可以直接更新state状态</strong></td></tr></tbody></table><p><strong>demo:</strong></p><pre><code>  static getDerivedStateFromProps(props, state) &#123;    if (props.age !== state.age) &#123;      return &#123; age: props.age &#125;      // 类似setStae      // this.setState(&#123;      //   age: props.age      // &#125;);    &#125;    return null  &#125;</code></pre><pre><code>  componentWillReceiveProps(nextporps) &#123;    if (nextporps.age !== this.state.age) &#123;      this.setState(&#123;        age: nextporps.age       &#125;);    &#125;  &#125;</code></pre><h4 id="02-Virtual-Dom"><a href="#02-Virtual-Dom" class="headerlink" title="02 / Virtual Dom"></a>02 / Virtual Dom</h4><ul><li><p>什么是Virtual Dom?</p><ul><li>在原生的<code>JavaScript</code>程序中，我们直接对<code>DOM</code>进行创建和更改，而<code>DOM</code>元素通过我们监听的事件和我们的应用程序进行通讯。</li><li><code>React</code>会先将你的代码转换成一个<code>JavaScript</code>对象，然后这个<code>JavaScript</code>对象再转换成真实<code>DOM</code>。这个<code>JavaScript</code>对象就是所谓的虚拟<code>DOM</code>。</li><li>当我们需要创建或更新元素时，<code>React</code>首先会让这个<code>VitrualDom</code>对象进行创建和更改，然后再将<code>VitrualDom</code>对象渲染成真实<code>DOM</code>；</li><li>当我们需要对<code>DOM</code>进行事件监听时，首先对<code>VitrualDom</code>进行事件监听，<code>VitrualDom</code>会代理原生的<code>DOM</code>事件从而做出响应。</li></ul></li><li><p>为什么使用虚拟dom?</p><ul><li><p>可以提高开发效率</p><pre><code>使用JavaScript，我们在编写应用程序时的关注点在于如何更新DOM。使用React，你只需要告诉React你想让视图处于什么状态，React则通过VitrualDom确保DOM与该状态相匹配。你不必自己去完成属性操作、事件处理、DOM更新，React会替你完成这一切。这让我们更关注我们的业务逻辑而非DOM操作，这一点即可大大提升我们的开发效率。</code></pre></li><li><p>性能提升?(有一些矛盾)</p><pre><code>- 直接说虚拟DOM可以提升性能这种说法是很片面的,直接操作dom非常耗费性能这一点毋庸置疑,但是react同样也无法避免操作dom-    如果是首次渲染,virtualDom不具有任何优势,甚至要进行更多的计算和耗费更多的内存- virtualDOm优势在于diff算法和批量处理策略,在react页面更新之前,已经提前计算好了如何更新和渲染dom,减少重绘回流,因此可以理解为提升了性能</code></pre></li><li><p>跨浏览器兼容</p><pre><code>virtualDom自己实现了一套事件机制,模拟了事件捕获和冒泡的过程,采用了事件代理和批量更新的方法,可以抹平各浏览器事件处理不兼容的问题</code></pre></li></ul></li><li><p>React组件的渲染流程</p><ul><li><p>使用<code>React.createElement</code>或<code>JSX</code>编写<code>React</code>组件，<code>Babel</code>帮助我们把所有的<code>JSX </code>代码最后都会转换成<code>React.createElement(...) </code>格式</p><ul><li><p>JSX编写</p><pre><code>class Hello extends Component &#123;  render() &#123;    return &lt;div&gt;Hello ConardLi&lt;/div&gt;;  &#125;&#125;</code></pre></li><li><p><code>React.createElement</code>编写</p><pre><code>class Hello extends Component &#123;  render() &#123;    return React.createElement(&#39;div&#39;, null, `Hello ConardLi`);  &#125;&#125;</code></pre></li><li><p><code>Babel</code>转化demo</p><pre><code>&lt;div&gt;  &lt;img src=&quot;avatar.png&quot; className=&quot;profile&quot; /&gt;  &lt;Hello /&gt;&lt;/div&gt;;</code></pre><pre><code>React.createElement(&quot;div&quot;, null,     React.createElement(&quot;img&quot;, &#123;      src: &quot;avatar.png&quot;,      className: &quot;profile&quot;    &#125;),     React.createElement(Hello, null));</code></pre></li></ul></li><li><p><code>createElement</code>函数对<code>key</code>和<code>ref</code>等特殊的<code>props</code>进行处理，并获取<code>defaultProps</code>对默认<code>props</code>进行赋值，并且对传入的孩子节点进行处理，最终构造成一个<code>ReactElement</code>对象（所谓的虚拟<code>DOM</code>）。</p></li><li><p><code>ReactDOM.render</code>将生成好的虚拟<code>DOM</code>渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实<code>DOM</code>。</p></li></ul></li></ul><p>​    </p><ul><li><p>virtualDom的组成</p><p>即<code>ReactElement</code>element对象，我们的组件最终会被渲染成下面的结构</p><ul><li><code>type</code>：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或<code>class</code>）</li><li><code>key</code>：组件的唯一标识，用于<code>Diff</code>算法</li><li><code>ref</code>：用于访问原生<code>dom</code>节点</li><li><code>props</code>：传入组件的<code>props</code>，<code>chidren</code>是<code>props</code>中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点）</li><li><code>owner</code>：当前正在构建的<code>Component</code>所属的<code>Component</code></li><li><code>self</code>：（非生产环境）指定当前位于哪个组件实例</li><li><code>_source</code>：（非生产环境）指定调试代码来自的文件(<code>fileName</code>)和代码行数(<code>lineNumber</code>)</li></ul><p>例如;</p><pre><code>&lt;div class=&quot;title&quot;&gt;      &lt;span&gt;Hello ConardLi&lt;/span&gt;      &lt;ul&gt;        &lt;li&gt;苹果&lt;/li&gt;        &lt;li&gt;橘子&lt;/li&gt;      &lt;/ul&gt;&lt;/div&gt;</code></pre><pre><code>const VitrualDom = &#123;  type: &#39;div&#39;,  props: &#123; class: &#39;title&#39; &#125;,  children: [    &#123;      type: &#39;span&#39;,      children: &#39;Hello ConardLi&#39;    &#125;,    &#123;      type: &#39;ul&#39;,      children: [        &#123; type: &#39;li&#39;, children: &#39;苹果&#39; &#125;,        &#123; type: &#39;li&#39;, children: &#39;橘子&#39; &#125;      ]    &#125;  ]&#125;</code></pre></li></ul><h4 id="03-diff算法"><a href="#03-diff算法" class="headerlink" title="03 / diff算法"></a>03 / diff算法</h4><ul><li>DIFF算法是DOM更新的一种算法,指页面被更新时,程序用哪种策略更新DOM</li><li>作用是用来计算出 <strong>Virtual DOM</strong> 中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面。</li></ul><p>DIFF算法策略:</p><ul><li><p>Tree Diff    对树每一层进行遍历，找出不同</p><p><img src="https://s3.ax1x.com/2020/11/17/DVYzW9.png"></p></li><li><p>Component Diff  是数据层面的差异比较</p></li><li><p>Element Diff  真实DOM渲染，结构差异的比较</p><ul><li>Diff提供三种DOM操作：<strong>删除</strong>、<strong>移动</strong>、<strong>插入</strong>。</li></ul></li></ul><p><img src="https://s3.ax1x.com/2020/11/17/DVYozn.png"></p><h4 id="04-fiber架构"><a href="#04-fiber架构" class="headerlink" title="04 / fiber架构"></a>04 / fiber架构</h4><blockquote><p>fiber架构是React16对核心算法的一次重构</p><p>Fiber使原本同步渲染变为异步</p></blockquote><p><strong>4.1 React历史算法的风险</strong></p><blockquote><p>React16之前,组件每次更新都会触发React去构建一棵新的虚拟DOM树,通过与上一次虚拟DOM的diff对比,实现DOM的定更新</p><p>该过程是是一个递归的过程,调用栈非常深,只有最低层的返回了,才能逐层返回.</p><p>这个过程漫长且不可打断,同步一旦开始,就会牢牢抓住线程,直到递归完成,这个过程浏览器除了渲染不会再做其他事情,无法处理用户</p><p>交互状态,页面可能会卡死</p></blockquote><p><strong>4.2 Fiber是怎样处理渲染的？</strong></p><blockquote><p>Fiber 会将一个大的更新任务拆解为许多个小任务。</p><p>每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。</p><p>在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”</p></blockquote><p><strong>4.3 说回生命周期</strong></p><p>在最开始给出生命周期图的时候，细心的同学会发现，在下面这张图的左边，React又将生命周期划分了如下三个阶段</p><p><img src="https://s1.ax1x.com/2020/11/10/BL0HNF.png"></p><ul><li>render：纯净且没有副作用，可能会被暂停或者终止，重新启动</li><li>Pre-commit阶段：可以读取DOM</li><li>commit阶段：可以使用DOM，运行副作用，安排更新</li></ul><p><strong>4.4为什么会这样分呢？</strong></p><blockquote><p>总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。</p><p>为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，再狂的框架也不敢在用户眼皮子底下胡乱更改视图，所以这个过程必须用同步渲染来求稳。</p></blockquote><p><strong>4.5废除的生命周期跟Fiber之间的联系</strong></p><pre><code>在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。这就导致 render 阶段的生命周期都是有可能被重复执行的。带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：componentWillMount；componentWillUpdate；componentWillReceiveProps。这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。</code></pre><h4 id="05-React数据传递方案"><a href="#05-React数据传递方案" class="headerlink" title="05 / React数据传递方案"></a>05 / React数据传递方案</h4><ul><li>组件传值</li><li>context</li><li>redux</li></ul><h4 id="06-setState之后发生什么"><a href="#06-setState之后发生什么" class="headerlink" title="06 / setState之后发生什么?"></a>06 / setState之后发生什么?</h4><p>一、React中setState后发生了什么</p><blockquote><p>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程(Reconciliation)。</p><p>经过调和过程，React 会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个Ul界面。</p><p>在React得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变,这就保证了按需更新，而不是全部重新渲染。</p></blockquote><p>二、setState 为什么默认是异步</p><blockquote><p>假如所有setState是同步的，意味着每执行一次setState时 (有可能一个同步代码中， 多次setState) 都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异 步，则可以把一一个同步代码中的多个setState合并成- -次组件更新。</p></blockquote><p>三、setState什么时候是同步</p><blockquote><p>在setTimeout或者原生事件中，setState是同步的。</p></blockquote><h4 id="7-componentWillUpdate可以直接修改state的值吗？"><a href="#7-componentWillUpdate可以直接修改state的值吗？" class="headerlink" title="7 / componentWillUpdate可以直接修改state的值吗？"></a>7 / componentWillUpdate可以直接修改state的值吗？</h4><blockquote><p>react组件在每次需要重新渲染时候都会调用<code>componentWillUpdate()</code>,</p><p>例如，我们调用 <code>this.setState()</code>时候</p><p>在这个函数中我们之所以不调用<code>this.setState()</code>是因为该方法会触发另一个<code>componentWillUpdate()</code>,如果我们<code>componentWillUpdate()</code>中触发状态更改,我们将以无限循环结束.</p></blockquote><h4 id="8-使用Hooks要遵守哪些原则？"><a href="#8-使用Hooks要遵守哪些原则？" class="headerlink" title="8 / 使用Hooks要遵守哪些原则？"></a>8 / 使用Hooks要遵守哪些原则？</h4><blockquote><ol><li>只在最顶层使用 Hook, 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</li><li>只在 React 函数中调用 Hook, 不要在普通的 JavaScript 函数中调用 Hook。</li><li>可以：<br>✅ 在 React 的函数组件中调用 Hook<br>✅ 在自定义 Hook 中调用其他 Hook</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;center&gt;“基于 XLSX 封装的  Excel 并解析为 JSON格式数据的组件”&lt;/center&gt;</summary>
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://juntengma.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://juntengma.github.io/2020/11/09/JavaScript/08%20-%20JavaScript-%E9%97%AD%E5%8C%85/"/>
    <id>https://juntengma.github.io/2020/11/09/JavaScript/08%20-%20JavaScript-%E9%97%AD%E5%8C%85/</id>
    <published>2020-11-09T06:39:32.085Z</published>
    <updated>2020-11-12T12:31:51.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  闭包</h4></blockquote><a id="more"></a><h4 id="0-前置知识"><a href="#0-前置知识" class="headerlink" title="0/前置知识:"></a>0/前置知识:</h4><p><a href="https://juntengma.github.io/2020/11/03/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F/">&lt;&lt;JavaScript作用域&amp;可执行上下文&gt;&gt;</a></p><h4 id="1-什么是闭包"><a href="#1-什么是闭包" class="headerlink" title="1/什么是闭包?"></a>1/什么是闭包?</h4><pre><code>- 内部函数可以访问其所在的外部函数中声明的参数和变量- 闭包找到的是同一地址中,父级函数中对应变量最终的值</code></pre><h4 id="2-闭包的特点"><a href="#2-闭包的特点" class="headerlink" title="2/闭包的特点"></a>2/闭包的特点</h4><pre><code>- 让外部访问函数内部变量成为可能；-    局部变量会常驻在内存中；- 可以避免使用全局变量，防止全局变量污染；- 可能会造成内存泄露</code></pre><h4 id="3-实际使用案例"><a href="#3-实际使用案例" class="headerlink" title="3/实际使用案例"></a>3/实际使用案例</h4><ul><li><p>函数防抖节流</p><pre><code>function debounce(fun, delay) &#123;  let timer  return function (args) &#123;    let _this = this    let _args = args      clearTimeout(timer)    timer = setTimeout(() =&gt; &#123;        fun.call(_this, _args)    &#125;, delay);  &#125;&#125;</code></pre></li><li><p>使用闭包设计单例模式</p><pre><code>class CreateUser &#123;    constructor(name) &#123;        this.name = name;        this.getName();    &#125;    getName() &#123;         return this.name;    &#125;&#125;// 代理实现单例模式var ProxyMode = (function() &#123;    var instance = null;    return function(name) &#123;        if(!instance) &#123;            instance = new CreateUser(name);        &#125;        return instance;    &#125;&#125;)();// 测试单体模式的实例var a = ProxyMode(&quot;aaa&quot;);var b = ProxyMode(&quot;bbb&quot;);// 因为单体模式是只实例化一次，所以下面的实例是相等的console.log(a === b);    //true</code></pre></li><li><p>为多个组件独立属性</p><p>假如我现在要在页面中使用echarts画6个线状图，需要6个容器 </p><p>需要为每个容器元素声明一个独立id,不然会混乱</p><pre><code> constructor()&#123; this.state = &#123;id: &quot;EchartsLine&quot;+Util.clourse()&#125;; &#125;  componentDidMount() &#123;      this.myEChart =echarts.init(document.getElementById(this.state.id));//不同id  &#125;</code></pre><pre><code>&lt;div id=&#123;this.state.id&#125; className=&#39;echarts-line&#39;&gt;&lt;/div&gt;</code></pre><pre><code>clourse()&#123;    let clourse = (function()&#123;        var a = 1;        return function()&#123;            return a++;        &#125;    &#125;)(this);    this.clourse = clourse;&#125;//使用数字命名 不用害怕被篡改</code></pre></li><li><p>设置私有变量</p><pre><code>let _width = Symbol();    class Private &#123;        constructor(s) &#123;            this[_width] = s        &#125;        foo() &#123;            console.log(this[_width])        &#125;    var p = new Private(&quot;50&quot;);    p.foo();    console.log(p[_width]);//可以拿到</code></pre><pre><code> //赋值到闭包里    let sque = (function () &#123;        let _width = Symbol();        class Squery &#123;            constructor(s) &#123;                this[_width] = s            &#125;            foo() &#123;                console.log(this[_width])            &#125;        &#125;        return Squery    &#125;)();    let ss = new sque(20);    ss.foo();    console.log(ss[_width])</code></pre></li><li><p>拿到正确的值（老掉牙的问题了😝）</p><pre><code>for(var i=0;i&lt;10;i++)&#123;    setTimeout(function()&#123;        console.log(i)//10个10    &#125;,1000)&#125;</code></pre><pre><code>for(var i=0;i&lt;10;i++)&#123;((j)=&gt;&#123;  setTimeout(function()&#123;        console.log(j)//1-10    &#125;,1000)&#125;)(i)&#125;</code></pre><p>原理是 声明了10个自执行函数，保存当时的值到内部</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 闭包
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="闭包" scheme="https://juntengma.github.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期函数</title>
    <link href="https://juntengma.github.io/2020/11/06/React/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://juntengma.github.io/2020/11/06/React/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-11-06T07:28:31.113Z</published>
    <updated>2020-11-10T04:07:29.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​    温故而知新<del>~</del></p><p>​    越基础,越重要哦~</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/06/Bf52x1.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;​    温故而知新&lt;del&gt;~&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;​    越基础,越重要哦~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/06/Bf52x1.jpg&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://juntengma.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React-Hook学习</title>
    <link href="https://juntengma.github.io/2020/11/06/React/React-hooks/"/>
    <id>https://juntengma.github.io/2020/11/06/React/React-hooks/</id>
    <published>2020-11-06T06:49:51.445Z</published>
    <updated>2020-11-18T04:35:52.435Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直都知道Hook这个新技术,但是工作过程中几乎没有用到,最近刚好有时间来学习一下<del>~</del></p></blockquote><a id="more"></a><h3 id="01-什么是Hook"><a href="#01-什么是Hook" class="headerlink" title="01/什么是Hook?"></a>01/什么是Hook?</h3><p>Hook是react16.8新增特性,可以在不编写class的情况下使用state以及其他React特性</p><h3 id="02-什么是Hook"><a href="#02-什么是Hook" class="headerlink" title="02/什么是Hook?"></a>02/什么是Hook?</h3><ul><li>Hook顾名思义是钩子的意思,它可以使函数组件中可以勾入React-State以及生命周期特性等等.</li><li>Hook不能在class组件中使用</li></ul><h3 id="03-Hook内置组件"><a href="#03-Hook内置组件" class="headerlink" title="03/Hook内置组件"></a>03/Hook内置组件</h3><ul><li><p><strong>useState</strong>    (用于操控state)</p><ul><li><p><strong>使用:</strong></p><pre><code>const [stateName , stateChangeFun] = useState(初始值)</code></pre><pre><code>const [count , setCount] = useState(0)&lt;Button onClick=&#123;()=&gt;setCount(count++)&#125;&gt;Click&lt;/Button&gt;    </code></pre></li></ul></li><li><p><strong>useEffect</strong></p><p>Effect Hook 可以让我们在react中执行副作用操作</p><p><code>useEffect</code> 的第二个参数，有三种情况</p><ol><li>什么都不传，组件每次 <code>render</code> 之后 <code>useEffect</code> 都会调用，相当于 <code>componentDidMount</code> 和 <code>componentDidUpdate</code></li></ol></li></ul><ol start="2"><li>传入一个空数组 [], 只会调用一次，相当于 <code>componentDidMount</code> 和 <code>componentWillUnmount</code><ol start="3"><li>传入一个数组，其中包括变量，只有这些变量变动时，<code>useEffect</code> 才会执行</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一直都知道Hook这个新技术,但是工作过程中几乎没有用到,最近刚好有时间来学习一下&lt;del&gt;~&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="Hook" scheme="https://juntengma.github.io/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击</title>
    <link href="https://juntengma.github.io/2020/11/04/Safe/CSRF%E6%94%BB%E5%87%BB/"/>
    <id>https://juntengma.github.io/2020/11/04/Safe/CSRF%E6%94%BB%E5%87%BB/</id>
    <published>2020-11-04T07:53:26.651Z</published>
    <updated>2020-11-16T09:10:00.414Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="01-什么是CSRF攻击"><a href="#01-什么是CSRF攻击" class="headerlink" title="01/ 什么是CSRF攻击?"></a>01/ 什么是CSRF攻击?</h4><p>CSRF攻击指的是跨站请求伪造,攻击者诱导用户进入第三方网站,然后该网站向被攻击者网站发送跨站请求.</p><p>如果用户在被攻击者网站中保存了登录状态,攻击者就可以利用这个状态,绕过后台验证,冒充用户向服务器执行一些操作;</p><h4 id="02-CSRF攻击分类"><a href="#02-CSRF攻击分类" class="headerlink" title="02/ CSRF攻击分类"></a>02/ CSRF攻击分类</h4><ul><li>GET请求的CSRF攻击, 通常用img标签构建请求,用户打开网站的时候,自动发送请求</li><li>POST请求CSRF攻击,比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单</li><li>链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li></ul><h4 id="03-防御方法"><a href="#03-防御方法" class="headerlink" title="03/ 防御方法"></a>03/ 防御方法</h4><ul><li>第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</li><li>第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</li><li>第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li><li>第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li><li>验证码</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h4 id=&quot;01-什么是CSRF攻击&quot;&gt;&lt;a href=&quot;#01-什么是CSRF攻击&quot; class=&quot;headerlink&quot; title=&quot;01/ 什么是CSRF攻击?&quot;&gt;&lt;/a&gt;01/ 什么是CSRF攻击?&lt;/h4&gt;&lt;p&gt;CSRF攻击指</summary>
      
    
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击</title>
    <link href="https://juntengma.github.io/2020/11/04/Safe/XSS%E6%94%BB%E5%87%BB/"/>
    <id>https://juntengma.github.io/2020/11/04/Safe/XSS%E6%94%BB%E5%87%BB/</id>
    <published>2020-11-04T07:53:15.118Z</published>
    <updated>2020-11-18T02:36:10.688Z</updated>
    
    <content type="html"><![CDATA[<p>前端知识回顾之 - XSS攻击</p><a id="more"></a><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><h4 id="1-什么是xss攻击"><a href="#1-什么是xss攻击" class="headerlink" title="1.什么是xss攻击"></a>1.什么是xss攻击</h4><ul><li>xss攻击即跨站脚本攻击,是一种恶意代码注入攻击,攻击者通过在网站上面注入恶意代码,使之在浏览器上面运行,从而获取用户的敏感信息如cookie等</li><li>xss的本质是因为网站没有对恶意代码进行过滤, 与正常代码混在一起,但是浏览器不能识别代码哪些可信哪些不可信,从而导致了恶意代码的执行.</li></ul><h4 id="2-XSS攻击分类"><a href="#2-XSS攻击分类" class="headerlink" title="2.XSS攻击分类"></a>2.XSS攻击分类</h4><ul><li><p>存储型</p><blockquote><p>存储型XSS攻击是将恶意代码提交到网站服务器中,当用户请求数据的时候,服务器将恶意代码拼接到HTML里面后返回,导致恶意代码的执行</p></blockquote></li><li><p>反射型</p><blockquote><p>反射型指的是某些通过url参数获取数据的网站,攻击者构建特殊的url,当服务器收到请求之后,从url中获取数据,并将其拼接为html后返回,从而导致了恶意代码的执行</p></blockquote></li><li><p>DOM型</p><blockquote><p>DOM型XSS攻击指的是攻击者构建了特殊的URL,当用户打开了网站之后,js脚本从url中获取数据,从而导致了恶意代码的执行</p></blockquote></li></ul><h4 id="3-如何预防XSS攻击"><a href="#3-如何预防XSS攻击" class="headerlink" title="3.如何预防XSS攻击"></a>3.如何预防XSS攻击</h4><p>​    预防XSS攻击主要有两个方案</p><ul><li><p>恶意代码提交的时候(不可靠)</p><blockquote><p>当数据即将存入数据库的时候进行转义,但是数据库的数据可能在多个地方使用,有些地方不需要转义,由于我们无法判断这些数据最后的使用场景,所以该方法是<strong>不可靠的</strong></p></blockquote></li><li><p>浏览器执行之前</p><blockquote><ul><li>使用纯前端的方式,不用服务器拼接HTML返回    </li><li>对需要插入的HTML进行充分的转义</li></ul></blockquote></li><li><p>对于DOM性XSS攻击还有以下几种方式</p><blockquote><ul><li>CSP,CSP本质是简历一个白名单,告诉浏览器哪些外部资源是可以加载和执行,从而防止恶意代码的注入攻击</li><li>对敏感信息进行保护,比如cookie使用http-only,禁止脚本获取cookie</li><li>使用验证码,防止脚本伪装用户进行操作</li></ul></blockquote></li></ul><h4 id="4-什么是CSP"><a href="#4-什么是CSP" class="headerlink" title="4.什么是CSP"></a>4.什么是CSP</h4><p>​    CSP指的是内容安全侧策略</p><p>​    他的本质是建立一个白名单,告诉浏览器哪些外部资源可以加在和执行.</p><p>​    <strong>开启SCP方式:</strong></p><ul><li>一种是设置 HTTP 首部中的 <code>Content-Security-Policy</code></li><li>一种是设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ul><p>详细资料可以参考： <a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端知识回顾之 - XSS攻击&lt;/p&gt;</summary>
    
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript作用域&amp;可执行上下文</title>
    <link href="https://juntengma.github.io/2020/11/03/JavaScript/03%20-%20JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://juntengma.github.io/2020/11/03/JavaScript/03%20-%20JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2020-11-03T09:42:08.975Z</published>
    <updated>2020-11-16T06:50:05.206Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript深入 - 作用域相关问题</p></blockquote><a id="more"></a><h3 id="01-什么是作用域"><a href="#01-什么是作用域" class="headerlink" title="01 / 什么是作用域?"></a>01 / 什么是作用域?</h3><p><strong>作用域是指程序源代码中定义变量的区域:</strong></p><ul><li>作用域规定了当前执行代码对变量的访问权限</li><li>JavaScript采用词法作用域(静态作用域)</li></ul><h3 id="02-词法作用域和静态作用域的区别"><a href="#02-词法作用域和静态作用域的区别" class="headerlink" title="02 / 词法作用域和静态作用域的区别?"></a>02 / 词法作用域和静态作用域的区别?</h3><ul><li>静态作用域:    函数的作用域在函数定义的时候就已经决定了</li><li>动态作用域: 函数的作用域在函数调用的时候才决定</li></ul><h3 id="03-作用域包含两种"><a href="#03-作用域包含两种" class="headerlink" title="03 / 作用域包含两种:"></a>03 / 作用域包含两种:</h3><ul><li>全局作用域<ul><li>最外层函数和在最外层函数外面定义的变量拥有全局作用域</li><li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li><li>所有 window 对象的属性拥有全局作用域</li></ul></li><li>函数作用域<ul><li>指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到</li></ul></li><li>块级作用域<ul><li>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;JavaScript深入 - 作用域相关问题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="作用域&amp;可执行上下文" scheme="https://juntengma.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://juntengma.github.io/2020/11/02/JavaScript/JavaScript-ES6/"/>
    <id>https://juntengma.github.io/2020/11/02/JavaScript/JavaScript-ES6/</id>
    <published>2020-11-02T08:41:06.847Z</published>
    <updated>2020-11-12T12:33:29.327Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  ES6</h4></blockquote><a id="more"></a><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h4 id="ES6是什么"><a href="#ES6是什么" class="headerlink" title="ES6是什么"></a>ES6是什么</h4><p>es6是ECMA为JavaScript订制的第6个版本,2015年6月发行,涵盖了2015 - 2020</p><h4 id="ES6特性"><a href="#ES6特性" class="headerlink" title="ES6特性"></a>ES6特性</h4><ul><li>表达式<ul><li>[声明 (let/const)](#### 声明)</li><li>解构赋值</li></ul></li><li>内置对象<ul><li>字符串扩展</li><li>数值扩展</li><li>对象扩展</li><li>数组扩展</li><li>函数扩展</li><li>正则扩展</li><li>Symbol / set /Map / Proxy /Reflect</li></ul></li><li>语句与运算<ul><li>class</li><li>Module</li><li>Iterator</li></ul></li><li>异步编程<ul><li>Promise</li><li>Generator</li><li>Async</li></ul></li></ul><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><ul><li>let (声明变量,类似var,但是只在代码块中有效)<ul><li>let声明的变量只在所处于的块级有效；</li><li>let没有‘变量提升’的特性，而是‘暂时性死区（temporal dead zone）’特性</li></ul></li><li>const (声明常量)<ul><li>声明恒定变量，声明的同时就必须赋值，否则会报错</li></ul></li></ul><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域:"></a>块级作用域:</h4><h5 id="ES6之前"><a href="#ES6之前" class="headerlink" title="ES6之前"></a>ES6之前</h5><ul><li>全局作用域</li><li>函数作用域</li></ul><p>因此会产生变量提升的问题</p><pre><code>function func()&#123;    console.log(test);    var test = 1;&#125;;func();//undefind在进入func之前,所有通过var声明的变量提前声明并赋予undefinded值</code></pre><h5 id="ES6-1"><a href="#ES6-1" class="headerlink" title="ES6"></a>ES6</h5><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul><pre><code>function f1() &#123;  let n = 5;  if (true) &#123;    let n = 10;  &#125;  console.log(n); // 5&#125;function f1() &#123;  var n = 5;  if (true) &#123;    var n = 10;  &#125;  console.log(n); // 10&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 ES6
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="https://juntengma.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>for-in &amp; for-of的区别 和 map-for &amp; Each区别</title>
    <link href="https://juntengma.github.io/2020/11/02/JavaScript/forIn-forOF-Map-forEach%E5%8C%BA%E5%88%AB/"/>
    <id>https://juntengma.github.io/2020/11/02/JavaScript/forIn-forOF-Map-forEach%E5%8C%BA%E5%88%AB/</id>
    <published>2020-11-02T07:52:25.395Z</published>
    <updated>2020-11-12T12:32:22.079Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  for-in & for-of的区别 和 map-for & Each区别</h4></blockquote><a id="more"></a><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><ul><li>遍历一个对象的除<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>以外的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举</a>属性, <strong>用于遍历对象</strong></li><li>for…in循环出的是key</li></ul><pre><code>const obj = &#123;    name: &#39;哇塞&#39;,    age: 18&#125;for(let item in obj)&#123;    console.log(item)&#125;// Output://name//age</code></pre><h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><ul><li><strong>用于遍历数组</strong></li><li>for-of 是ES6引入属性</li><li>for-of不能用来遍例普通对象,需要和Obect.keys()搭配使用</li><li>for…of循环出的是value</li></ul><pre><code>let aArray = [&#39;a&#39;,123,&#123;a:&#39;1&#39;,b:&#39;2&#39;&#125;]</code></pre><p>结论:</p><ul><li>推荐在<strong>循环对象</strong>属性的时候，使用<strong>for…in</strong></li><li>在<strong>遍历数组</strong>的时候的时候使用<strong>for…of</strong>。</li><li>for…in循环出的是key，for…of循环出的是value</li><li>注意，for…of是ES6新引入的特性。修复了ES5引入的for…in的不足</li><li>for…of不能循环普通的对象，需要通过和Object.keys()搭配使用</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 for-in &amp; for-of的区别 和 map-for &amp; Each区别
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>深拷贝浅拷贝</title>
    <link href="https://juntengma.github.io/2020/11/02/JavaScript/JavaScript-%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://juntengma.github.io/2020/11/02/JavaScript/JavaScript-%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-11-02T07:28:19.796Z</published>
    <updated>2020-11-12T12:33:18.744Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  深拷贝浅拷贝</h4></blockquote><a id="more"></a><p><a href="https://juejin.im/post/6844903929705136141">https://juejin.im/post/6844903929705136141</a></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。</p><p>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><p>浅拷贝只拷贝一层属性,无法拷贝引用数据类型</p><ul><li><code>Object.assign(&#123;&#125;,obj)</code>浅拷贝object</li><li><code>newobj = &#123;...obj2&#125;</code>  展开运算符浅拷贝</li><li><code>Object.fromEntries( Object.entriens(obj) ) </code>通过生成迭代器,在通过迭代器生成对象</li><li><code>Object.create(&#123;&#125;,Object.getOwnPropertyDescriptors(obj))</code></li></ul><p><strong>简单浅拷贝:</strong></p><pre><code>function clone(target)&#123;    let cloneTarget=&#123;&#125;;    for(let key in target)&#123;        cloneTarget[key] = target[key]    &#125;    return cloneTarget&#125;</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><ul><li><code>JSON.parse(JSON.stringfy( obj ))</code>通过<strong>JSON的2次转换深拷贝obj</strong><ul><li>无法拷贝<code>undefined</code>与<code>symbol</code>属性</li><li>无法拷贝<strong>循环引用</strong>对象</li></ul></li><li>loadsh:<a href="http://lodash.think2011.net/cloneDeep"><em>.cloneDeep</em></a></li></ul><p>简单深拷贝(可以处理<strong>原始数据类型 + Object</strong>):</p><ul><li>如果是原始类型，无需继续拷贝，直接返回</li><li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行深拷贝后依次添加到新对象上。</li></ul><pre><code>function smpleDeepCopy(target) &#123;  let type = typeof target  if (type === &quot;object&quot;) &#123;    let copy = &#123;&#125;;    for (let key in target) &#123;      copy[key] = smpleDeepCopy(target[key])    &#125;    return copy  &#125;  return target&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 深拷贝浅拷贝
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="深拷贝浅拷贝" scheme="https://juntengma.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础知识综合</title>
    <link href="https://juntengma.github.io/2020/11/01/JavaScript/01%20-%20JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://juntengma.github.io/2020/11/01/JavaScript/01%20-%20JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-11-01T00:00:00.000Z</published>
    <updated>2020-11-23T06:42:39.267Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4> 整理一些js基础知识点和总结...</h4></blockquote><p>[TOC]</p><a id="more"></a><h4 id="01-JS数据类型-6-1"><a href="#01-JS数据类型-6-1" class="headerlink" title="01 / JS数据类型(6+1)"></a>01 / JS数据类型(6+1)</h4><ul><li><p><strong>基本数据类型:</strong></p><pre><code>- null- undefined- number- string- boolean- symbol:代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。</code></pre></li><li><p><strong>引用数据类型:</strong></p><p>引用数据类型指的是object类型,其他如Array,Date等数据类型都可以理解为Object的子类</p><pre><code>object =  [   Array,   Date,   Math,   ...]</code></pre></li><li><p><strong>基本数据类型和引用数据类型区别:</strong></p><ul><li>基本数据类型在内存中占固定大小的空间,因此被保存在栈中</li><li>引用类型值是对象，保存在 <strong>堆内存</strong> 中。包含引用类型值的变量实际包含并非对象本身，而是指向该对象的指针。一个变量从另一个变量复制引用类型的值时，复制的也是指向该对象的指针。</li></ul></li></ul><h4 id="02-什么是堆-栈"><a href="#02-什么是堆-栈" class="headerlink" title="02 / 什么是堆/栈?"></a>02 / 什么是堆/栈?</h4><pre><code>堆栈概念存在于数据结构和操作系统内存中- 在数据结构中:  - 栈中的数据存取方式为先进后出  - 堆是一个优先队列,按照优先级来进行排序的,优先级可以按照大小来规定- 操作系统中 ,内存被分为栈区和堆区:  - 栈区的内存由编译器自动分配释放,存放函数的参数值,局部变量值等    - 堆内存一般由程序员释放,若没有手动释放则程序结束时由垃圾回收机制回收</code></pre><h4 id="03-什么是JavaSctipt垃圾回收机制"><a href="#03-什么是JavaSctipt垃圾回收机制" class="headerlink" title="03 / 什么是JavaSctipt垃圾回收机制?"></a>03 / 什么是JavaSctipt垃圾回收机制?</h4><ul><li><p><strong>为什么要垃圾回收?</strong></p><pre><code class="html">随着前端业务需求的不断增多，相比以前，我们会占用更多的内存。但是内存并不是无限的，我们需要垃圾回收机制去处理那些我们不再需要的变量、对象 </code></pre></li><li><p><strong>垃圾回收机制的特点:</strong></p><p>垃圾回收机制会定期对那些我们不再使用的变量、对象所占用的内存释放     </p><pre><code>原理:    + 找出那些不再使用的变量，然后释放其占用的内存。    + 垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。</code></pre></li><li><p><strong>垃圾回收的方式有哪些?</strong></p><ul><li><p>标记清除</p><ul><li><p>当变量进入环境时,就将其标记为”进入环境”,此时”进入环境”的变量是不可以被回收的”</p></li><li><p>当变量离开环境时,就将其标记为”离开环境”,此时”离开环境”的变量可以被回收</p><pre><code>function func () &#123;      const a = 1    const b = 2      // 函数执行时，a b 分别被标记 进入环境&#125;func() // 函数执行结束，a b 被标记 离开环境，被回收</code></pre></li></ul></li><li><p>引用计数</p><ul><li><p>统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收</p><pre><code>function func1 () &#123;      const c = &#123;&#125; // 引用类型变量 c的引用计数为 0      let d = c // c 被 d 引用 c的引用计数为 1      let e = c // c 被 e 引用 c的引用计数为 2      d = &#123;&#125; // d 不再引用c c的引用计数减为 1      e = null // e 不再引用 c c的引用计数减为 0 将被回收&#125;</code></pre></li><li><p>但是引用计数的方式，有一个相对明显的缺点——<strong>循环引用</strong></p><pre><code>function func5 () &#123;      let f = &#123;&#125;      let g = &#123;&#125;      f.prop = g      g.prop = f      // 由于 f 和 g 互相引用，计数永远不可能为 0&#125;</code></pre></li><li><p>像上面这种情况就需要<strong>手动将变量的内存释放</strong></p><pre><code>f.prop = nullg.prop = null</code></pre></li></ul></li></ul></li></ul><p>参考:<br>    <a href="https://juejin.im/post/6844903652331618312">&lt;&lt;javascript 垃圾回收机制&gt;&gt;</a><br>    <a href="https://juejin.im/post/6844903858972409869#heading-3">&lt;&lt;JavaScript 垃圾回收机制&gt;&gt;</a></p><h4 id="04-什么是循环引用"><a href="#04-什么是循环引用" class="headerlink" title="04 / 什么是循环引用 ?"></a>04 / 什么是循环引用 ?</h4><p>当对象 1 中的某个属性指向对象 2，对象 2 中的某个属性指向对象 1 就会出现循环引用(最简单的例子)</p><pre><code>  function circularReference() &#123;      let obj1 = &#123; &#125;;      let obj2 = &#123; &#125;;      obj1.a = obj2;      obj2.b = obj1;  &#125;</code></pre><h4 id="05-内存泄露"><a href="#05-内存泄露" class="headerlink" title="05 / 内存泄露"></a>05 / 内存泄露</h4><ul><li><p>什么是内存泄露?</p><pre><code>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</code></pre></li><li><p>常见的内存泄露有哪些?</p><ul><li><p>全局变量(在非严格模式下当引用未声明的变量时，会在全局对象中创建一个新变量。)</p></li><li><p>被遗忘的定时器和回调函数</p></li><li><p>DOM引用</p></li><li><p>闭包</p></li></ul></li></ul><h4 id="06-JavaScript可执行上下文"><a href="#06-JavaScript可执行上下文" class="headerlink" title="06 /  JavaScript可执行上下文"></a>06 /  JavaScript可执行上下文</h4><p><a href="/2020/11/03/JavaScript/03%20-%20JavaScript-作用域&可执行上下文/" target="_blank">&lt;&lt;JavaScript可执行上下文&gt;&gt;</a></p><h4 id="07-JavaScript在浏览器中如何执行的"><a href="#07-JavaScript在浏览器中如何执行的" class="headerlink" title="07 /  JavaScript在浏览器中如何执行的"></a>07 /  JavaScript在浏览器中如何执行的</h4><p><a href="/2020/09/22/JavaScript/04%20-%20JavaScript-一段js代码在浏览器中是如何执行的/" target="_blank">&lt;&lt;JavaScript在浏览器中如何执行的&gt;&gt;</a></p><h4 id="08-从输入url到页面加载过程"><a href="#08-从输入url到页面加载过程" class="headerlink" title="08 /  从输入url到页面加载过程"></a>08 /  从输入url到页面加载过程</h4><p><a href="/2020/10/26/JavaScript/06%20-%20从输入url到页面加载过程/" target="_blank">&lt;&lt;从输入url到页面加载过程&gt;&gt;</a></p><h4 id="09-内部属性-class-是什么"><a href="#09-内部属性-class-是什么" class="headerlink" title="09 / 内部属性[[class]]是什么"></a>09 / 内部属性[[class]]是什么</h4><p>所有<code>typeof</code>返回值为 <code>object</code> 的对象（如数组）都包含一个内部属性 [[Class]],这个属性无法直接访问，一般通过以下代码查看</p><pre><code>Object.prototype.toString.call(Array)  //&quot;[object Function]&quot;</code></pre><h4 id="10-Js内置对象都有哪些"><a href="#10-Js内置对象都有哪些" class="headerlink" title="10 / Js内置对象都有哪些"></a>10 / Js内置对象都有哪些</h4><pre><code>js内置对象主要是只在程序执行前存在全局作用域里面的由js定义的一些全局属性,函数和用来实例化其他对象的构造函数对象.一般我们经常用到的全局函数变量值: NaN , undefined ,全局函数: parseInt() , paeseFloat()用来实例化的全局构造函数: Date , Object 等</code></pre><h4 id="11-原型原型链"><a href="#11-原型原型链" class="headerlink" title="11 / 原型原型链"></a>11 / 原型原型链</h4><pre><code>01/ 原型:-    Js中我们使用构造函数来新建对象的-    每个构造函数内部都有一个prototype属性,这个属性值是一个对象,包含了可以由该构造函数共享的实例和方法- 我们使用构造函数新建一个对象后,这个对象内部有一个`__proto__`指针,可以指向构造函数prototype属性对应的值,es5中我们一般称他为对象的原型 浏览器可以通过`__proto__`值来获取,也可以用Object.getPrototypeOf()找到对象的原型02/ 原型链:- 当我们访问一个对象的属性时,如果这个对象里面不存在该属性的时候,那么就会到这个对象的原型对象中找这个属性,就这样一层层的找就构成了原型链,最后找到Object.proptotype,如果还没找到就会返回null.03/ 获取原型的办法:- `p.__proto__`- `p.constructor.prototype`- `Object.getPrototypeOf(p)`04/ 原型可以做什么?- 实现继承- 共享我们的一些实例和方法</code></pre><p><a href="">&lt;&lt;JavaScript原型原型链&gt;&gt;</a></p><h4 id="12-闭包"><a href="#12-闭包" class="headerlink" title="12 / 闭包"></a>12 / 闭包</h4><pre><code>闭包是指内部函数可以访问其所在的外部函数中声明的参数和变量;创建闭包最常用的方法是在一个函数内创建另外一个函数,创建的函数可以访问父级函数的局部变量;闭包主要有两个用途:1/ 使我们可以在函数外部访问到函数内部的变量,通过这个方法,我们可以在函数外部调用闭包函数,在函数外部访问到函数内部变量2/ 使已经运行过的函数上下文的变量对象继续保存在内存中,不被垃圾回收机制释放内存,但是操作不当可能会造成内存泄露</code></pre><h4 id="13-继承"><a href="#13-继承" class="headerlink" title="13 / 继承"></a>13 / 继承</h4><pre><code>继承实现方式:- 原型链继承- 构造函数继承- 组合继承(原型链+构造函数继承)- 原型式继承- 寄生式继承- 寄生组合式继承</code></pre><p><a href="https://github.com/mqyqingfeng/Blog/issues/16">&lt;&lt;JavaScript深入之继承的多种方式和优缺点&gt;&gt;</a></p><h4 id="14-什么是-pure-function"><a href="#14-什么是-pure-function" class="headerlink" title="14 / 什么是 pure function"></a>14 / 什么是 pure function</h4><p>如果一个函数没有任何副作用（side-effects)，不会影响任何外部状态，对于任何一个相同的输入（参数），无论何时调用这个函数总是返回同样的结果，这个函数就是一个 pure function。</p><h4 id="15-重绘回流"><a href="#15-重绘回流" class="headerlink" title="15 / 重绘回流"></a>15 / 重绘回流</h4><p><strong>01/ 前置知识:</strong></p><ol><li><p>浏览器使用流式布局模型 (Flow Based Layout)。</p></li><li><p>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了<code>Render Tree</code>。</p></li><li><p>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</p></li><li><p>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一。 </p></li></ol><p><strong>02/ 什么是回流:</strong></p><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p><p><strong>02.1/ 会导致回流的操作：</strong></p><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li><li>激活<code>CSS</code>伪类（例如：<code>:hover</code>）</li><li>查询某些属性或调用某些方法</li></ul><p><strong>02.2/ 一些常用且会导致回流的属性和方法：</strong></p><ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li><li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li><li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li><li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li><li><code>scrollTo()</code></li></ul><p><strong>03/ 什么是重绘:</strong></p><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><ul><li><strong>回流比重绘的代价要更高。</strong></li><li>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</li></ul><p><strong>03.1/ 现代浏览器会对频繁的回流或重绘操作进行优化：</strong></p><ul><li><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p></li><li><p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p><pre><code>- clientWidth、clientHeight、clientTop、clientLeft</code></pre></li></ul><ul><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li></ul><ul><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li></ul><ul><li>width、height</li></ul><ul><li>getComputedStyle()</li></ul><ul><li>getBoundingClientRect()<pre><code></code></pre></li></ul><p><strong>04/ 如何避免回流重绘?</strong></p><ul><li><p>CSS</p><ul><li>避免使用<code>table</code>布局。</li><li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li><li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li></ul></li><li><p>JavaScript</p><ul><li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li><li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li><li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul></li></ul><p><strong>05 /总结:</strong></p><p> <strong>回流必将引起重绘，重绘不一定会引起回流。</strong></p><p>参考:<a href="https://juejin.im/post/6844903569087266823">&lt;&lt;浏览器的回流与重绘 (Reflow &amp; Repaint)&gt;&gt;</a></p><h4 id="16-http缓存"><a href="#16-http缓存" class="headerlink" title="16 / http缓存"></a>16 / http缓存</h4><p>http缓存按我自己的理解:</p><blockquote><p>我更愿意叫做浏览器缓存,缓存主要发生在浏览器端,而http起到的作用是告诉浏览器是否使用缓存资源,是否进行缓存…</p></blockquote><p>01/ 为什么要缓存呢?</p><blockquote><p>用于性能提升,减少延迟,提高网页加载速度;同时,由于缓存文件可以重复利用,还可以减少带宽,降低网络负荷</p></blockquote><p>02/ 浏览器怎么才能缓存?</p><blockquote><p>http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。<br>可以控制浏览器是否使用缓存、缓存多久</p></blockquote><p>03/ 那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：</p><p><img src="https://s3.ax1x.com/2020/11/12/BzalAP.png"></p><p>第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分size有具体数值，然而还有一部分请求，比如图片、css和js等文件并没有显示文件大小，而是显示了 from dis cache 或者 from memory cache 字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。</p><p>04/ 浏览器缓存方式?<br>浏览器缓存分为两种:</p><ul><li>强制缓存</li><li>协商缓存</li></ul><p>05/ 浏览器缓存机制</p><blockquote><p>1\ 浏览器加载资源的时候,先根据资源的http header判断他是否命中强缓存,</p><pre><code>-    如果命中,浏览器就先从自己的缓存(先从内存中找,找不到再去磁盘中找)中读取资源,不会发送请求到服务器</code></pre><p>2\ 没有命中的时候,浏览器会发送一个请求给服务器,通过服务器端的另外的一些http header来验证这个资源是否命中协商缓存</p><ul><li>如果命中协商缓存,服务器会将这个请求返回,但是不会返回这个请求的数据,而是告诉客户端可以直接从缓存中加载资源,然后浏览器重新去缓存中读取数据</li></ul><p>3\强缓存和协商缓存相同点:</p><ul><li>命中都是从浏览器缓存中加载资源</li></ul><p>4\不同点</p><ul><li>强缓存不发请求到服务器</li><li>协商缓存会发请求给服务器</li></ul><p>05\协商缓存也没有命中的时候,浏览器直接去服务器获取数据</p></blockquote><p>06/ 判断缓存机制</p><p><img src="https://s3.ax1x.com/2020/11/12/BzB1bj.png"></p><p>参考:</p><ul><li><a href="https://juejin.im/post/6844903672556552205#heading-2">&lt;&lt;前端优化：浏览器缓存技术介绍&gt;&gt;</a></li><li><a href="https://juejin.im/post/6844903838768431118#heading-0">&lt;&lt;http面试必会的：强制缓存和协商缓存&gt;&gt;</a></li></ul><h4 id="17-SSR-BSR区别"><a href="#17-SSR-BSR区别" class="headerlink" title="17 / SSR/BSR区别"></a>17 / SSR/BSR区别</h4><ul><li><p>SSR:服务端渲染</p><p>对营销推广的要求比较高的产品,比如官网等</p><pre><code>- M+V发生在服务端,服务器压力较大- 页面访问和显示速度更快(DOM比较少)- 有利于SEO搜索引擎优化- 前后端不分离,后端开发压力大- 功能不能过于复杂,多用于功能交互都比较简单的产品</code></pre></li><li><p>BSR:客户端渲染</p><p>对营销推广要求没有那么搞的产品,例如后台管理系统</p><pre><code>- M+v过程发生在浏览器,浏览器压力较大- 页面访问和加载速度没有服务端渲染快- 不利于SEO优化- 前后端分离,便于代码调试和维护- 可以做更加复杂的产品</code></pre></li></ul><h4 id="18-SEO优化"><a href="#18-SEO优化" class="headerlink" title="18 / SEO优化"></a>18 / SEO优化</h4><p>………………</p><h4 id="19-MVC"><a href="#19-MVC" class="headerlink" title="19 / MVC"></a>19 / MVC</h4><p>MVC模式的意思是，软件可以分成三个部分。即Model模型、View视图、Controller控件器。</p><blockquote><ul><li><p>View：视图，为用户提供使用界面，与用户直接进行交互。</p></li><li><p>Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载Bean，一类称为业务处理Bean。所谓数据承载Bean是指实体类，专门承载业务数据的，如Student、User等。而业务处理Bean则是指Service或Dao对象，专门用于处理用户提交请求的。</p></li><li><p>Controller：控制器，用于将用户请求转发给相应的Model进行处理，并处理Model的计算结果向用户提供相应响应。</p></li></ul></blockquote><p>MVC架构程序的工作流程是这样的：</p><p><img src="https://s3.ax1x.com/2020/11/16/DAKqrd.png"></p><blockquote><p>（1）用户通过View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX请求等。</p><p>（2）服务端Controller控制器接收到请求后对请求进行解析，找到相应 的Model对用户请求进行处理。</p><p>（3）Model处理后，将处理结果再交给Controller。</p><p>（4）Controller在接到处理结果后，根据处理结果找到要作为向客户端发回的响应View页面。页面经渲染（数据填充）后，再发送给客户端。</p></blockquote><p>实际项目往往采用更灵活的方式</p><p><img src="https://s3.ax1x.com/2020/11/16/DAMGIx.png"></p><blockquote><p>\1. 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</p><p>\2. 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</p><p>\3. Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。</p></blockquote><p>参考: </p><p><a href="https://juejin.im/post/6844903479568252935">&lt;&lt;MVC 与三层架构&gt;&gt;</a></p><p><a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">&lt;&lt;MVC，MVP 和 MVVM 的图示&gt;&gt;</a></p><h4 id="20-MVVM"><a href="#20-MVVM" class="headerlink" title="20 / MVVM"></a>20 / MVVM</h4><p><img src="https://s3.ax1x.com/2020/11/16/DAYfZF.png"></p><pre><code>1. 各部分之间的通信，都是双向的。2. View 与 Model 不发生联系，都通过 ViewModule 传递。3. View 非常薄，不部署任何业务逻辑，称为&quot;被动视图&quot;（Passive View），即没有任何主动性，而 ViewModule非常厚，所有逻辑都部署在那里。4. 它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然</code></pre><h4 id="21-SPA单页应用-amp-多页应用"><a href="#21-SPA单页应用-amp-多页应用" class="headerlink" title="21/ SPA单页应用 &amp; 多页应用"></a>21/ SPA单页应用 &amp; 多页应用</h4><p><a href="https://www.jianshu.com/p/a02eb15d2d70">&lt;&lt;&gt;&gt;</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
整理一些js基础知识点和总结...
&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Https及其加密原理</title>
    <link href="https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https/"/>
    <id>https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https/</id>
    <published>2020-10-30T08:59:24.175Z</published>
    <updated>2020-11-10T04:06:07.552Z</updated>
    
    <content type="html"><![CDATA[<p>Https协议及其加密原理</p><a id="more"></a><h2 id="1-http-协议存在的一些问题"><a href="#1-http-协议存在的一些问题" class="headerlink" title="1/http 协议存在的一些问题"></a>1/http 协议存在的一些问题</h2><ul><li>http报文明文发送,可能会被第三方窃听</li><li>http报文可能会被第三方截取之后修改通信内容,接收方没有办法发现报文内容的修改</li><li>http还存在认证问题,第三方可以冒充他人参与通信</li></ul><h2 id="2-Https简介"><a href="#2-Https简介" class="headerlink" title="2/Https简介"></a>2/Https简介</h2><ul><li>HTTPS指的是超文本传输安全协议,HTTPS是基于HTTTP协议的,不过它会使用TLS/SSL来对数据进行加密,即Http+TLS/SSL</li><li>使用TLS和SSL协议,所有的信息都是加密的,第三方没有办法窃听,并且他提供了一种校验机制,信息一旦被篡改,通信双方立刻就会发现</li><li>它还配备了身份证书,防止身份被冒充的情况出现</li></ul><h2 id="3-SSL加密方式"><a href="#3-SSL加密方式" class="headerlink" title="3/SSL加密方式"></a>3/SSL加密方式</h2><ul><li><p>对称加密</p><p><img src="https://s1.ax1x.com/2020/11/10/Bqe2dS.png"></p><pre><code>对称加密即客户端和服务端同时约定同一种秘钥,客户端发送信息给服务端使用该秘钥加密,服务端收到信息后在用秘钥解密,整个流程类似下面这个例子:期末考试,小明找小红希望数学考试的时候小红可以帮他,两个人考试前约定了一把秘钥:小红把所有的答案都加上250;小红把答案通过秘钥加密: 15 + 250 = 265 --&gt; 偷偷的丢给小明小明通过秘钥解密: 265- 250 = 15 ---&gt; 小明得到正确答案</code></pre><ul><li>对称加密加密效率高速度快</li><li>但是该加密方式存在一些漏洞,假如别人获取到了加密方式,然后再用该方案来解密,那数据信息岂不是还是可以被截取修改,因此出现了非对称加密的方案</li></ul></li><li><p>非对称加密</p><p>非对称加密就是有两把密钥，公钥和私钥。私钥自己藏着，不告诉任何人；而公钥可以公开给别人。</p><p><img src="https://s1.ax1x.com/2020/11/10/Bqe7LV.png"></p><pre><code>非对称加密即通信双方各自有一个秘钥和公钥,公钥用来对信息进行加密,私钥用来对信息进行解密;通信的时候, 公钥是随着信息一起发送给对方的,即公钥是公开的, 但是私钥是不会公开的假如A发送信息给B:- A把自己发送的信息连同公钥(加密方式)一起发送给B,- B方收到信息和公钥的时候,把返回的信息通过A的公钥对信息进行加密- 返回信息给A的同时把自己的公钥和密文一起发送给A- A收到B的加密信息之后,再通过自己的私钥对信息进行解密,如果还需要和B进行通信,再用B的公钥加密即可</code></pre><ul><li>非对称加密相对于对称加密安全度是高了一点,但是如果拦截方把数据拦截下来,将自己的数据用拦截下来的公钥加密后返回给发送方,放松方并不能识别出来是不是目标通信对象发来的信息,因此还需要<strong>数字签名</strong>来作保障</li></ul></li></ul><h2 id="4-数字签名"><a href="#4-数字签名" class="headerlink" title="4/数字签名"></a>4/数字签名</h2><p>数字签名是附加在报文上面的特殊加密校验码.可以防止报文被篡改,如果恶意攻击在传输过程中篡改了报文,那么校验的时候就不再匹配,因此可以确认报文被篡改;</p><p><strong>数字签名加密过程:</strong></p><ul><li>发送端将报文通过算法（比如通过HASH函数）提取为定长的摘要；</li><li>发送端将摘要应用签名算法，以私有密钥作为参数生成一个签名；</li><li>计算得出签名后，将签名附加在报文末端发送给接收方；</li><li>接收端收到报文后，对签名进行检查。接收端通过公开密钥解码签名。然后比对报文生成的摘要是否与签名一致便可判断报文是否被篡改。</li></ul><p><strong>数字证书:</strong></p><p>数字证书是由权威机构给某网站颁发的一种认可凭证。它主要包含一些认证信息，比如：对象的名称（服务器、组织、个人等）、过期时间、证书颁发者、来自证书发布者的数字签名。</p><p><img src="https://s1.ax1x.com/2020/11/10/BqM3Bq.png"></p><p>上面的图片就是<a href="http://www.google.com的证书./">www.google.com的证书。</a></p><p>我们可以看到在上面讲到数字签名的时候，似乎就可以保证报文的安全了。为什么还需要数字证书呢？这个设想一下这个场景：比如某人A把发送到浏览器的公有密钥进行了替换，同时A在给浏览器发送报文时使用自己的私有密钥对报文进行数字签名，那么浏览器就不能确认报文是否来自于真实服务器。这个时候就可以使用数字证书进行验证，因为数字证书中保存了真实服务器的信息。</p><h2 id="5-HTTPS的工作流程"><a href="#5-HTTPS的工作流程" class="headerlink" title="5/HTTPS的工作流程"></a>5/HTTPS的工作流程</h2><p><strong>建立安全传输</strong><br>在TCP连接建立完成以后，在HTTPS协议中，客户端和服务端会初始化SSL层，也就是安全层。</p><p><strong>SSL握手</strong><br>在发送报文之前，客户端和服务端会进行一次SSL握手，在这个过程中主要完成以下工作：</p><ul><li><p>交换协议版本号；</p></li><li><p>选择一个两端都了解的密码；</p></li><li><p>对两端的身份进行认证；</p></li><li><p>生成临时会话密钥，以便加密信道（建立完安全通道后，传输报文时使用对称加密）；</p></li></ul><p>在SSL会进行很多工作，处理交换一些必要的信息之外，还会对身份进行认证。</p><p>这里的认证是通过数字证书进行的，在客户端获取证书后，会采用相应的算法对服务端的身份信息进行验证：</p><ul><li><p>日期检测：客户端会检查证书的有效期是否合法；</p></li><li><p>签名颁布者可信度检测：浏览器会附带一个签名颁发机构的授信列表，如果浏览器收到了位置的颁发机构签发的证书，那么它会显示一条警告信息；</p></li><li><p>签名检测：客户端对签名使用签名颁发机构的公开密钥，然后将其与校验码比较，以便验证证书是否合法；</p></li><li><p>站点身份检测：客户端验证数字证书中的域名是否与服务端的域名匹配；</p></li></ul><p>身份认证完成后，客户端与服务端进行密码协商，确定本次连接采用哪种加密算法进行通信。</p><p><strong>开始通信</strong><br>SSL握手完成后，就完成建立了HTTPS通道，客户端与服务端就会根据协商的加密算法进行通信。</p><p>整个HTTPS的工作流程可以总结如下：</p><p><img src="https://s1.ax1x.com/2020/11/10/BqM7Uf.png"></p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6/总结"></a>6/总结</h2><p>相较于HTTP协议，HTTPS确保了报文的机密性以及完整性。HTTPS确保这些的依赖就是SSL/TSL协议，SSL/TSL安全协议搭配数字证书保证了报文在传输过程中的绝对安全。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Https协议及其加密原理&lt;/p&gt;</summary>
    
    
    
    <category term="Http&amp;Https" scheme="https://juntengma.github.io/categories/Http-Https/"/>
    
    
    <category term="Https" scheme="https://juntengma.github.io/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>Http</title>
    <link href="https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%99%A8%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%99%A8%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81/</id>
    <published>2020-10-30T08:49:32.136Z</published>
    <updated>2020-11-10T04:06:05.285Z</updated>
    
    <content type="html"><![CDATA[<p>HTTPS的一些知识</p><a id="more"></a><h3 id="1-什么是HTTP协议"><a href="#1-什么是HTTP协议" class="headerlink" title="1/什么是HTTP协议"></a>1/什么是HTTP协议</h3><ul><li>HTTP协议是超文本传输协议的简称,规定了服务端和客户端(前后端)通信方式以及占用的接口</li><li>HTTP协议是一个局域TCP/IP通信协议来传输数据的</li></ul><h3 id="2-HTTP协议的特性"><a href="#2-HTTP协议的特性" class="headerlink" title="2/HTTP协议的特性"></a>2/HTTP协议的特性</h3><ul><li>HTTP协议支持客户端/服务端模式,也是一种请求/响应模式的协议</li><li>简单快速,客户端向服务器请求服务时,只需要提供请求方法和URL.常用的有 GET,PSOT,DELETE,HEAD等</li><li>无连接:HTTP协议规定浏览器和服务端只能保持短暂的链接,浏览器的每次请求都需要与服务器建立一个TCP链接,服务器处理完成后立即断开TCP链接</li><li>无状态:无状态是指服务器不跟踪也不记录请求过的状态,后续如果需要前面的信息,必须重传.</li><li>但是可以借助cookie和session记住来做身份认证和状态记录</li></ul><h3 id="3-HTTP报文组成"><a href="#3-HTTP报文组成" class="headerlink" title="3/HTTP报文组成"></a>3/HTTP报文组成</h3><h4 id="请求报问"><a href="#请求报问" class="headerlink" title="请求报问"></a>请求报问</h4><ul><li>请求行</li><li>请求头(Request Header)</li><li>请求正文</li></ul><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><ul><li>状态行</li><li>响应头(Response Header)</li><li>响应正文</li></ul><h3 id="4-常见请求方法"><a href="#4-常见请求方法" class="headerlink" title="4/常见请求方法"></a>4/常见请求方法</h3><ul><li>GET</li><li>HEAD:类似GET请求,但是返回的响应中没有具体内容,用于获取报头</li><li>POST</li><li>PUT:从客户端向服务器传送的数据取代指定的文档的内容</li><li>DELETE:请求服务器删除指定页面</li></ul><h3 id="5-响应状态码"><a href="#5-响应状态码" class="headerlink" title="5/响应状态码"></a>5/响应状态码</h3><p>状态码分类：</p><ul><li>1XX- 信息型，服务器收到请求，需要请求者继续操作。</li><li>2XX- 成功型，请求成功收到，理解并处理。</li><li>3XX - 重定向，需要进一步的操作以完成请求。</li><li>4XX - 客户端错误，请求包含语法错误或无法完成请求。</li><li>5XX - 服务器错误，服务器在处理请求的过程中发生了错误。</li></ul><h3 id="6-常见状态码"><a href="#6-常见状态码" class="headerlink" title="6/常见状态码"></a>6/常见状态码</h3><ul><li>200:请求成功</li><li>204:无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>301:永久重定向，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302:临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>304:未修改。所请求的资源未修改，服务器不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>400:客户端请求的语法错误，服务器无法理解</li><li>401:请求要求用户的身份认证</li><li>403:服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404:服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>422:请求格式正确，但是由于含有语义错误，无法响应。</li><li>500:服务器内部错误，无法完成请求</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;HTTPS的一些知识&lt;/p&gt;</summary>
    
    
    
    <category term="Http&amp;Https" scheme="https://juntengma.github.io/categories/Http-Https/"/>
    
    
    <category term="Http" scheme="https://juntengma.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://juntengma.github.io/2020/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95/"/>
    <id>https://juntengma.github.io/2020/10/30/%E7%AE%97%E6%B3%95%E9%A2%98/%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-30T03:39:39.217Z</published>
    <updated>2020-11-12T12:34:09.334Z</updated>
    
    <content type="html"><![CDATA[<p>复习做的几个算法练习题/…</p><a id="more"></a><p>一、不借助临时变量，进行两个整数的交换</p><pre><code>let a = 1, b = 2;[a, b] = [b, a]console.log(a, b);</code></pre><p>二、字符串查找：请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。<br>🌰:</p><pre><code>a=&#39;34&#39;;b=&#39;1234567&#39;; // 返回 2a=&#39;35&#39;;b=&#39;1234567&#39;; // 返回 -1a=&#39;355&#39;;b=&#39;12354355&#39;; // 返回 5isContain(a,b);</code></pre><p>三、统计一个字符串出现最多的字母：给出一段英文连续的英文字符窜，找出重复出现次数最多的字母。<br>🌰:</p><pre><code>输入 ： afjghdfraaaasdenas输出 ： a</code></pre><pre><code>function hasMost(str) &#123;  let counts = &#123;&#125;  for (let item of str) &#123;    counts[`$&#123;item&#125;`] = 0    for (let j of str) &#123;      if (j === item) &#123;        counts[`$&#123;item&#125;`] = counts[`$&#123;item&#125;`] + 1;      &#125;    &#125;  &#125;  getMax(counts)&#125;function getMax(counts) &#123;  let maxValue = 0  let maxItem = &#39;&#39;  for (let item in counts) &#123;    if (counts[item] &gt; maxValue) &#123;      maxValue = counts[item]      maxItem = item    &#125;  &#125;  console.log(maxItem, maxValue)&#125;</code></pre><p>四、找出下列正数组的最大差值<br>🌰:</p><pre><code>输入 [10,5,11,7,8,9]输出 6</code></pre><pre><code>function getDifferenceValue(arr) &#123;  let maxNum = null, minNum = null  arr.forEach(item =&gt; &#123;    !maxNum ? maxNum = item : !minNum ? minNum = item : null    item &gt; maxNum      ? maxNum = item      : item &lt; minNum        ? minNum = item        : minNum  &#125;)  console.log(maxNum, minNum)  console.log(maxNum - minNum)&#125;</code></pre><p>五、斐波那契数列：1、1、2、3、5、8、13、21。输入n，输出数列中第n位数的值。<br>🌰:</p><pre><code>function getValue(num) &#123;  if (num &lt; 2) &#123;    return 1  &#125; else &#123;    return (getValue(num - 1) + getValue(num - 2))  &#125;&#125;</code></pre><p>六、用js实现二分查找：二分查找的前提是有序数组</p><pre><code>🌰:将要查找的值每次与中间值比较，大于中间值，则在右边进行相同的查找，小于中间值则在左边进行比较查找，找到返回索引值，没找到返回-1。</code></pre><p>var missingNumber = function (nums) {<br>  let left = 0, right = nums.length - 1;<br>  while (left &lt;= right) {<br>    let mid = Math.floor((left + right) / 2);<br>    if (mid === nums[mid]) {<br>      left = mid + 1;<br>    } else if (mid &lt; nums[mid]) {<br>      right = mid - 1;<br>    }<br>  }<br>  return left;<br>};</p><p>```<br>七、数组去重</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习做的几个算法练习题/…&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://juntengma.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://juntengma.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
