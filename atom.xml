<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>June&#39;s Blog</title>
  
  
  <link href="https://juntengma.github.io/atom.xml" rel="self"/>
  
  <link href="https://juntengma.github.io/"/>
  <updated>2020-11-04T08:23:27.164Z</updated>
  <id>https://juntengma.github.io/</id>
  
  <author>
    <name>June</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://juntengma.github.io/2020/11/04/Safe/CSRF%E6%94%BB%E5%87%BB/"/>
    <id>https://juntengma.github.io/2020/11/04/Safe/CSRF%E6%94%BB%E5%87%BB/</id>
    <published>2020-11-04T07:53:26.651Z</published>
    <updated>2020-11-04T08:23:27.164Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>XSS攻击</title>
    <link href="https://juntengma.github.io/2020/11/04/Safe/XSS%E6%94%BB%E5%87%BB/"/>
    <id>https://juntengma.github.io/2020/11/04/Safe/XSS%E6%94%BB%E5%87%BB/</id>
    <published>2020-11-04T07:53:15.118Z</published>
    <updated>2020-11-04T09:48:21.387Z</updated>
    
    <content type="html"><![CDATA[<p>前端知识回顾之 - XSS攻击</p><a id="more"></a><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><h4 id="1-什么是xss攻击"><a href="#1-什么是xss攻击" class="headerlink" title="1.什么是xss攻击"></a>1.什么是xss攻击</h4><ul><li>xss攻击即跨站脚本攻击,是一种恶意代码注入攻击,攻击者通过在网站上面注入恶意代码,使之在浏览器上面运行,从而获取用户的敏感信息如cookie等</li><li>xss的本质是因为网站没有对恶意代码进行过滤, 与正常代码混在一起,但是浏览器不能识别代码哪些可信哪些不可信,从而导致了恶意代码的执行.</li></ul><h4 id="2-XSS攻击分类"><a href="#2-XSS攻击分类" class="headerlink" title="2.XSS攻击分类"></a>2.XSS攻击分类</h4><ul><li><p>存储型</p><blockquote><p>存储型XSS攻击是将恶意代码提交到网站服务器中,当用户请求数据的时候,服务器将恶意代码拼接到HTML里面后返回,导致恶意代码的执行</p></blockquote></li><li><p>反射型</p><blockquote><p>反射型指的是某些通过url参数获取数据的网站,攻击者构建特殊的url,当服务器收到请求之后,从url中获取数据,并将其拼接为html后返回,从而导致了恶意代码的执行</p></blockquote></li><li><p>DOM型</p><blockquote><p>DOM型XSS攻击指的是攻击者构建了特殊的URL,当用户打开了网站之后,js脚本从url中获取数据,从而导致了恶意代码的执行</p></blockquote></li></ul><h4 id="3-如何预防XSS攻击"><a href="#3-如何预防XSS攻击" class="headerlink" title="3.如何预防XSS攻击"></a>3.如何预防XSS攻击</h4><p>​    预防XSS攻击主要有两个方案</p><ul><li><p>恶意代码提交的时候(不可靠)</p><blockquote><p>当数据即将存入数据库的时候进行转义,但是数据库的数据可能在多个地方使用,有些地方不需要转义,由于我们无法判断这些数据最后的使用场景,所以该方法是<strong>不可靠的</strong></p></blockquote></li><li><p>浏览器执行之前</p><blockquote><ul><li>使用纯前端的方式,不用服务器拼接HTML返回    </li><li>对需要插入的HTML进行充分的转义</li></ul></blockquote></li><li><p>对于DOM性XSS攻击还有以下几种方式</p><blockquote><ul><li>CSP,CSP本质是简历一个白名单,告诉浏览器哪些外部资源是可以加载和执行,从而防止恶意代码的注入攻击</li><li>对敏感信息进行保护,比如cookie使用http-only,禁止脚本获取cookie</li><li>使用验证码,防止脚本伪装用户进行操作</li></ul></blockquote></li></ul><h4 id="4-什么是CSP"><a href="#4-什么是CSP" class="headerlink" title="4.什么是CSP"></a>4.什么是CSP</h4><p>​    CSP指的是内容安全侧策略</p><p>​    他的本质是建立一个白名单,告诉浏览器哪些外部资源可以加在和执行.</p><p>​    <strong>开启SCP方式:</strong></p><ul><li>一种是设置 HTTP 首部中的 <code>Content-Security-Policy</code></li><li>一种是设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ul><p>详细资料可以参考： <a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端知识回顾之 - XSS攻击&lt;/p&gt;</summary>
    
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript作用域</title>
    <link href="https://juntengma.github.io/2020/11/03/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://juntengma.github.io/2020/11/03/JavaScript/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2020-11-03T09:42:08.975Z</published>
    <updated>2020-11-03T11:28:15.228Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript深入 - 作用域相关问题</p><a id="more"></a><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是指程序源代码中定义变量的区域</p><ul><li>规定了如何让查找变量,也就是当前执行代码对变量的访问权限</li><li>JavaScript采用词法作用域(静态作用域)</li></ul><h2 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h2><p>函数的作用域在函数定义的时候就已经决定了</p><h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>函数的作用域在函数调用的时候才决定</p><h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><ul><li>JavaScript代码是逐行执行的</li><li>但是js引擎并非一行一行的分析执行程序,而是一段一段的分析执行</li></ul><h4 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h4><p>可执行代码有三种,全局代码,函数代码,eval代码,当执行到可执行代码的,就会进行准备一些工作—-&gt;执行上下文</p><ul><li>全局代码</li><li>函数代码</li><li>eval代码</li></ul><h4 id="执行上下文栈-1"><a href="#执行上下文栈-1" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h4><p>为了管理js中大量的可执行上下文,JavaScript引擎创建了执行上下文栈来管理可执行上下文</p><ul><li>当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext.<ul><li>当函数开始执行的时候,同样生成一个可以执行上下文并压入可执行上下文栈,当函数执行完毕的时候,再从执行上下文栈中弹出</li></ul></li></ul><h2 id="什么是堆栈"><a href="#什么是堆栈" class="headerlink" title="什么是堆栈"></a>什么是堆栈</h2><p>堆栈概念存在于数据结构和操作系统内存中</p><ul><li>在数据结构中<ul><li>栈中的数据存取方式为先进后出</li><li>堆是一个优先队列,按照优先级来进行排序的,优先级可以按照大小来规定</li></ul></li><li>操作系统中,内存被分为栈区和堆区<ul><li>栈区的内存由编译器自动分配释放,存放函数的参数值,局部变量值等</li><li>堆内存一般由程序员释放,若没有手动释放则程序结束时由垃圾回收记住回收</li></ul></li></ul><h2 id="内部属性"><a href="#内部属性" class="headerlink" title="内部属性"></a>内部属性</h2><p>所有typeof返回Object的对象都有一个内部属性.可以通过以下代码查看</p><pre><code>Object.prototype.toString.call(array)</code></pre><h2 id="Js内置对象"><a href="#Js内置对象" class="headerlink" title="Js内置对象"></a>Js内置对象</h2><p>js内置对象主要是只在程序执行前存在全局作用域里面的由js定义的一些全局属性,函数和用来实例化其他对象的构造函数对象.</p><p>一般我们经常用到的全局函数变量值 nan , undefined ,</p><p>全局函数: parseInt() , paeseFloat()</p><p>用来实例化的全局构造函数: Date , Object 等</p><h2 id="原型原型链"><a href="#原型原型链" class="headerlink" title="原型原型链"></a>原型原型链</h2><ul><li>js中我们使用构造函数新建对象,在每一个构造函数中都有一个prototype属性值,他的属性值是一个对象,该对象包含了可以由该构造函数的所有梳理共享的属性和方法</li><li>当我们使用构造函数新建一个对象后,在这个对象的内部将包含一个指针,这个指针指向构造函数的prototype属性对应的值,es5该指针被称为对象的原型</li><li>一般来说我们是不能</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;JavaScript深入 - 作用域相关问题&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="作用域" scheme="https://juntengma.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://juntengma.github.io/2020/11/02/JavaScript/JavaScript-ES6/"/>
    <id>https://juntengma.github.io/2020/11/02/JavaScript/JavaScript-ES6/</id>
    <published>2020-11-02T08:41:06.847Z</published>
    <updated>2020-11-02T09:48:38.394Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h4 id="ES6是什么"><a href="#ES6是什么" class="headerlink" title="ES6是什么"></a>ES6是什么</h4><p>es6是ECMA为JavaScript订制的第6个版本,2015年6月发行,涵盖了2015 - 2020</p><h4 id="ES6特性"><a href="#ES6特性" class="headerlink" title="ES6特性"></a>ES6特性</h4><ul><li>表达式<ul><li>[声明 (let/const)](#### 声明)</li><li>解构赋值</li></ul></li><li>内置对象<ul><li>字符串扩展</li><li>数值扩展</li><li>对象扩展</li><li>数组扩展</li><li>函数扩展</li><li>正则扩展</li><li>Symbol / set /Map / Proxy /Reflect</li></ul></li><li>语句与运算<ul><li>class</li><li>Module</li><li>Iterator</li></ul></li><li>异步编程<ul><li>Promise</li><li>Generator</li><li>Async</li></ul></li></ul><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><ul><li>let (声明变量,类似var,但是只在代码块中有效)<ul><li>let声明的变量只在所处于的块级有效；</li><li>let没有‘变量提升’的特性，而是‘暂时性死区（temporal dead zone）’特性</li></ul></li><li>const (声明常量)<ul><li>声明恒定变量，声明的同时就必须赋值，否则会报错</li></ul></li></ul><h4 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域:"></a>块级作用域:</h4><h5 id="ES6之前"><a href="#ES6之前" class="headerlink" title="ES6之前"></a>ES6之前</h5><ul><li>全局作用域</li><li>函数作用域</li></ul><p>因此会产生变量提升的问题</p><pre><code>function func()&#123;    console.log(test);    var test = 1;&#125;;func();//undefind在进入func之前,所有通过var声明的变量提前声明并赋予undefinded值</code></pre><h5 id="ES6-1"><a href="#ES6-1" class="headerlink" title="ES6"></a>ES6</h5><ul><li>全局作用域</li><li>函数作用域</li><li>块级作用域</li></ul><pre><code>function f1() &#123;  let n = 5;  if (true) &#123;    let n = 10;  &#125;  console.log(n); // 5&#125;function f1() &#123;  var n = 5;  if (true) &#123;    var n = 10;  &#125;  console.log(n); // 10&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;h2 id=&quot;ES6&quot;&gt;&lt;a href=&quot;#ES6&quot; class=&quot;headerlink&quot; title=&quot;ES6&quot;&gt;&lt;/a&gt;ES6&lt;/h2&gt;&lt;h4 id=&quot;ES6是什么&quot;&gt;&lt;a href=&quot;#ES6是什么&quot; class=&quot;headerl</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="https://juntengma.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>for-in &amp; for-of的区别 和 map-for &amp; Each区别</title>
    <link href="https://juntengma.github.io/2020/11/02/JavaScript/forIn-forOF-Map-forEach%E5%8C%BA%E5%88%AB/"/>
    <id>https://juntengma.github.io/2020/11/02/JavaScript/forIn-forOF-Map-forEach%E5%8C%BA%E5%88%AB/</id>
    <published>2020-11-02T07:52:25.395Z</published>
    <updated>2020-11-02T08:15:36.487Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="for-in"><a href="#for-in" class="headerlink" title="for-in"></a>for-in</h3><ul><li>遍历一个对象的除<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a>以外的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties">可枚举</a>属性, <strong>用于遍历对象</strong></li><li>for…in循环出的是key</li></ul><pre><code>const obj = &#123;    name: &#39;哇塞&#39;,    age: 18&#125;for(let item in obj)&#123;    console.log(item)&#125;// Output://name//age</code></pre><h3 id="for-of"><a href="#for-of" class="headerlink" title="for-of"></a>for-of</h3><ul><li><strong>用于遍历数组</strong></li><li>for-of 是ES6引入属性</li><li>for-of不能用来遍例普通对象,需要和Obect.keys()搭配使用</li><li>for…of循环出的是value</li></ul><pre><code>let aArray = [&#39;a&#39;,123,&#123;a:&#39;1&#39;,b:&#39;2&#39;&#125;]</code></pre><p>结论:</p><ul><li>推荐在<strong>循环对象</strong>属性的时候，使用<strong>for…in</strong></li><li>在<strong>遍历数组</strong>的时候的时候使用<strong>for…of</strong>。</li><li>for…in循环出的是key，for…of循环出的是value</li><li>注意，for…of是ES6新引入的特性。修复了ES5引入的for…in的不足</li><li>for…of不能循环普通的对象，需要通过和Object.keys()搭配使用</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h3 id=&quot;for-in&quot;&gt;&lt;a href=&quot;#for-in&quot; class=&quot;headerlink&quot; title=&quot;for-in&quot;&gt;&lt;/a&gt;for-in&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;遍历一个对象的除&lt;a href=&quot;https://deve</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>深拷贝浅拷贝</title>
    <link href="https://juntengma.github.io/2020/11/02/JavaScript/JavaScript%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://juntengma.github.io/2020/11/02/JavaScript/JavaScript%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-11-02T07:28:19.796Z</published>
    <updated>2020-11-02T11:51:38.328Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><a href="https://juejin.im/post/6844903929705136141">https://juejin.im/post/6844903929705136141</a></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。</p><p>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><p>浅拷贝只拷贝一层属性,无法拷贝引用数据类型</p><ul><li><code>Object.assign(&#123;&#125;,obj)</code>浅拷贝object</li><li><code>newobj = &#123;...obj2&#125;</code>  展开运算符浅拷贝</li><li><code>Object.fromEntries( Object.entriens(obj) ) </code>通过生成迭代器,在通过迭代器生成对象</li><li><code>Object.create(&#123;&#125;,Object.getOwnPropertyDescriptors(obj))</code></li></ul><p><strong>简单浅拷贝:</strong></p><pre><code>function clone(target)&#123;    let cloneTarget=&#123;&#125;;    for(let key in target)&#123;        cloneTarget[key] = target[key]    &#125;    return cloneTarget&#125;</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><ul><li><code>JSON.parse(JSON.stringfy( obj ))</code>通过<strong>JSON的2次转换深拷贝obj</strong><ul><li>无法拷贝<code>undefined</code>与<code>symbol</code>属性</li><li>无法拷贝<strong>循环引用</strong>对象</li></ul></li><li>loadsh:<a href="http://lodash.think2011.net/cloneDeep"><em>.cloneDeep</em></a></li></ul><p>简单深拷贝(可以处理<strong>原始数据类型 + Object</strong>):</p><ul><li>如果是原始类型，无需继续拷贝，直接返回</li><li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行深拷贝后依次添加到新对象上。</li></ul><pre><code>function smpleDeepCopy(target) &#123;  let type = typeof target  if (type === &quot;object&quot;) &#123;    let copy = &#123;&#125;;    for (let key in target) &#123;      copy[key] = smpleDeepCopy(target[key])    &#125;    return copy  &#125;  return target&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;



&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6844903929705136141&quot;&gt;https://juejin.im/post/6844903929705136141&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;浅拷贝&quot;</summary>
      
    
    
    
    
    <category term="深拷贝浅拷贝" scheme="https://juntengma.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>Https及其加密原理</title>
    <link href="https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https/"/>
    <id>https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Https/</id>
    <published>2020-10-30T08:59:24.175Z</published>
    <updated>2020-11-03T12:38:01.460Z</updated>
    
    <content type="html"><![CDATA[<p>Https协议</p><a id="more"></a><h2 id="http-协议存在的一些问题"><a href="#http-协议存在的一些问题" class="headerlink" title="http 协议存在的一些问题"></a>http 协议存在的一些问题</h2><ul><li>http报文明文发送,可能会被第三方窃听</li><li>http报文可能会被第三方截取之后修改通信内容,接收方没有办法发现报文内容的修改</li><li>http还存在认证问题,第三方可以冒充他人参与通信</li></ul><h2 id="Https简介"><a href="#Https简介" class="headerlink" title="Https简介"></a>Https简介</h2><ul><li>HTTPS指的是超文本传输安全协议,HTTPS是基于HTTTP协议的,不过它会使用TLS/SSL来对数据进行加密.</li><li>使用TLS和SSL协议,所有的信息都是加密的,第三方没有办法窃听,并且他提供了一种校验机制,信息一旦被篡改,通信双方立刻就会发现</li><li>它还配备了身份证书,防止身份被冒充的情况出现</li></ul><h2 id="TSL握手过程"><a href="#TSL握手过程" class="headerlink" title="TSL握手过程"></a>TSL握手过程</h2><ul><li>第一步:客户端向服务端发起请求,请求中包含使用的<strong>协议版本号</strong>,生成的一个<strong>随机数</strong>,以及<strong>客户端支持的加密方法</strong>.</li><li>第二步:服务端接收到请求之后,确认双方使用的<strong>加密方法</strong>,并给出服务器的证书和服务器生成的随机数</li><li>第三步:客户端确认服务器证书有效之后,生成一个新的随机数,并使用数字证书的公匙,加密这个随机数,然后发给服务器,并且还会提供一个前面所有内容的hash值,用来提供服务器检验</li><li>第四步:服务器使用自己的私匙,来解密客户端发送过来的随机数,并提供给前面所有内容的hash值来给客户端检验</li><li>第五步: 客户端和服务端根据约定的加密方法使用前面的三个随机数,生成对话密匙,以后对话的过程都使用这个秘钥来加密信息</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Https协议&lt;/p&gt;</summary>
    
    
    
    <category term="Https" scheme="https://juntengma.github.io/categories/Https/"/>
    
    
    <category term="Https" scheme="https://juntengma.github.io/tags/Https/"/>
    
  </entry>
  
  <entry>
    <title>Http</title>
    <link href="https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http/"/>
    <id>https://juntengma.github.io/2020/10/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http/</id>
    <published>2020-10-30T08:49:32.136Z</published>
    <updated>2020-10-30T09:19:17.633Z</updated>
    
    <content type="html"><![CDATA[<p>HTTPS的一些知识</p><a id="more"></a><h3 id="1-什么是HTTP协议"><a href="#1-什么是HTTP协议" class="headerlink" title="1/什么是HTTP协议"></a>1/什么是HTTP协议</h3><ul><li>HTTP协议是超文本传输协议的简称,规定了服务端和客户端(前后端)通信方式以及占用的接口</li><li>HTTP协议是一个局域TCP/IP通信协议来传输数据的</li></ul><h3 id="2-HTTP协议的特性"><a href="#2-HTTP协议的特性" class="headerlink" title="2/HTTP协议的特性"></a>2/HTTP协议的特性</h3><ul><li>HTTP协议支持客户端/服务端模式,也是一种请求/响应模式的协议</li><li>简单快速,客户端向服务器请求服务时,只需要提供请求方法和URL.常用的有 GET,PSOT,DELETE,HEAD等</li><li>无连接:HTTP协议规定浏览器和服务端只能保持短暂的链接,浏览器的每次请求都需要与服务器建立一个TCP链接,服务器处理完成后立即断开TCP链接</li><li>无状态:无状态是指服务器不跟踪也不记录请求过的状态,后续如果需要前面的信息,必须重传.</li><li>但是可以借助cookie和session记住来做身份认证和状态记录</li></ul><h3 id="3-HTTP报文组成"><a href="#3-HTTP报文组成" class="headerlink" title="3/HTTP报文组成"></a>3/HTTP报文组成</h3><h4 id="请求报问构成"><a href="#请求报问构成" class="headerlink" title="请求报问构成"></a>请求报问构成</h4><ul><li>请求行</li><li>请求头(Request Header)</li><li>请求正文</li></ul><h4 id="响应报文构成"><a href="#响应报文构成" class="headerlink" title="响应报文构成"></a>响应报文构成</h4><ul><li>状态行</li><li>响应头(Response Header)</li><li>响应正文</li></ul><h3 id="4-常见请求方法"><a href="#4-常见请求方法" class="headerlink" title="4/常见请求方法"></a>4/常见请求方法</h3><ul><li>GET</li><li>POST</li><li>HEAD:类似GET请求,但是返回的响应中没有具体内容,用于获取报头</li><li>PUT:从客户端向服务器传送的数据取代指定的文档的内容</li><li>DELETE:请求服务器删除指定页面</li></ul><h3 id="5-响应状态码"><a href="#5-响应状态码" class="headerlink" title="5/响应状态码"></a>5/响应状态码</h3><p>状态码分类：</p><ul><li>1XX- 信息型，服务器收到请求，需要请求者继续操作。</li><li>2XX- 成功型，请求成功收到，理解并处理。</li><li>3XX - 重定向，需要进一步的操作以完成请求。</li><li>4XX - 客户端错误，请求包含语法错误或无法完成请求。</li><li>5XX - 服务器错误，服务器在处理请求的过程中发生了错误。</li></ul><h3 id="6-常见状态码"><a href="#6-常见状态码" class="headerlink" title="6/常见状态码"></a>6/常见状态码</h3><ul><li>200:请求成功</li><li>204:无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>301:永久移动。请求的资源已被永久的重定向到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302:临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>304:未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>400:客户端请求的语法错误，服务器无法理解</li><li>401:请求要求用户的身份认证</li><li>403:服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404:服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>422:请求格式正确，但是由于含有语义错误，无法响应。</li><li>500:服务器内部错误，无法完成请求</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;HTTPS的一些知识&lt;/p&gt;</summary>
    
    
    
    <category term="Http" scheme="https://juntengma.github.io/categories/Http/"/>
    
    
    <category term="Http" scheme="https://juntengma.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://juntengma.github.io/2020/10/30/%E7%AE%97%E6%B3%95/"/>
    <id>https://juntengma.github.io/2020/10/30/%E7%AE%97%E6%B3%95/</id>
    <published>2020-10-30T03:39:39.217Z</published>
    <updated>2020-10-30T11:14:46.209Z</updated>
    
    <content type="html"><![CDATA[<p>复习做的几个算法练习题/…</p><a id="more"></a><p>一、不借助临时变量，进行两个整数的交换</p><pre><code>let a = 1, b = 2;[a, b] = [b, a]console.log(a, b);</code></pre><p>二、字符串查找：请使用最基本的遍历来实现判断字符串 a 是否被包含在字符串 b 中，并返回第一次出现的位置（找不到返回 -1）。<br>🌰:</p><pre><code>a=&#39;34&#39;;b=&#39;1234567&#39;; // 返回 2a=&#39;35&#39;;b=&#39;1234567&#39;; // 返回 -1a=&#39;355&#39;;b=&#39;12354355&#39;; // 返回 5isContain(a,b);</code></pre><p>三、统计一个字符串出现最多的字母：给出一段英文连续的英文字符窜，找出重复出现次数最多的字母。<br>🌰:</p><pre><code>输入 ： afjghdfraaaasdenas输出 ： a</code></pre><pre><code>function hasMost(str) &#123;  let counts = &#123;&#125;  for (let item of str) &#123;    counts[`$&#123;item&#125;`] = 0    for (let j of str) &#123;      if (j === item) &#123;        counts[`$&#123;item&#125;`] = counts[`$&#123;item&#125;`] + 1;      &#125;    &#125;  &#125;  getMax(counts)&#125;function getMax(counts) &#123;  let maxValue = 0  let maxItem = &#39;&#39;  for (let item in counts) &#123;    if (counts[item] &gt; maxValue) &#123;      maxValue = counts[item]      maxItem = item    &#125;  &#125;  console.log(maxItem, maxValue)&#125;</code></pre><p>四、找出下列正数组的最大差值<br>🌰:</p><pre><code>输入 [10,5,11,7,8,9]输出 6</code></pre><pre><code>function getDifferenceValue(arr) &#123;  let maxNum = null, minNum = null  arr.forEach(item =&gt; &#123;    !maxNum ? maxNum = item : !minNum ? minNum = item : null    item &gt; maxNum      ? maxNum = item      : item &lt; minNum        ? minNum = item        : minNum  &#125;)  console.log(maxNum, minNum)  console.log(maxNum - minNum)&#125;</code></pre><p>五、斐波那契数列：1、1、2、3、5、8、13、21。输入n，输出数列中第n位数的值。<br>🌰:</p><pre><code>function getValue(num) &#123;  if (num &lt; 2) &#123;    return 1  &#125; else &#123;    return (getValue(num - 1) + getValue(num - 2))  &#125;&#125;</code></pre><p>六、用js实现二分查找：二分查找的前提是有序数组</p><pre><code>🌰:将要查找的值每次与中间值比较，大于中间值，则在右边进行相同的查找，小于中间值则在左边进行比较查找，找到返回索引值，没找到返回-1。</code></pre><p>var missingNumber = function (nums) {<br>  let left = 0, right = nums.length - 1;<br>  while (left &lt;= right) {<br>    let mid = Math.floor((left + right) / 2);<br>    if (mid === nums[mid]) {<br>      left = mid + 1;<br>    } else if (mid &lt; nums[mid]) {<br>      right = mid - 1;<br>    }<br>  }<br>  return left;<br>};</p><p>```<br>七、数组去重</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;复习做的几个算法练习题/…&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://juntengma.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Http各版本特性及其区别</title>
    <link href="https://juntengma.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E7%89%88%E6%9C%AC%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7/"/>
    <id>https://juntengma.github.io/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/Http%E7%89%88%E6%9C%AC%E5%8F%8A%E5%85%B6%E7%89%B9%E6%80%A7/</id>
    <published>2020-10-29T08:21:42.848Z</published>
    <updated>2020-10-30T11:15:50.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP各版本特性及区别"><a href="#HTTP各版本特性及区别" class="headerlink" title="HTTP各版本特性及区别"></a>HTTP各版本特性及区别</h3><a id="more"></a><p>本文参考:<br><a href="https://juejin.im/post/6844903923136856078">https://juejin.im/post/6844903923136856078</a><br><a href="https://segmentfault.com/a/1190000019891825">https://segmentfault.com/a/1190000019891825</a></p><p>HTTP 是基于 TCP/IP 协议的一个应用层协议，是现代互联网的一个基础协议。规定了客户端与服务端之间的通信格式以及所占用的服务端口80(HTTPS是443)。</p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>HTTP 协议从开始立项到现在一共经历了 4 个版本:</p><pre><code>HTTP 0.9 -&gt; HTTP 1.0 -&gt; HTTP 1.1 -&gt; HTTP 2</code></pre><h4 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h4><p>HTTP 0.9 是一个最古老的版本</p><p><strong>只支持GET请求方式</strong>：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息<br>没有请求头概念：所以不能在请求中指定版本号，<strong>服务端也只具有返回 HTML字符串的能力</strong><br><strong>服务端相响应之后，立即关闭TCP连接</strong></p><h4 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h4><p>随着 HTTP 1.0 的发布，这个版本:</p><p>请求方式<strong>新增了POST，DELETE，PUT，HEADER等方式</strong><br>增添了<strong>请求头</strong>和<strong>响应头</strong>的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)<br>扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输<br>在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。</p><h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p>一个简单请求的头信息</p><pre><code>GET / HTTP/1.0User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)Accept: */*</code></pre><p>浏览器控制台reponse headers<br><img src="https://s1.ax1x.com/2020/10/30/BtJAlF.png"></p><p>可以看到在请求方法之后有 请求资源的位置 + 请求协议版本，之后是一些客户端的信息配置</p><h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p>一个简单响应的头信息(v1.0)</p><pre><code>HTTP/1.0 200 OKContent-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMT// 这是一个空行...数据内容</code></pre><p>浏览器控制台request headers<br><img src="https://s1.ax1x.com/2020/10/30/BtJfhV.png"></p><p>服务端的响应头第一个就是 请求协议版本，后面紧跟着是这次请求的状态码、以及状态码的描述，之后的内容是一些关于返回内容的描述。</p><h5 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h5><p>在 HTTP 1.0 的时候，任何的资源都可以被传输，传输的格式呢也是多种多样的，客户端在收到响应体的内容的时候就是根据这个 Content-Type 去进行解析的。所以<strong>服务端返回时候</strong>必须带着这个字段。<br><img src="https://s1.ax1x.com/2020/10/30/BtYKBj.png"><br>一些常见的 Content-Type 可以参考 对照表。 这些 Content-Type 有一个总称叫做<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a></p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>无状态：服务器不跟踪不记录请求过的状态</li><li><strong>无连接</strong>：<strong>HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接）</strong></li></ul><h6 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h6><p>对于无状态的特性可以借助cookie/session机制来做身份认证和状态记录</p><h6 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h6><p>无连接导致的性能缺陷有两种：</p><ul><li><strong>无法复用连接</strong><br>每次发送请求，都需要进行一次tcp连接（即3次握手4次挥手），使得网络的利用率非常低</li><li><strong>队头阻塞</strong><br>HTTP 1.0 规定在前一个请求响应到达之后下一个请求才能发送，如果前一个阻塞，后面的请求也给阻塞的</li></ul><h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h4><p>  HTTP 1.1 是在 1.0 发布之后的半年就推出了，完善了 1.0 版本。目前也还有很多的互联网项目基于 HTTP 1.1 在向外提供服务。</p><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><p>长连接：新增Connection字段，可以设置keep-alive值保持连接不断开<br>管道化：基于上面长连接的基础，管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回<br>缓存处理：新增字段cache-control<br>断点传输</p><h6 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h6><p>HTTP 1.1默认保持长连接，数据传输完成保持tcp连接不断开,继续用这个通道传输数据.</p><p>B站首页，就有keep-alive，因为他们也有IM的成分在里面。需要大量复用TCP连接～<br><img src="https://s1.ax1x.com/2020/10/30/Btt4L4.png"></p><h6 id="管道化"><a href="#管道化" class="headerlink" title="管道化"></a>管道化</h6><p>基于长连接的基础，我们先看没有管道化请求响应：</p><p>tcp没有断开，用的同一个通道</p><pre><code>--&gt; 请求1 &gt; 响应1 --&gt; 请求2 &gt; 响应2 --&gt; 请求3 &gt; 响应3</code></pre><p>管道化的请求响应：</p><pre><code>--&gt; 请求1 --&gt; 请求2 --&gt; 请求3 --&gt; 响应1 --&gt; 响应2 --&gt; 响应3</code></pre><p>即使服务器先准备好响应2,也是按照请求顺序先返回响应1</p><p>虽然管道化，可以一次发送多个请求，但是响应仍是顺序返回，仍然无法解决队头阻塞的问题</p><h6 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理:"></a>缓存处理:</h6><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。 通过设置字段cache-control来控制缓存。</p><p><strong>怎么解决解决队头阻塞的问题?</strong></p><blockquote><p>实际上，现阶段的浏览器厂商采取了另外一种做法，它允许我们打开多个TCP的会话。<br>也就是说，上图我们看到的并行，其实是不同的TCP连接上的HTTP请求和响应。这也就是我们所熟悉的浏览器对同域下并行加载6~8个资源的限制。而这，才是真正的并行！</p></blockquote><p><strong>浏览器同域名请求的最大并发数限制</strong></p><blockquote><p>当我们在浏览网页的时候，对浏览速度有一个重要的影响因素，就是浏览器的并发数量。并发数量简单通俗的讲就是，当浏览器网页的时候同时工作的进行数量。</p></blockquote><ul><li><p>HTTP客户端一般对同一个服务器的并发连接个数都是有限制的。<br>实际上，浏览器确实使用并行连接，但它们将并行连接的总数限制为少量（<strong>通常为四个</strong>）。服务器可以自由地关闭来自特定客户端的过多连接。</p></li><li><p>一些主流浏览器对HTTP 1.1和HTTP 1.0的最大并发连接数目，可以参考如下表格：</p></li></ul><p><img src="https://s1.ax1x.com/2020/10/30/BtcGjA.png"></p><h6 id="断点传输"><a href="#断点传输" class="headerlink" title="断点传输"></a>断点传输</h6><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p><h5 id="Http-1-1的致命缺点："><a href="#Http-1-1的致命缺点：" class="headerlink" title="Http 1.1的致命缺点："></a>Http 1.1的致命缺点：</h5><p>1.明文传输<br>2.其实还是没有解决无状态连接的<br>3.当有多个请求同时被挂起的时候,就会拥塞请求通道，导致后面请求无法发送<br>4.臃肿的消息首部:HTTP/1.1能压缩请求内容,但是消息首部不能压缩;在现今请求中,消息首部占请求绝大部分(甚至是全部)也较为常见.</p><h4 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP 2"></a>HTTP 2</h4><h5 id="特性-2"><a href="#特性-2" class="headerlink" title="特性:"></a>特性:</h5><h6 id="二进制帧封装"><a href="#二进制帧封装" class="headerlink" title="二进制帧封装:"></a>二进制帧封装:</h6><p>HTTP 1.x 的解析是基于文本，HTTP 2之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率</p><h6 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用:"></a>多路复用:</h6><blockquote><p>所有的请求都是通过一个 TCP 连接并发完成。<br>HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。</p><p>同时，流还支持优先级和流量控制。当流并发时，就会涉及到流的优先级和依赖。</p><p>即：HTTP2.0对于同一域名下所有请求都是基于流的，不管对于同一域名访问多少文件，也只建立一路连接。优先级高的流会被优先发送。图片请求的优先级要低于 CSS 和 SCRIPT，这个设计可以确保重要的东西可以被优先加载完</p></blockquote><h6 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩:"></a>头部压缩:</h6><p>由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。所以 HTTP 2 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源，</p><p>HTTPS 和 HTTP</p><ul><li>HTTPS 协议需要申请证书</li><li>HTTP 和 HTTPS 使用端口不一样，前者是80，后者是443</li><li>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 运行在 SSL/TLS 之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li><li>HTTPS 可以有效的防止运营商劫持</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;HTTP各版本特性及区别&quot;&gt;&lt;a href=&quot;#HTTP各版本特性及区别&quot; class=&quot;headerlink&quot; title=&quot;HTTP各版本特性及区别&quot;&gt;&lt;/a&gt;HTTP各版本特性及区别&lt;/h3&gt;</summary>
    
    
    
    <category term="Http" scheme="https://juntengma.github.io/categories/Http/"/>
    
    
    <category term="Http" scheme="https://juntengma.github.io/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>防抖节流及其应用场景</title>
    <link href="https://juntengma.github.io/2020/10/29/JavaScript/JavaScript%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>https://juntengma.github.io/2020/10/29/JavaScript/JavaScript%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2020-10-29T02:30:59.717Z</published>
    <updated>2020-11-02T07:04:49.744Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​    复习一下防抖节流及其应用场景</p></blockquote><a id="more"></a><h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><p>在事件被触发的n秒后再执行回调,如果在这n秒内又被触发,则重新计时</p><pre><code>function debounse(fun, delay) &#123;    let timer;    // 设置一个 timer    return function (args) &#123;      let _this = this      let _args = args      clearTimeout(timer)      timer = setTimeout(function () &#123;        fun.call(_this, _args);      &#125;, delay);    &#125;  &#125;</code></pre><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p><pre><code>function throttle(fun, delay) &#123;    let last, timer    return function (args) &#123;      let _this = this      let _args = args      let now = +new Date()      if (last &amp;&amp; now &lt; last + delay) &#123;        clearTimeout(timer)        timer = setTimeout(function () &#123;          last = now          fun.apply(_this, _args)        &#125;, delay)      &#125; else &#123;        last = now        fun.apply(_this, _args)      &#125;    &#125;  &#125;</code></pre><h3 id="demo"><a href="#demo" class="headerlink" title="demo:"></a>demo:</h3><h5 id="模拟ajax请求"><a href="#模拟ajax请求" class="headerlink" title="模拟ajax请求"></a>模拟ajax请求</h5><pre><code>function ajax(params) &#123;    console.log(&#39;ajax request : &#39; + params)&#125;</code></pre><h5 id="普通input"><a href="#普通input" class="headerlink" title="普通input:"></a>普通input:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252be5c94d6b?imageslim"></p><h5 id="加入防抖"><a href="#加入防抖" class="headerlink" title="加入防抖:"></a>加入防抖:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4b429b56?imageslim"></p><h5 id="加入节流"><a href="#加入节流" class="headerlink" title="加入节流:"></a>加入节流:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4c1a9686?imageslim"></p><h3 id="demo代码"><a href="#demo代码" class="headerlink" title="demo代码"></a>demo代码</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  没有防抖的Input &lt;input type=&quot;text&quot; class=&quot;unDebounce&quot;&gt;  &lt;br&gt;  加入防抖的Input &lt;input type=&quot;text&quot; class=&quot;debounce&quot;&gt;  &lt;br&gt;  加入截留的Input &lt;input type=&quot;text&quot; class=&quot;htrottle&quot;&gt;&lt;/body&gt;&lt;script&gt;  function ajax(params) &#123;    console.log(&#39;ajax request : &#39; + params)  &#125;  let inputValue0 = document.querySelector(&#39;.unDebounce&#39;)  inputValue0.addEventListener(&#39;keyup&#39;, function (e) &#123;    ajax(e.target.value)  &#125;)  /**********************防抖********************************/  function debounse(fun, delay) &#123;    let timer;    // 设置一个 timer    return function (args) &#123;      let _this = this      // 取debounce执行作用域的this      let _args = args      clearTimeout(timer)      timer = setTimeout(function () &#123;        fun.call(_this, args);      &#125;, delay);    &#125;  &#125;  let inputValue1 = document.querySelector(&#39;.debounce&#39;)  let debounse_ajax = debounse(ajax, 500)  inputValue1.addEventListener(&#39;keyup&#39;, function (e) &#123;    debounse_ajax(e.target.value)  &#125;)  /**********************节流********************************/  function throttle(fun, delay) &#123;    let last, timer    return function (args) &#123;      let _this = this      let _args = args      let now = +new Date()      if (last &amp;&amp; now &lt; last + delay) &#123;        clearTimeout(timer)        timer = setTimeout(function () &#123;          last = now          fun.apply(_this, _args)        &#125;, delay)      &#125; else &#123;        last = now        fun.apply(_this, _args)      &#125;    &#125;  &#125;  let inputValue2 = document.querySelector(&#39;.htrottle&#39;)  let htrottle_ajax = throttle(ajax, 2000)  inputValue2.addEventListener(&#39;keyup&#39;, function (e) &#123;    htrottle_ajax(e.target.value)  &#125;)&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;​    复习一下防抖节流及其应用场景&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="防抖节流" scheme="https://juntengma.github.io/tags/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>JSON-Server</title>
    <link href="https://juntengma.github.io/2020/10/28/%E5%B7%A5%E5%85%B7/Json-server/"/>
    <id>https://juntengma.github.io/2020/10/28/%E5%B7%A5%E5%85%B7/Json-server/</id>
    <published>2020-10-28T11:04:41.772Z</published>
    <updated>2020-10-29T07:41:14.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="json-server"><a href="#json-server" class="headerlink" title="json-server"></a>json-server</h1><p>json-server 是什么？如何使用？</p><blockquote><p>json-server 是一个 npm 管理的包，可以提供前端提供mock的功能。</p></blockquote><a id="more"></a><h2 id="json-server-的使用"><a href="#json-server-的使用" class="headerlink" title="json-server 的使用"></a>json-server 的使用</h2><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1/安装"></a>1/安装</h4><p>全局安装:</p><pre><code>- yarn global add json-server- npm install -g json-server </code></pre><h4 id="2-提供一个json数据的文件"><a href="#2-提供一个json数据的文件" class="headerlink" title="2.提供一个json数据的文件"></a>2.提供一个json数据的文件</h4><h4 id="3-使用json-server命令开启一个端口服务"><a href="#3-使用json-server命令开启一个端口服务" class="headerlink" title="3.使用json-server命令开启一个端口服务"></a>3.使用json-server命令开启一个端口服务</h4><pre><code>json-server --watch --port 3000 test.json</code></pre><h4 id="4-接口的使用"><a href="#4-接口的使用" class="headerlink" title="4.接口的使用:"></a>4.接口的使用:</h4><blockquote><ol><li>列表</li></ol></blockquote><blockquote><ol start="2"><li>详情</li></ol></blockquote><blockquote><ol start="3"><li>分页</li></ol></blockquote><blockquote><ol start="4"><li>排序</li></ol></blockquote><blockquote><ol start="5"><li>全局查询<br>需要使用第三方接口调试工具的(postman)</li></ol></blockquote><blockquote><ol start="6"><li>提供 增加（post）、</li></ol></blockquote><blockquote><ol start="7"><li>删除(delete)、</li></ol></blockquote><blockquote><ol start="8"><li>更新(put)</li></ol></blockquote><p>我们常见的接口：都是 get 或者 post 请求一个 url 地址即可。<br>json-server 除了常见的 get 或者 post ，还提供了诸如 put 、delete 这样的HTTP请求方式，<strong>对于这种使用 http请求方式 + 请求url地址 形成的 api ，我们一般叫做 RESTFul 风格的api</strong>, <em>RESTFul 风格的api底层遵循的是 REST 架构这种协议。</em></p><p>倒叙:<a href="http://localhost:3000/news?sort=id&amp;order=desc">http://localhost:3000/news?sort=id&amp;order=desc</a> </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;json-server&quot;&gt;&lt;a href=&quot;#json-server&quot; class=&quot;headerlink&quot; title=&quot;json-server&quot;&gt;&lt;/a&gt;json-server&lt;/h1&gt;&lt;p&gt;json-server 是什么？如何使用？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;json-server 是一个 npm 管理的包，可以提供前端提供mock的功能。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Json-server" scheme="https://juntengma.github.io/categories/Json-server/"/>
    
    
    <category term="Json-server" scheme="https://juntengma.github.io/tags/Json-server/"/>
    
  </entry>
  
  <entry>
    <title>JSONP跨域请求及其原理</title>
    <link href="https://juntengma.github.io/2020/10/28/Ajax/JsonP/"/>
    <id>https://juntengma.github.io/2020/10/28/Ajax/JsonP/</id>
    <published>2020-10-28T10:46:25.938Z</published>
    <updated>2020-10-29T08:12:22.160Z</updated>
    
    <content type="html"><![CDATA[<p>JSONP及其原理</p><a id="more"></a><h5 id="1、JSONP的产生"><a href="#1、JSONP的产生" class="headerlink" title="1、JSONP的产生"></a>1、JSONP的产生</h5><p><strong>背景:</strong></p><ul><li><p>因为浏览器同源策略限制,AJAX跨域请求不到信息</p></li><li><p>Web页面上面调用js文件不受是否跨域影响(类似的还有<code>&lt;script&gt;</code>,<code>&lt;IMG&gt;</code>,<code>&lt;iframe&gt;</code>)</p></li><li><p>于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、Web socket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；</p></li><li><p>恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被JS原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；</p></li><li><p>客户端在对JSON文件调用成功之后,也就获得了自己所需要的数据,剩下的就是按自己的需求进行处理和展现了</p></li><li><p>为了方便客户使用数据,逐渐形成了一种非正式传输协议—JSONP.</p><blockquote><p>该协议允许用户传递一个callback参数给服务端,然后服务端返回数据时会将这个callback参数坐会函数名来包裹JSON数据,这样客户端就可以随意订制自己的函数来自动处理返回函数了</p></blockquote></li></ul><h5 id="2、JSONP弊端"><a href="#2、JSONP弊端" class="headerlink" title="2、JSONP弊端"></a>2、JSONP弊端</h5><ul><li>只能发送get请求</li><li>需要服务端配合</li></ul><h5 id="3、JSON流程"><a href="#3、JSON流程" class="headerlink" title="3、JSON流程"></a>3、JSON流程</h5><ul><li>先定义好全局函数</li><li>动态创建script标签</li><li>给服务器提供事先创建好的容器</li><li>服务器获取容器</li><li>将内容填充进容器</li></ul><h5 id="4、-代码实现-https-github-com-JuntengMa-JavaScript-tree-master-JsonP"><a href="#4、-代码实现-https-github-com-JuntengMa-JavaScript-tree-master-JsonP" class="headerlink" title="4、[代码实现]:https://github.com/JuntengMa/JavaScript/tree/master/JsonP"></a>4、[代码实现]:<a href="https://github.com/JuntengMa/JavaScript/tree/master/JsonP">https://github.com/JuntengMa/JavaScript/tree/master/JsonP</a></h5>]]></content>
    
    
    <summary type="html">&lt;p&gt;JSONP及其原理&lt;/p&gt;</summary>
    
    
    
    <category term="JSONP" scheme="https://juntengma.github.io/categories/JSONP/"/>
    
    
    <category term="JSONP" scheme="https://juntengma.github.io/tags/JSONP/"/>
    
  </entry>
  
  <entry>
    <title>Ajax</title>
    <link href="https://juntengma.github.io/2020/10/28/Ajax/Ajax/"/>
    <id>https://juntengma.github.io/2020/10/28/Ajax/Ajax/</id>
    <published>2020-10-28T08:18:31.341Z</published>
    <updated>2020-10-30T11:16:15.122Z</updated>
    
    <content type="html"><![CDATA[<p>AJAX复习一下~</p><a id="more"></a><h5 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h5><h5 id="01-ajax是什么"><a href="#01-ajax是什么" class="headerlink" title="01-ajax是什么"></a>01-ajax是什么</h5><blockquote><p>​    JavaScript执行异步网络请求</p></blockquote><p><img src="https://s1.ax1x.com/2020/10/28/B3MoX8.png"></p><h5 id="02-ajax原理"><a href="#02-ajax原理" class="headerlink" title="02-ajax原理"></a>02-ajax原理</h5><p><strong>现在浏览器AJAX主要依靠XMLHttpRequest对象实现</strong></p><p><img src="https://s1.ax1x.com/2020/10/28/B3l0sK.png"></p><h5 id="03-创建ajax"><a href="#03-创建ajax" class="headerlink" title="03 - 创建ajax"></a>03 - 创建ajax</h5><h6 id="1-创建Ajax核心对象XMLHttpRequest"><a href="#1-创建Ajax核心对象XMLHttpRequest" class="headerlink" title="1/创建Ajax核心对象XMLHttpRequest"></a>1/创建Ajax核心对象XMLHttpRequest</h6><pre><code>var xhr = null ;if(window.XMLHttpRequest)&#123;    xhr = new XMLHttpRequest()&#125;else&#123;    xhr = new ActiveXobject(&quot;Microsoft.XMLHTTP&quot;)&#125;</code></pre><h6 id="2-向服务器发送请求"><a href="#2-向服务器发送请求" class="headerlink" title="2/向服务器发送请求"></a>2/向服务器发送请求</h6><pre><code>xhr.open(method,url,async:boolean)xhr.send(string); //POST请求时候采用string参数,否则不需要带参数</code></pre><ul><li><strong>method</strong> : GET/POST</li><li>**url:**请求链接(位置)</li><li>**async:**是否异步</li></ul><pre><code>xhr.open(&quot;POST&quot;,&quot;test.html&quot;,true);  xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);  xhr.send(&quot;fname=Henry&amp;lname=Ford&quot;);  //post请求参数放在send里面，即请求体</code></pre><h6 id="3-服务器响应处理-区分同步-异步情况"><a href="#3-服务器响应处理-区分同步-异步情况" class="headerlink" title="3/服务器响应处理(区分同步/异步情况)"></a>3/服务器响应处理(区分同步/异步情况)</h6><ul><li>responseText:获得字符串形式的响应数据</li><li>ResponseXML:获得XML形式的响应数据</li></ul><p>👹同步处理数据</p><pre><code>1. xhr.open(&quot;GET&quot;,&quot;info.txt&quot;,false);  2. xhr.send();  3. document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText; //获取数据直接显示在页面上</code></pre><p>👺异步处理数据(要在请求状态改变事件中处理。)</p><pre><code>1. xhr.onreadystatechange=function()  &#123; 2.    if (xhr.readyState==4 &amp;&amp;xhr.status==200)  &#123; 3.       document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText;  4.      &#125;5.    &#125; </code></pre><h6 id="4-什么是readyState"><a href="#4-什么是readyState" class="headerlink" title="4/什么是readyState?"></a>4/什么是readyState?</h6><p>readyState是XMLHttpRequest对象的一个属性,用来表示当前XMLHttpRequest对象处于什么状态</p><ul><li>0 : 未初始化,尚未调用xhr.open()方法</li><li>1 : 启动,已经调用xhr.open放大,但是未send</li><li>2 : 发送,已经调用xhr.send方法,但是还没有收到响应</li><li>3 : 接收,已经接收到部分响应数据</li><li>4 : 完成,已经接收到全部响应数据,并且可以在客户端使用</li></ul><h6 id="05-GET和POST请求数据区别"><a href="#05-GET和POST请求数据区别" class="headerlink" title="05/GET和POST请求数据区别"></a>05/GET和POST请求数据区别</h6><ul><li>get请求,参数在url中显示,post请求放在send里面</li><li>get请求发送数据量小,Post请求发送数据量比较大</li><li>get请求安全性低,会被缓存,POST反之</li></ul><h5 id="04-AJAX代码"><a href="#04-AJAX代码" class="headerlink" title="04/AJAX代码"></a>04/AJAX代码</h5><pre><code>function verificationParams(requestInfo) &#123;    //地址不能为空    if (!requestInfo.url) &#123;        throw new Error(&#39;输入请求地址&#39;)    &#125;    //判断是异步是否合规    if (typeof requestInfo.async !== &#39;boolean&#39;) &#123;        throw new Error(&#39;async只接受boolean类型数据&#39;)    &#125;    //请求方式    if (!(requestInfo.type.toUpperCase() === &#39;GET&#39; || requestInfo.type.toUpperCase() === &#39;post&#39;)) &#123;        throw new Error(&#39;请求方式有误&#39;)    &#125;&#125;function ajax(params) &#123;    //默认参数对象    let requestInfo=&#123;        type: &#39;GET&#39;,//请求方式        url:&#39;&#39;,        data:&#39;&#39;,//请求参数        datatype:&#39;string&#39;, //数据类型        async:true,//异步还是同步        callBack:function()&#123;&#125; //处理函数        &#125;    for(let item in params)&#123;        requestInfo[item] = params[item]    &#125;    verificationParams(requestInfo)    const &#123; type, url, data, datatype, async, callBack &#125; = requestInfo    //数据类型转换    let str=&#39;&#39;    let dataType = Object.prototype.toString.call(data)    if (dataType===&#39;[object String]&#39;)&#123;        str = data.replace(/,/g,&#39;&amp;&#39;)    &#125; else if (dataType===&#39;[object Object]&#39;)&#123;        for(let attr in data)&#123;            str+=attr+&#39;=&#39;+data[attr]+&#39;&amp;&#39;        &#125;        str=str.slice(0,-1)    &#125;    let xhr = new XMLHttpRequest()    if(type.toUpperCase()===&#39;GET&#39;)&#123;        xhr.open(type.toUpperCase(),url+&#39;?&#39;+str,async)        xhr.send()    &#125;else&#123;        xhr.open(type.toUpperCase(),url,async)        xhr.setRequestHeader(&#39;content-type&#39;, &#39;application/x-www-form-urlencoded&#39;)        xhr.send(str)    &#125;    xhr.onload=function()&#123;        if(datatype===&#39;json&#39;)&#123;            callBack(eval(&#39;(&#39;+xhr.responseText+&#39;)&#39;))        &#125;else&#123;            callBack(xhr.responseText)        &#125;    &#125;&#125;function Ajax(params)&#123;    let promise=new Promise(function(resolve,reject)&#123;        ajax(&#123;            url:params.url,            type:params.type.toUpperCase() || &#39;GET&#39;,            data:params.data ||&#39;&#39;,            datatype:params.datatype || &#39;string&#39;,            async:params.async || true,            callBack:function(res)&#123;                resolve(res)            &#125;        &#125;)    &#125;)    return promise&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;AJAX复习一下~&lt;/p&gt;</summary>
    
    
    
    <category term="Ajax" scheme="https://juntengma.github.io/categories/Ajax/"/>
    
    <category term="Axios" scheme="https://juntengma.github.io/categories/Ajax/Axios/"/>
    
    
    <category term="Ajax" scheme="https://juntengma.github.io/tags/Ajax/"/>
    
    <category term="Axios" scheme="https://juntengma.github.io/tags/Axios/"/>
    
  </entry>
  
  <entry>
    <title>盒模型,BFC</title>
    <link href="https://juntengma.github.io/2020/10/28/Css/Css%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <id>https://juntengma.github.io/2020/10/28/Css/Css%E7%9B%92%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-10-28T07:57:01.036Z</published>
    <updated>2020-10-29T07:36:20.410Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>   关于盒模型的一些总结</p></blockquote><a id="more"></a><h4 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h4><h5 id="标准盒模型-box-sizing-content-box"><a href="#标准盒模型-box-sizing-content-box" class="headerlink" title="标准盒模型(box-sizing:content-box)"></a>标准盒模型(box-sizing:content-box)</h5><pre><code>width = content width;height = content height;</code></pre><h5 id="怪异盒模型-box-sizing-border-box"><a href="#怪异盒模型-box-sizing-border-box" class="headerlink" title="怪异盒模型(box-sizing:border-box)"></a>怪异盒模型(box-sizing:border-box)</h5><pre><code>width = content width + padding + border;height = content height + padding + border;</code></pre><h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><h5 id="01-什么是BFC"><a href="#01-什么是BFC" class="headerlink" title="01/什么是BFC?"></a>01/什么是BFC?</h5><p>块级格式化上下文</p><p>BFC是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p><h5 id="02-建立BFC"><a href="#02-建立BFC" class="headerlink" title="02/建立BFC"></a>02/建立BFC</h5><ul><li>浮动</li><li>绝对定位</li><li>行内块元素</li><li>表格单元</li><li>弹性盒</li><li>overflow不为visible</li></ul><h5 id="03-BFC应用场景"><a href="#03-BFC应用场景" class="headerlink" title="03/BFC应用场景"></a>03/BFC应用场景</h5><ul><li>清除浮动</li><li>阻止元素被浮动元素覆盖</li><li>实现两列自适应布局</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;   关于盒模型的一些总结&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Css" scheme="https://juntengma.github.io/categories/Css/"/>
    
    <category term="盒模型" scheme="https://juntengma.github.io/categories/Css/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="BFC" scheme="https://juntengma.github.io/categories/Css/%E7%9B%92%E6%A8%A1%E5%9E%8B/BFC/"/>
    
    
    <category term="Css" scheme="https://juntengma.github.io/tags/Css/"/>
    
    <category term="盒模型" scheme="https://juntengma.github.io/tags/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="BFC" scheme="https://juntengma.github.io/tags/BFC/"/>
    
  </entry>
  
  <entry>
    <title>DOM事件 , 事件流</title>
    <link href="https://juntengma.github.io/2020/10/28/JavaScript/JavaScriptDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <id>https://juntengma.github.io/2020/10/28/JavaScript/JavaScriptDOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</id>
    <published>2020-10-28T01:52:53.368Z</published>
    <updated>2020-10-29T07:31:46.752Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DOM事件, 事件流</p></blockquote><a id="more"></a><h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><blockquote><p>事件是指JavaScript与HTML交互的基础.要实现用户与页面的交互,先要对目标元素绑定特定的事件,设置事件处理函数,用户触发事件,事件处理函数执行,产生交互效果</p></blockquote><h4 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h4><p>DOM 级别分为四个级别：DOM0 级、DOM1 级、DOM2 级、DOM3 级；<br><img src="https://s1.ax1x.com/2020/10/28/B1JoY4.md.jpg" alt="B1JoY4.md.jpg"></p><p>DOM事件分为三个级别:<br>DOM0 级事件</p><pre><code>&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;/button&gt;&lt;script&gt;    var btn = document.getElementById(&#39;btn&#39;)    btn.onclick = function() &#123;        console.log(&#39;Hello World&#39;)    &#125;    // btn.onclick = null // 解绑事件&lt;/script&gt;</code></pre><blockquote><p>   缺点：无法设置多个事件处理函数</p></blockquote><p>DOM2 级事件</p><pre><code>&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;/button&gt;&lt;script&gt;    var btn = document.getElementById(&#39;btn&#39;);        btn.addEventListener(&#39;click&#39;, showFn, false)    btn.addEventListener(&#39;click&#39;, showFn2, false)    // btn.removeEventListener(&#39;click&#39;, showFn, false) // 解绑事件     function showFn() &#123;        alert(&#39;Hello World&#39;);    &#125;     function showFn2() &#123;        alert(&#39;Hello World2&#39;);    &#125; &lt;/script&gt;</code></pre><blockquote><p>可以为事件设置多个事件处理函数，可以通过第三个参数 ( useCapture ) 设置在什么阶段执行事件处理函数，默认是 false， 即在事件冒泡阶段执行事件处理函数。</p></blockquote><blockquote><p>需要注意的是在 IE8 及以下版本需要用 attachEvent 和 detachEvent 实现，只有两个参数，事件名需要以 on 开头，只支持在事件冒泡阶段执行事件处理函数。</p></blockquote><p>DOM3 级事件</p><blockquote><p>DOM3 级事件是在 DOM2 级事件的基础上添加了更多的事件类型，允许自定义事件。</p></blockquote><p>UI事件，当用户与页面上的元素交互时触发，如：load、scroll<br>焦点事件，当元素获得或失去焦点时触发，如：blur、focus<br>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup<br>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel<br>文本事件，当在文档中输入文本时触发，如：textInput<br>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress<br>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart<br>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</p><pre><code>// 自定义事件var event = new Event(&#39;test&#39;)// 给元素绑定事件domElement.addEventListener(&#39;test&#39;, function() &#123;    console.log(&#39;event test&#39;)&#125;,)// 触发事件setTimeout(function() &#123;    domElement.dispatchEvent(event)&#125;, 1000)</code></pre><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><blockquote><p>事件流又称为事件传播，描述的是从<strong>页面中接收事件的顺序</strong>。</p><p>DOM2 级事件规定事件流包括三个阶段: </p><ul><li>事件捕获(capturing phase)</li><li>目标事件(target phase)</li><li>事件冒泡(bubbling phase)</li></ul><p>发生的顺序是：事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段</p></blockquote><p><img src="https://s1.ax1x.com/2020/10/28/B1tIz9.png" alt="B1tIz9.png"></p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><blockquote><p>​    事件起始元素逐级向上传播</p></blockquote><pre><code>&lt;style&gt;  #parent &#123;      width: 200px;      height: 200px;      background-color: green;  &#125;  #child &#123;      width: 100px;      height: 100px;      background-color: yellow;  &#125;&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt;  &lt;div id=&quot;child&quot;&gt;目标元素&lt;/div&gt;  父级元素&lt;/div&gt;&lt;script&gt;  var parent = document.getElementById(&#39;parent&#39;)  var child = document.getElementById(&#39;child&#39;)  parent.addEventListener(&#39;click&#39;, function(e) &#123;      console.log(&#39;parent bubbling&#39;)  &#125;, false)  child.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;target bubbling&#39;)  &#125;, false)  document.body.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;body bubbling&#39;)  &#125;, false)  document.documentElement.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;html bubbling&#39;)  &#125;, false)  document.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;document bubbling&#39;)  &#125;, false)  window.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;window bubbling&#39;)  &#125;, false)&lt;/script&gt;</code></pre><p>运行结果：</p><p><img src="https://s1.ax1x.com/2020/10/28/B1UStU.gif" alt="B1UStU.gif"></p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><blockquote><p>​    事件按 window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素 的方向向下层元素传递。</p></blockquote><pre><code>&lt;style&gt;  #parent &#123;      width: 200px;      height: 200px;      background-color: green;  &#125;  #child &#123;      width: 100px;      height: 100px;      background-color: yellow;  &#125;&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt;  &lt;div id=&quot;child&quot;&gt;目标元素&lt;/div&gt;  父级元素&lt;/div&gt;&lt;script&gt;  var parent = document.getElementById(&#39;parent&#39;)  var child = document.getElementById(&#39;child&#39;)  parent.addEventListener(&#39;click&#39;, function(e) &#123;      console.log(&#39;parent capture&#39;)  &#125;, true)  child.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;target capture&#39;)  &#125;, true)  document.body.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;body capture&#39;)  &#125;, true)  document.documentElement.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;html capture&#39;)  &#125;, true)  document.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;document capture&#39;)  &#125;, true)  window.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;window capture&#39;)  &#125;, true)&lt;/script&gt;</code></pre><p>运行结果:</p><p><img src="https://s1.ax1x.com/2020/10/28/B1UCp4.gif" alt="B1UCp4.gif"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;DOM事件, 事件流&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="DOM事件事件流" scheme="https://juntengma.github.io/tags/DOM%E4%BA%8B%E4%BB%B6%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>原型,原型链</title>
    <link href="https://juntengma.github.io/2020/10/26/JavaScript/JavaScript%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://juntengma.github.io/2020/10/26/JavaScript/JavaScript%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-10-26T14:36:07.474Z</published>
    <updated>2020-11-04T08:21:17.467Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​    原型原型链</p></blockquote><a id="more"></a><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识:"></a>前置知识:</h3><ul><li><p>js分为函数对象和普通对象,,每个对象都有<code>_proto_</code>属性,但是只有函数对象才有<code>prototype</code>属性</p></li><li><p>Object,Function都是js内置函数,类似的还有Array , RegExp , Date , Boolean , Nuber , String </p></li><li><p><code>_porto_</code>,<code>constructor</code>属性是<strong>对象</strong>所独有的</p></li><li><p><code>prototype</code>属性是<strong>函数</strong>所独有的</p></li><li><p>函数也是对象的一种,所以函数中也有<code>_protot_</code>和<code>constructor</code></p></li></ul><h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><pre><code>function Peron() &#123; &#125;var person = new Person()person.name = &#39;kevin&#39;console.log(person.name)</code></pre><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>每个函数都有<code>prototype</code>属性</p><pre><code>function Person() &#123; &#125;Person.prototype.name = &#39;kavin&#39;var person1 = new Person()var person2 = new Person()console.log(person1.name); //kavinconsole.log(person2.name); //kavin</code></pre><ul><li>函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。</li><li>那什么是原型呢？每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中继承属性</li></ul><p><strong>构造函数和实例原型之间的关系</strong></p><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png"></p><h3 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a><code>_proto_</code></h3><p>每一个js对象都有一个属性,就是<code>_Proto_</code>,这个属性会指向该对象的原型</p><pre><code>function Person() &#123; &#125;var person = new Person()console.log(person.__proto__ === Person.prototype); //true</code></pre><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png"></p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>consttructor指向该构造函数本身,即</p><pre><code>Person.prototype.constructor = Person</code></pre><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png"></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a><a href="https://segmentfault.com/a/1190000008959943">原型链</a></h3><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;​    原型原型链&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="原型原型链" scheme="https://juntengma.github.io/tags/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>浏览器解析js流程</title>
    <link href="https://juntengma.github.io/2020/10/26/JavaScript/JavaScript%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/"/>
    <id>https://juntengma.github.io/2020/10/26/JavaScript/JavaScript%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B/</id>
    <published>2020-10-26T10:14:39.943Z</published>
    <updated>2020-10-29T03:49:55.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>浏览器解析js流程</p></blockquote><a id="more"></a><h4 id="JS解析"><a href="#JS解析" class="headerlink" title="JS解析"></a>JS解析</h4><p><a href="https://imgchr.com/i/BufjDe"><img src="https://s1.ax1x.com/2020/10/26/BufjDe.png" alt="BufjDe.png"></a></p><p>js解析是由浏览器的就是解析引擎完成的.</p><p>js是单线程运行,也就是说同时只能做一件事,所有任务都需要排队,</p><p>为了解决某些任务比较耗时,需要一种机制来使其可以执行排在后面的任务,就出现了同步任务和异步任务</p><p>JS执行机制可以看做一个主线程加上一个任务队列.</p><p>同步任务就是主线程上面执行的任务 , 异步任务就是放在任务队列的任务</p><p>所有的同步任务都在主线程上面执行,形成一个执行栈</p><p>异步任务有了运行结果就会在任务队列中放置一个事件,脚本运行时依次运行执行栈,然后会从任务队列中提取事件,</p><p>运行任务队列中的任务,该过程是不断重复的,所以又叫做事件循环(Event loop)</p><ul><li>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。</li><li>请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。</li><li>原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。</li><li>CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;浏览器解析js流程&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="浏览器" scheme="https://juntengma.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="https://juntengma.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面加载发生了什么</title>
    <link href="https://juntengma.github.io/2020/10/26/JavaScript/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>https://juntengma.github.io/2020/10/26/JavaScript/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2020-10-26T06:38:03.324Z</published>
    <updated>2020-11-02T09:02:45.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从输入URL到页面加载发生了什么</p></blockquote><p>[TOC]</p><a id="more"></a><p>总体来说分为以下几个过程:</p><ul><li>[DNS解析](### DNS解析)</li><li>TCP连接</li><li>[发送HTTP请求](### HTTPS协议)</li><li>[服务器处理请求并返回HTTP报文](### 服务器处理请求并返回HTTP报文)</li><li>[浏览器解析渲染页面](### 浏览器解析渲染页面)</li><li>连接结束</li></ul><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>DNS解析的过程就是在寻找哪台机器上有你需要的资源的全过程.<br>当你在浏览器中输入一个地址时,将网址转换为IP的过程叫做DNS解析</p><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS解析本质上是一个递归查询的过程<br><a href="https://imgchr.com/i/BuniZV"><img src="https://s1.ax1x.com/2020/10/26/BuniZV.png" alt="BuniZV.png"></a></p><p>上图是查找<code>www.google.com</code>这个网址的过程</p><ol><li>在<code>本地域名服务器</code>中查询IP地址–&gt;无</li><li><code>本地域名服务器</code>向<code>根域名服务器</code>发送请求–&gt;无</li><li><code>本地域名服务器</code> 向<code>COM顶级域名服务器</code>发送请求–&gt;无</li><li>……</li><li>最后本地服务器得到Google的IP的字号并缓存到本地,功下次使用</li></ol><p>由上可以看出网址解析是一个 从右到左的过程:<br><code>com</code> –&gt; <code>google.com</code> –&gt; <code>www.google.com</code><br>根域名服务器呢?<br>默认情况下所有网址最后一位都是. , 即<code>www.google.com.</code>,方便用户一般都会省略,浏览器在请求DNS的时候会自动加上,<br>即NDS解析流程:<br><code>.</code>–&gt;<code>com.</code>–&gt;<code>google.com.</code>–&gt;<code>www.google.com.</code></p><h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3><ul><li>HTTP报文是包裹在tcp报文中发送的,服务端的吼道TCP报文时会解包提取出HTTP报文,但是该过程存在一定风险,HTTP报文是明文,如果中间被截取的话会存在一些信息泄露的风险</li><li>HTTPS协议本质就是HTTP+SSL,在HTTP报文进入TCP报文之前,先使用SSL报文进行加密.从网络层的结构看它位于HTTP协议与TCP协议之间<br><a href="https://imgchr.com/i/BunpMn"><img src="https://s1.ax1x.com/2020/10/26/BunpMn.png" alt="BunpMn.png"></a></li></ul><p><strong>HTTPS过程</strong><br>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TSL/SSL握手),在握手的过程中将确立对方家里传输数据的密码信息.TLS/SSL使用了非对称加密,对称加密以及hash等.</p><p>HTTPS相对于HTTP,虽然提供了安全保证,但势必会造成一些时间上的损耗,如握手和加密等过程,使用前需要做好安全和性能方面的权衡<br><strong>HTTP请求</strong><br>http请求主要发生在客户端.发送http请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080,HTTPS协议443)<br>http请求报文由三部分组成</p><ul><li>请求行 ( 常用方法有get,post,put,delete…等)</li><li>请求报头(请求报头允许客户端向度武器传递请求的附加信息和客户端自身的信息)</li><li>请求正文(客户端向服务端传递的数据)<h3 id="服务器处理请求并返回HTTP报文"><a href="#服务器处理请求并返回HTTP报文" class="headerlink" title="服务器处理请求并返回HTTP报文"></a>服务器处理请求并返回HTTP报文</h3>HTTP响应报文也是由三部分组成: <strong>状态码</strong>, <strong>响应报头</strong>和<strong>响应报文</strong>。</li></ul><p><strong>状态码</strong><br>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p><ul><li>1xx:指示信息 - 表示请求已接收,继续处理</li><li>2xx:成功,表示请求已被成功接收,理解,处理</li><li>3xx:重定向 -  要完成请求必须进行更进一步的操作</li><li>4xx:客户端错误 - 请求有语法错误或请求无法实现.</li><li>5xx:服务端错误 - 服务器未能实现合法请求</li></ul><p><strong>常见错误码:</strong></p><ul><li>200:请求成功</li><li>204:无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>301:永久移动。请求的资源已被永久的重定向到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302:临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>304:未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>400:客户端请求的语法错误，服务器无法理解</li><li>401:请求要求用户的身份认证</li><li>403:服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404:服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>422:请求格式正确，但是由于含有语义错误，无法响应。</li><li>500:服务器内部错误，无法完成请求</li></ul><h3 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h3><p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。</p><p>`<a href="https://imgchr.com/i/BufqgK"><img src="https://s1.ax1x.com/2020/10/26/BufqgK.png" alt="BufqgK.png"></a></p><p>浏览器是一个边解析边渲染的过程.</p><p>首先在浏览器解析HTML文件构建DOM树,然后解析css文件构建渲染树,等到渲染完成后,浏览器开封市布局渲染树并将其绘制到屏幕上.</p><p>该过程涉及到两个概念 : <strong>重绘</strong>,<strong>回流</strong></p><ul><li>**回流:**DOM节点中的各个元素都是以盒模型的形式存在,需要浏览器来计算其位置和大小等,该过程叫做回流</li><li>**重绘:**当盒模型的位置,大小以及其他属性,如颜色,字体等确定下来之后,浏览器就开始绘制内容,该过程叫做重绘</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从输入URL到页面加载发生了什么&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="浏览器" scheme="https://juntengma.github.io/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="https://juntengma.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>[object Object]</title>
    <link href="https://juntengma.github.io/2020/10/26/TypeScript/TypeScript/"/>
    <id>https://juntengma.github.io/2020/10/26/TypeScript/TypeScript/</id>
    <published>2020-10-26T04:23:04.617Z</published>
    <updated>2020-10-29T04:31:47.705Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
