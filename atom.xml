<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>June&#39;s Blog</title>
  
  
  <link href="https://juntengma.github.io/atom.xml" rel="self"/>
  
  <link href="https://juntengma.github.io/"/>
  <updated>2020-11-26T07:33:47.637Z</updated>
  <id>https://juntengma.github.io/</id>
  
  <author>
    <name>June</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>a标签的url怎么会乱码嘞？？？？</title>
    <link href="https://juntengma.github.io/2020/11/26/JavaScript/JavaScript-a%E6%A0%87%E7%AD%BE%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://juntengma.github.io/2020/11/26/JavaScript/JavaScript-a%E6%A0%87%E7%AD%BE%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-25T16:00:00.000Z</published>
    <updated>2020-11-26T07:33:47.637Z</updated>
    
    <content type="html"><![CDATA[<p>最近写博客发现自己博客链接居然是一堆乱码 ，这哪是我忍受的了的， 没注意还好， 注意到了怎么看怎么碍眼 ，<br> 类似下面这样👿👿👿👿👿：<br><img src="https://s3.ax1x.com/2020/11/26/D0M9N8.png"></p><p>具体百度过程😁和调试过程🙄（调试个棒槌）就不细说了 ， 这里是我得到的解决方案 ：<br>通过<code>decodeURI()</code>对链接进行解码 ， 我是这么写的</p><pre><code class="ejs"> &lt;a href=&quot;&lt;%= decodeURI(page.permalink) %&gt;&quot; target=&quot;_blank&quot;&gt;    &lt;%= decodeURI(page.permalink) %&gt;  &lt;/a&gt;</code></pre><p>所以最后我的链接就可以变回我需要的样子：<br><img src="https://s3.ax1x.com/2020/11/26/D0QdZq.png"></p><p>说到这里就有人问我了：马老师 ， 你这个 <code>decodeURI</code> 是干肾么用的呀？</p><p>我就啪的一下，很快啊~ ，给你甩出一个别人写的博客 <a href="https://segmentfault.com/a/1190000013236956">JS对url进行编码和解码（三种方式）</a> , 并告诉你这个知识点我也是刚学从他这边学的</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近写博客发现自己博客链接居然是一堆乱码 ，这哪是我忍受的了的， 没注意还好， 注意到了怎么看怎么碍眼 ，&lt;br&gt; 类似下面这样👿👿👿👿👿：&lt;br&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/D0M9N8.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体百度过程😁和调试过程🙄（调试个棒槌）就不细说了 ， 这里是我得到的解决方案 ：&lt;br&gt;通过&lt;code&gt;decodeURI()&lt;/code&gt;对链接进行解码 ， 我是这么写的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;ejs&quot;&gt; &amp;lt;a href=&amp;quot;&amp;lt;%= decodeURI(page.permalink) %&amp;gt;&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;
    &amp;lt;%= decodeURI(page.permalink) %&amp;gt;
  &amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以最后我的链接就可以变回我需要的样子：&lt;br&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/26/D0QdZq.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;说到这里就有人问我了：马老师 ， 你这个 &lt;code&gt;decodeURI&lt;/code&gt; 是干肾么用的呀？&lt;/p&gt;
&lt;p&gt;我就啪的一下，很快啊~ ，给你甩出一个别人写的博客 &lt;a href=&quot;https://segmentfault.com/a/1190000013236956&quot;&gt;JS对url进行编码和解码（三种方式）&lt;/a&gt; , 并告诉你这个知识点我也是刚学从他这边学的&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>自定义webpack配置</title>
    <link href="https://juntengma.github.io/2020/11/23/React/%E8%87%AA%E5%AE%9A%E4%B9%89webpack%E9%85%8D%E7%BD%AE/"/>
    <id>https://juntengma.github.io/2020/11/23/React/%E8%87%AA%E5%AE%9A%E4%B9%89webpack%E9%85%8D%E7%BD%AE/</id>
    <published>2020-11-23T07:29:16.000Z</published>
    <updated>2020-11-23T07:59:55.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="create-react-app-自定义配置webpack"><a href="#create-react-app-自定义配置webpack" class="headerlink" title="create-react-app 自定义配置webpack"></a>create-react-app 自定义配置webpack</h1><h4 id="1、修改webpack配置文件，需要安装-react-app-rewired-customize-cra"><a href="#1、修改webpack配置文件，需要安装-react-app-rewired-customize-cra" class="headerlink" title="1、修改webpack配置文件，需要安装 react-app-rewired customize-cra"></a>1、修改webpack配置文件，需要安装 react-app-rewired customize-cra</h4><pre><code>yarn add react-app-rewired customize-cra -D</code></pre><h4 id="2、修改package-json文件"><a href="#2、修改package-json文件" class="headerlink" title="2、修改package.json文件"></a>2、修改package.json文件</h4><pre><code>&quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;react-app-rewired start&quot;,    &quot;build&quot;: &quot;react-app-rewired build&quot;,    &quot;test&quot;: &quot;react-app-rewired test --env=jsdom&quot;,    &quot;eject&quot;: &quot;react-scripts eject&quot;  &#125;,</code></pre><h4 id="3、在项目根目录新建config-overrides-js"><a href="#3、在项目根目录新建config-overrides-js" class="headerlink" title="3、在项目根目录新建config-overrides.js"></a>3、在项目根目录新建config-overrides.js</h4><pre><code>const &#123; override &#125; = require(&#39;customize-cra&#39;);module.exports = &#123;&#125;;</code></pre><h4 id="4、一些plugins"><a href="#4、一些plugins" class="headerlink" title="4、一些plugins"></a>4、一些plugins</h4><pre><code></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;create-react-app-自定义配置webpack&quot;&gt;&lt;a href=&quot;#create-react-app-自定义配置webpack&quot; class=&quot;headerlink&quot; title=&quot;create-react-app 自定义配置webpack&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>原型,原型链</title>
    <link href="https://juntengma.github.io/2020/11/20/JavaScript/07%20-%20JavaScript-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://juntengma.github.io/2020/11/20/JavaScript/07%20-%20JavaScript-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2020-11-26T07:47:58.947Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  原型,原型链</h4></blockquote><a id="more"></a><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识:"></a>前置知识:</h3><ul><li><p>js分为函数对象和普通对象,,每个对象都有<code>_proto_</code>属性,但是只有函数对象才有<code>prototype</code>属性</p></li><li><p>Object,Function都是js内置函数,类似的还有Array , RegExp , Date , Boolean , Nuber , String </p></li><li><p><code>_porto_</code>,<code>constructor</code>属性是<strong>对象</strong>所独有的</p></li><li><p><code>prototype</code>属性是<strong>函数</strong>所独有的</p></li><li><p>函数也是对象的一种,所以函数中也有<code>_protot_</code>和<code>constructor</code></p></li></ul><h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><pre><code>function Peron() &#123; &#125;var person = new Person()person.name = &#39;kevin&#39;console.log(person.name)</code></pre><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>每个函数都有<code>prototype</code>属性</p><pre><code>function Person() &#123; &#125;Person.prototype.name = &#39;kavin&#39;var person1 = new Person()var person2 = new Person()console.log(person1.name); //kavinconsole.log(person2.name); //kavin</code></pre><ul><li>函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。</li><li>那什么是原型呢？每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中继承属性</li></ul><p><strong>构造函数和实例原型之间的关系</strong></p><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png"></p><h3 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a><code>_proto_</code></h3><p>每一个js对象都有一个属性,就是<code>_Proto_</code>,这个属性会指向该对象的原型</p><pre><code>function Person() &#123; &#125;var person = new Person()console.log(person.__proto__ === Person.prototype); //true</code></pre><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png"></p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>consttructor指向该构造函数本身,即</p><pre><code>Person.prototype.constructor = Person</code></pre><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png"></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a><a href="https://segmentfault.com/a/1190000008959943">原型链</a></h3><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 原型,原型链
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="原型原型链" scheme="https://juntengma.github.io/tags/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>防抖节流及其应用场景</title>
    <link href="https://juntengma.github.io/2020/11/20/JavaScript/08.1%20-%20JavaScript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>https://juntengma.github.io/2020/11/20/JavaScript/08.1%20-%20JavaScript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2020-11-26T07:47:41.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  复习一下防抖节流及其应用场景</h4></blockquote><a id="more"></a><h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><p>在事件被触发的n秒后再执行回调,如果在这n秒内又被触发,则重新计时</p><pre><code>function debounse(fun, delay) &#123;    let timer;    // 设置一个 timer    return function (args) &#123;      let _this = this      let _args = args      clearTimeout(timer)      timer = setTimeout(function () &#123;        fun.call(_this, _args);      &#125;, delay);    &#125;  &#125;</code></pre><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p><pre><code>function throttle(fun, delay) &#123;    let last, timer    return function (args) &#123;      let _this = this      let _args = args      let now = +new Date()      if (last &amp;&amp; now &lt; last + delay) &#123;        clearTimeout(timer)        timer = setTimeout(function () &#123;          last = now          fun.apply(_this, _args)        &#125;, delay)      &#125; else &#123;        last = now        fun.apply(_this, _args)      &#125;    &#125;  &#125;</code></pre><h3 id="demo"><a href="#demo" class="headerlink" title="demo:"></a>demo:</h3><h5 id="模拟ajax请求"><a href="#模拟ajax请求" class="headerlink" title="模拟ajax请求"></a>模拟ajax请求</h5><pre><code>function ajax(params) &#123;    console.log(&#39;ajax request : &#39; + params)&#125;</code></pre><h5 id="普通input"><a href="#普通input" class="headerlink" title="普通input:"></a>普通input:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252be5c94d6b?imageslim"></p><h5 id="加入防抖"><a href="#加入防抖" class="headerlink" title="加入防抖:"></a>加入防抖:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4b429b56?imageslim"></p><h5 id="加入节流"><a href="#加入节流" class="headerlink" title="加入节流:"></a>加入节流:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4c1a9686?imageslim"></p><h3 id="demo代码"><a href="#demo代码" class="headerlink" title="demo代码"></a>demo代码</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  没有防抖的Input &lt;input type=&quot;text&quot; class=&quot;unDebounce&quot;&gt;  &lt;br&gt;  加入防抖的Input &lt;input type=&quot;text&quot; class=&quot;debounce&quot;&gt;  &lt;br&gt;  加入截留的Input &lt;input type=&quot;text&quot; class=&quot;htrottle&quot;&gt;&lt;/body&gt;&lt;script&gt;  function ajax(params) &#123;    console.log(&#39;ajax request : &#39; + params)  &#125;  let inputValue0 = document.querySelector(&#39;.unDebounce&#39;)  inputValue0.addEventListener(&#39;keyup&#39;, function (e) &#123;    ajax(e.target.value)  &#125;)  /**********************防抖********************************/  function debounse(fun, delay) &#123;    let timer;    // 设置一个 timer    return function (args) &#123;      let _this = this      // 取debounce执行作用域的this      let _args = args      clearTimeout(timer)      timer = setTimeout(function () &#123;        fun.call(_this, args);      &#125;, delay);    &#125;  &#125;  let inputValue1 = document.querySelector(&#39;.debounce&#39;)  let debounse_ajax = debounse(ajax, 500)  inputValue1.addEventListener(&#39;keyup&#39;, function (e) &#123;    debounse_ajax(e.target.value)  &#125;)  /**********************节流********************************/  function throttle(fun, delay) &#123;    let last, timer    return function (args) &#123;      let _this = this      let _args = args      let now = +new Date()      if (last &amp;&amp; now &lt; last + delay) &#123;        clearTimeout(timer)        timer = setTimeout(function () &#123;          last = now          fun.apply(_this, _args)        &#125;, delay)      &#125; else &#123;        last = now        fun.apply(_this, _args)      &#125;    &#125;  &#125;  let inputValue2 = document.querySelector(&#39;.htrottle&#39;)  let htrottle_ajax = throttle(ajax, 2000)  inputValue2.addEventListener(&#39;keyup&#39;, function (e) &#123;    htrottle_ajax(e.target.value)  &#125;)&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 复习一下防抖节流及其应用场景
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="防抖节流" scheme="https://juntengma.github.io/tags/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://juntengma.github.io/2020/11/19/TypeScript/Untitled/"/>
    <id>https://juntengma.github.io/2020/11/19/TypeScript/Untitled/</id>
    <published>2020-11-19T10:07:00.753Z</published>
    <updated>2020-11-19T10:28:15.521Z</updated>
    
    <content type="html"><![CDATA[<p>面试官你好,我的名字叫马俊腾,是一名web前端开发<br>目前工作3年, 对HTML,js,jq,框架之类的都比较熟悉<br>自己的特点: 心态好, 学习能力强, 对新技术比较敏感,愿意去学习新东西新知识,平时也会写写博客沉淀自身</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试官你好,我的名字叫马俊腾,是一名web前端开发&lt;br&gt;目前工作3年, 对HTML,js,jq,框架之类的都比较熟悉&lt;br&gt;自己的特点: 心态好, 学习能力强, 对新技术比较敏感,愿意去学习新东西新知识,平时也会写写博客沉淀自身&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://juntengma.github.io/2020/11/18/Safe/JWT%E9%89%B4%E6%9D%83/"/>
    <id>https://juntengma.github.io/2020/11/18/Safe/JWT%E9%89%B4%E6%9D%83/</id>
    <published>2020-11-18T02:39:37.578Z</published>
    <updated>2020-11-18T03:46:20.353Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT(JSON Web Token)"></a>JWT(JSON Web Token)</h4><h4 id="01-什么是JWT"><a href="#01-什么是JWT" class="headerlink" title="01/ 什么是JWT"></a>01/ 什么是JWT</h4><ul><li><p>JWT是JSON Web Token的缩写,是一种易用且无状态的鉴权方式</p></li><li><p>用于在各方之间以JSON对象安全传输信息。这些信息可以通过数字签名进行验证和信任。</p></li><li><p>简单来说就是server端把JSON数据经过加密做成Token,以授权给client端</p></li></ul><h4 id="02-栗子"><a href="#02-栗子" class="headerlink" title="02/ 栗子:"></a>02/ 栗子:</h4><p>当Client端登录完成以后，Server端要返回一个7天有效的token，那么对应的Python的样例代码会是这样的：<br>（<a href="https://link.zhihu.com/?target=https://github.com/jpadilla/pyjwt">使用了PyJWT包：pip install pyjwt</a>）</p><pre><code>import timeimport jwtexp = int(time.time()) + 86400 * 7  # 失效时间user = &#39;liriansu&#39;  # 用户表示key = &#39;hunter2&#39;  # 密钥payload = &#123;&#39;exp&#39;: exp, &#39;user&#39;: user&#125;  # JSON 数据token = jwt.encode(payload, key)print(token)# token可能会长这样子# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.EoKoMCjq_zGqUg5HDfqw4EN7EiG6gMjkUZle0uGJDGU</code></pre><p>然后Client端每次在authorization header或者是query string里带上token。<br>Server端收到请求的时候，<br>用<code>payload = jwt.decode(token, key)</code>验证权限就行了。<br>验证通过以后，payload中就是整个JSON数据。<br>理论上你可以往token payload里塞任何<strong>_非敏感</strong>_数据。</p><h4 id="03-使用场景"><a href="#03-使用场景" class="headerlink" title="03 / 使用场景"></a>03 / 使用场景</h4><ul><li><p>鉴权</p><p>用户一旦登录,后续的每个请求都需要携带jwt,允许该用户访问该令牌允许的路由,服务和资源.</p><p>单点登录是当前使用最广泛的JWT的一项功能,因为开销较小,并且能够跨域使用</p></li><li><p>信息交换</p><p>JWT是在各方之间安全传输信息的好方式,因为JWT可以签名：例如使用公钥/私钥对，所以可以确定发件人是他们自称的人。此外，由于使用标头和有效载荷计算签名，因此您还可以验证内容是否未被篡改。</p></li></ul><h4 id="04-JWT结构"><a href="#04-JWT结构" class="headerlink" title="04 /  JWT结构"></a>04 /  JWT结构</h4><p><code> eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.EoKoMCjq_zGqUg5HDfqw4EN7EiG6gMjkUZle0uGJDGU</code></p><p>如上所示,JWT输出的是三个由点分隔的<code>xxxx.yyyy.zzzz</code>Base64-URL字符串，可以在HTML和HTTP环境中轻松传递，</p><p>他们分别代表:</p><ul><li>Header<ul><li>Header通常由两部分组成：令牌的类型，即JWT。和常用的散列算法</li><li>Header部分的JSON被Base64Url编码，形成JWT的第一部分。</li></ul></li><li>Payload<ul><li>存放沟通讯息的地方</li><li>Registered claims（注册声明）</li><li>Public claims（公开声明）</li><li>Private claims（私有声明）</li></ul></li><li>Signature<ul><li>用来验证发送请求者身份，由前两部分加密形成。</li></ul></li></ul><h4 id="04-所以综合来说，"><a href="#04-所以综合来说，" class="headerlink" title="04/ 所以综合来说，"></a>04/ 所以综合来说，</h4><p>假如使用JWT作为鉴权方式，<br>有以下几个特性：</p><ol><li>Client端不用管任何加密/解密，只用存token，在请求里面带上就行了。</li><li>Server端可以实现不依赖外部存储鉴权，所有的数据都丢在token里。</li><li>也就是说鉴权这一步不需要File/MySQL/Redis之类的数据库，也能知道用户身份。</li><li>因为token带失效时间，所以需要在失效前/后再刷新token。</li></ol><h4 id="05-常见问题"><a href="#05-常见问题" class="headerlink" title="05/ 常见问题"></a>05/ 常见问题</h4><h5 id="①-JWT-安全嗎"><a href="#①-JWT-安全嗎" class="headerlink" title="① JWT 安全嗎?"></a>① JWT 安全嗎?</h5><p>Base64编码方式是可逆的，也就是透过编码后发放的Token内容是可以被解析的。一般而言，我们都不建议在有效载荷内放敏感讯息，比如使用者的密码。</p><h5 id="②-JWT-Payload-內容可以被伪造嗎？"><a href="#②-JWT-Payload-內容可以被伪造嗎？" class="headerlink" title="② JWT Payload 內容可以被伪造嗎？"></a>② JWT Payload 內容可以被伪造嗎？</h5><p>JWT其中的一个组成内容为Signature，可以防止通过Base64可逆方法回推有效载荷内容并将其修改。因为Signature是经由Header跟Payload一起Base64组成的。</p><h5 id="③-如果我的-Cookie-被窃取了，那不就表示第三方可以做-CSRF-攻击"><a href="#③-如果我的-Cookie-被窃取了，那不就表示第三方可以做-CSRF-攻击" class="headerlink" title="③ 如果我的 Cookie 被窃取了，那不就表示第三方可以做 CSRF 攻击?"></a>③ 如果我的 Cookie 被窃取了，那不就表示第三方可以做 CSRF 攻击?</h5><p>是的，Cookie丢失，就表示身份就可以被伪造。故官方建议的使用方式是存放在LocalStorage中，并放在请求头中发送。</p><h5 id="④-空间及长度问题？"><a href="#④-空间及长度问题？" class="headerlink" title="④ 空间及长度问题？"></a>④ 空间及长度问题？</h5><p>JWT Token通常长度不会太小，特别是Stateless JWT Token，把所有的数据都编在Token里，很快的就会超过Cookie的大小（4K）或者是URL长度限制。</p><h5 id="⑤-Token失效问题？"><a href="#⑤-Token失效问题？" class="headerlink" title="⑤ Token失效问题？"></a>⑤ Token失效问题？</h5><p>无状态JWT令牌（Stateless JWT Token）发放出去之后，不能通过服务器端让令牌失效，必须等到过期时间过才会失去效用。</p><p>假设在这之间Token被拦截，或者有权限管理身份的差异造成授权Scope修改，都不能阻止发出去的Token失效并要求使用者重新请求新的Token。</p><h4 id="06-JWT使用建议"><a href="#06-JWT使用建议" class="headerlink" title="06/ JWT使用建议"></a>06/ JWT使用建议</h4><ul><li>不要存放敏感信息在Token里。</li><li>Payload中的exp时效不要设定太长。</li><li>开启Only Http预防XSS攻击。</li><li>如果担心重播攻击（replay attacks ）可以增加jti（JWT ID），exp（有效时间） Claim。</li><li>在你的应用程序应用层中增加黑名单机制，必要的时候可以进行Block做阻挡（这是针对掉令牌被第三方使用窃取的手动防御）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;JWT-JSON-Web-Token&quot;&gt;&lt;a href=&quot;#JWT-JSON-Web-Token&quot; class=&quot;headerlink&quot; title=&quot;JWT(JSON Web Token)&quot;&gt;&lt;/a&gt;JWT(JSON Web Token)&lt;/h4&gt;&lt;h4 id=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript作用域&amp;可执行上下文</title>
    <link href="https://juntengma.github.io/2020/11/16/JavaScript/03%20-%20JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://juntengma.github.io/2020/11/16/JavaScript/03%20-%20JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2020-11-15T16:00:00.000Z</published>
    <updated>2020-11-26T07:48:45.076Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript深入 - 作用域相关问题</p></blockquote><a id="more"></a><h3 id="01-什么是作用域"><a href="#01-什么是作用域" class="headerlink" title="01 / 什么是作用域?"></a>01 / 什么是作用域?</h3><p><strong>作用域是指程序源代码中定义变量的区域:</strong></p><ul><li>作用域规定了当前执行代码对变量的访问权限</li><li>JavaScript采用词法作用域(静态作用域)</li></ul><h3 id="02-词法作用域和静态作用域的区别"><a href="#02-词法作用域和静态作用域的区别" class="headerlink" title="02 / 词法作用域和静态作用域的区别?"></a>02 / 词法作用域和静态作用域的区别?</h3><ul><li>静态作用域:    函数的作用域在函数定义的时候就已经决定了</li><li>动态作用域: 函数的作用域在函数调用的时候才决定</li></ul><h3 id="03-作用域包含两种"><a href="#03-作用域包含两种" class="headerlink" title="03 / 作用域包含两种:"></a>03 / 作用域包含两种:</h3><ul><li>全局作用域<ul><li>最外层函数和在最外层函数外面定义的变量拥有全局作用域</li><li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li><li>所有 window 对象的属性拥有全局作用域</li></ul></li><li>函数作用域<ul><li>指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到</li></ul></li><li>块级作用域<ul><li>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;JavaScript深入 - 作用域相关问题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="作用域&amp;可执行上下文" scheme="https://juntengma.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>浏览器解析js流程</title>
    <link href="https://juntengma.github.io/2020/11/16/JavaScript/05%20-%20JavaScript-%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF(Event%20Loop)/"/>
    <id>https://juntengma.github.io/2020/11/16/JavaScript/05%20-%20JavaScript-%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF(Event%20Loop)/</id>
    <published>2020-11-15T16:00:00.000Z</published>
    <updated>2020-11-26T07:48:25.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  浏览器解析js流程</h4></blockquote><a id="more"></a><h4 id="JS解析"><a href="#JS解析" class="headerlink" title="JS解析"></a>JS解析</h4><p><a href="https://imgchr.com/i/BufjDe"><img src="https://s1.ax1x.com/2020/10/26/BufjDe.png" alt="BufjDe.png"></a></p><p>js解析是由浏览器    </p><p>js是单线程运行,也就是说同时只能做一件事,所有任务都需要排队,</p><p>为了解决某些任务比较耗时,需要一种机制来使其可以执行排在后面的任务,就出现了同步任务和异步任务</p><p>JS执行机制可以看做一个主线程加上一个任务队列.</p><p>同步任务就是主线程上面执行的任务 , 异步任务就是放在任务队列的任务</p><p>所有的同步任务都在主线程上面执行,形成一个执行栈</p><p>异步任务有了运行结果就会在任务队列中放置一个事件,脚本运行时依次运行执行栈,然后会从任务队列中提取事件,</p><p>运行任务队列中的任务,该过程是不断重复的,所以又叫<strong>做事件循环</strong>(Event loop)</p><ul><li>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。</li><li>请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。</li><li>原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。</li><li>CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 浏览器解析js流程
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="浏览器解析js流程" scheme="https://juntengma.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90js%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面加载发生了什么</title>
    <link href="https://juntengma.github.io/2020/11/16/JavaScript/06%20-%20%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>https://juntengma.github.io/2020/11/16/JavaScript/06%20-%20%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2020-11-15T16:00:00.000Z</published>
    <updated>2020-11-26T07:48:12.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  从输入URL到页面加载发生了什么???</h4></blockquote><a id="more"></a><p>总体来说分为以下几个过程:</p><ul><li><a href="#01-dns%E8%A7%A3%E6%9E%90">01/ DNS解析</a><ul><li><a href="#dns%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B">DNS解析过程</a></li></ul></li><li><a href="#02-tcp%E8%BF%9E%E6%8E%A5">02 /TCP连接</a></li><li><a href="#03-%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82">03 /发送HTTP请求</a></li><li><a href="#04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%B9%B6%E8%BF%94%E5%9B%9Ehttp%E6%8A%A5%E6%96%87">04 /服务器处理请求并返回HTTP报文</a></li><li><a href="#05-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2">05 /浏览器解析渲染页面</a></li></ul><h3 id="01-DNS解析"><a href="#01-DNS解析" class="headerlink" title="01/ DNS解析"></a>01/ DNS解析</h3><p>DNS解析的过程就是在寻找哪台机器上有你需要的资源的全过程.<br>当你在浏览器中输入一个地址时,将网址转换为IP的过程叫做DNS解析</p><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS解析本质上是一个递归查询的过程</p><p><img src="https://s3.ax1x.com/2020/11/16/DAFZeU.png"></p><p>上图是查找<code>www.google.com</code>这个网址的过程</p><ol><li>在<code>本地域名服务器</code>中查询IP地址–&gt;无</li><li><code>本地域名服务器</code>向<code>根域名服务器</code>发送请求–&gt;无</li><li><code>本地域名服务器</code> 向<code>COM顶级域名服务器</code>发送请求–&gt;无</li><li>……</li><li>最后本地服务器得到Google的IP的字号并缓存到本地,功下次使用</li></ol><p>由上可以看出网址解析是一个 从右到左的过程:<br><code>com</code> –&gt; <code>google.com</code> –&gt; <code>www.google.com</code><br>根域名服务器呢?<br>默认情况下所有网址最后一位都是. , 即<code>www.google.com.</code>,方便用户一般都会省略,浏览器在请求DNS的时候会自动加上,<br>即NDS解析流程:<br><code>.</code>–&gt;<code>com.</code>–&gt;<code>google.com.</code>–&gt;<code>www.google.com.</code></p><h3 id="02-TCP连接"><a href="#02-TCP连接" class="headerlink" title="02 /TCP连接"></a>02 /TCP连接</h3><p>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p><p>三次握手:</p><ul><li>主机A向主机B发送TCP连接请求数据包</li><li>主机B收到请求后，会发回连接确认数据包。 </li><li>第三次，主机A收到主机B的确认报文后，还需作出确认，即发送一个序列号seq(A)=x+1；确认号为ack(A)=y+1的报文；</li></ul><p>四次挥手:(假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下)</p><ul><li>客户端向服务端发送关闭链接的请求</li><li>服务器收到请求之后,回复这个请求并确认</li><li>服务端也发送一个关闭链接的请求给客户端</li><li>客户端收到请求之后确认关闭然后断开tcp链接</li></ul><h3 id="03-发送HTTP请求"><a href="#03-发送HTTP请求" class="headerlink" title="03 /发送HTTP请求"></a>03 /发送HTTP请求</h3><ul><li>HTTP报文是包裹在tcp报文中发送的,服务端收到TCP报文时会解包提取出HTTP报文,但是该过程存在一定风险,HTTP报文是明文,如果中间被截取的话会存在一些信息泄露的风险</li><li>HTTPS协议本质就是HTTP+SSL,在HTTP报文进入TCP报文之前,先使用SSL报文进行加密.从网络层的结构看它位于HTTP协议与TCP协议之间<br><a href="https://imgchr.com/i/BunpMn"><img src="https://s1.ax1x.com/2020/10/26/BunpMn.png" alt="BunpMn.png"></a></li></ul><p><strong>HTTPS过程:</strong></p><p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TSL/SSL握手),在握手的过程中将确立对方家里传输数据的密码信息.TLS/SSL使用了非对称加密,对称加密以及hash等.</p><p>HTTPS相对于HTTP,虽然提供了安全保证,但势必会造成一些时间上的损耗,如握手和加密等过程,使用前需要做好安全和性能方面的权衡</p><p><strong>HTTP请求:</strong></p><p>http请求主要发生在客户端.发送http请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080,HTTPS协议443)<br>http请求报文由三部分组成</p><ul><li><p>请求行 ( 常用方法有get,post,put,delete…等)</p></li><li><p>请求报头(请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息)</p><p><img src="https://s3.ax1x.com/2020/11/16/DAklNQ.png"></p><blockquote><p>上图是使用Chrome开发者工具截取的对百度的HTTP请求以及响应报文，从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</p></blockquote></li><li><p>请求正文(客户端向服务端传递的数据)</p><blockquote><p>上图是使用Chrome开发者工具截取的对百度的HTTP请求以及响应报文，从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</p></blockquote><h3 id="04-服务器处理请求并返回HTTP报文"><a href="#04-服务器处理请求并返回HTTP报文" class="headerlink" title="04 /服务器处理请求并返回HTTP报文"></a>04 /服务器处理请求并返回HTTP报文</h3><p>HTTP响应报文也是由三部分组成: <strong>状态码</strong>, <strong>响应报头</strong>和<strong>响应报文</strong>。</p></li></ul><p><strong>状态码</strong><br>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p><ul><li>1xx:指示信息 - 表示请求已接收,继续处理</li><li>2xx:成功 - 表示请求已被成功接收,理解,处理</li><li>3xx:重定向 -  要完成请求必须进行更进一步的操作</li><li>4xx:客户端错误 - 请求有语法错误或请求无法实现.</li><li>5xx:服务端错误 - 服务器未能实现合法请求</li></ul><p><strong>常见错误码:</strong></p><ul><li>200:请求成功</li><li>204:无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>301:永久移动。请求的资源已被永久的重定向到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302:临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>304:未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>400:客户端请求的语法错误，服务器无法理解</li><li>401:请求要求用户的身份认证</li><li>403:服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404:服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>422:请求格式正确，但是由于含有语义错误，无法响应。</li><li>500:服务器内部错误，无法完成请求</li></ul><h3 id="05-浏览器解析渲染页面"><a href="#05-浏览器解析渲染页面" class="headerlink" title="05 /浏览器解析渲染页面"></a>05 /浏览器解析渲染页面</h3><p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。</p><p><img src="https://s3.ax1x.com/2020/11/16/DAAsIg.png"></p><p>浏览器是一个边解析边渲染的过程。</p><ul><li>首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</li><li>这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;</li><li>当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。</li><li>页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</li></ul><p>该过程涉及到两个概念 : <strong>重绘</strong>,<strong>回流</strong></p><ul><li>**回流:**DOM节点中的各个元素都是以盒模型的形式存在,需要浏览器来计算其位置和大小等,该过程叫做回流</li><li>**重绘:**当盒模型的位置,大小以及其他属性,如颜色,字体等确定下来之后,浏览器就开始绘制内容,该过程叫做重绘</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 从输入URL到页面加载发生了什么???
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="从输入URL到页面加载发生了什么" scheme="https://juntengma.github.io/tags/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://juntengma.github.io/2020/11/15/JavaScript/09%20-%20JavaScript-Promise/"/>
    <id>https://juntengma.github.io/2020/11/15/JavaScript/09%20-%20JavaScript-Promise/</id>
    <published>2020-11-14T16:00:00.000Z</published>
    <updated>2020-11-26T07:47:33.254Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4> 前端异步处理之 - Promise vs async/await</h4></blockquote><a id="more"></a><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="1-js回调地狱"><a href="#1-js回调地狱" class="headerlink" title="1/ js回调地狱"></a>1/ js回调地狱</h4><blockquote><p>在开发过程中我们经常遇到这种情况: </p><p>异步js或使用回调的js很难直观地得到正确的结果 , 一个异步函数的输出是另外一个异步函数的输入,如果嵌套层数过多，可读性和可以维护性都会变得很差，产生所谓的“回调地狱</p></blockquote><pre><code>let fs = require(&#39;fs&#39;)fs.readFile(&#39;./name.txt&#39;,&#39;utf8&#39;,function(err,data)&#123;  fs.readFile(data, &#39;utf8&#39;,function(err,data)&#123;    fs.readFile(data,&#39;utf8&#39;,function(err,data)&#123;      console.log(data);    &#125;)  &#125;)&#125;)</code></pre><p>总结一下回调地狱出现的原因:</p><ul><li><strong>嵌套调用</strong>，第一个函数的输出往往是第二个函数的输入；<ul><li><strong>处理多个异步请求并发</strong>，开发时往往需要同步请求最终的结果;</li></ul></li></ul><h4 id="2-怎么处理回调地狱"><a href="#2-怎么处理回调地狱" class="headerlink" title="2/ 怎么处理回调地狱"></a>2/ 怎么处理回调地狱</h4><ul><li><strong>消灭嵌套调用</strong>：通过 Promise 的链式调用可以解决(.then())；</li><li><strong>合并多个任务的请求结果</strong>：使用 Promise.all 获取合并多个任务的错误处理。</li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="1-什么是promise"><a href="#1-什么是promise" class="headerlink" title="1.什么是promise?"></a>1.什么是promise?</h4><p><img src="https://s3.ax1x.com/2020/11/13/DS4cZt.png"><br> 如上图所示,Promise是一个构造函数,身上有</p><ul><li><p>all()</p></li><li><p>reject()</p></li><li><p>resolve()几个方法,</p></li></ul><p>prototype上有</p><ul><li>then()</li><li>catch()等方法</li></ul><h4 id="2-Promise的特征"><a href="#2-Promise的特征" class="headerlink" title="2.Promise的特征"></a>2.Promise的特征</h4><ul><li>对象的状态不受外界影响,<code>Promise</code>对象代表一个异步操作，有下面这三种状态,只有异步操作可以决定当前是哪种状态<ul><li>pending(进行中)</li><li>fulfilled(成功)</li><li>rejected(失败)</li></ul></li><li>状态一旦改变, 结果就不再变化,Promise状态只可能会出现下面两种情况<ul><li>pending —&gt; fulfilled</li><li>pending —&gt; rejected</li></ul></li></ul><p><strong><code>Promise</code>的优点：</strong></p><p><strong>可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</strong></p><h4 id="3-Promise怎么创建"><a href="#3-Promise怎么创建" class="headerlink" title="3.Promise怎么创建?"></a>3.Promise怎么创建?</h4><ul><li><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 <code>JavaScript</code> 引擎提供，不用自己部署</li><li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li><li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code>变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li></ul><pre><code class="js">let promise = new Promise((resolve, reject) =&gt; &#123;  //此处执行一些异步操作（调用后台API，定时器等）  if (/*异步操作成功*/) &#123;    resolve(value);  &#125; else &#123;    reject(error)  &#125;&#125;)</code></pre><ul><li><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。</li><li>其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</li></ul><pre><code>promise.then(res=&gt;&#123;    //对于成功回调接受的数据做处理&#125;,err=&gt;&#123;    //对于失败的回调数据做处理&#125;)</code></pre><h4 id="4-实现一个符合PromiseA-规范的Promise"><a href="#4-实现一个符合PromiseA-规范的Promise" class="headerlink" title="4. 实现一个符合PromiseA+规范的Promise"></a>4. 实现一个符合PromiseA+规范的Promise</h4><p>该版本只能简单实现处理同步/异步函数, then的链式调用并没有真正实现…需要再做研究</p><pre><code>//1.先定义三个状态const PENDING = &quot;PENDING&quot;;const FULFILLED = &quot;FULFILLED&quot;;const REJECTED = &quot;REJECTED&quot;;//2.clss实例化一个promiseclass Promise &#123;  constructor(executor) &#123;    this.status = PENDING;    //存放成功状态    this.success = undefined;    //存放失败状态    this.error = undefined;    // 存放成功的回调    this.onResolvedCallbacks = [];    // 存放失败的回调    this.onRejectedCallbacks = [];        //3.实现resolve , reject    let resolve = (value) =&gt; &#123;      if (this.status === PENDING) &#123;        this.status = FULFILLED;        this.success = value;        //这句话的意思是把存储起来的异步回调也执行掉        this.onResolvedCallbacks.forEach(fn =&gt; fn());      &#125;    &#125;    let reject = (error) =&gt; &#123;      if (this.status === PENDING) &#123;        this.status = REJECTED;        this.error = error;        this.onRejectedCallbacks.forEach(fn =&gt; fn());      &#125;    &#125;     //异常捕获    try &#123;      executor(resolve, reject)    &#125; catch (error) &#123;      reject(error)    &#125;  &#125;    //4.实现then方法  then(onFulfilled, onRejected) &#123;    if (this.status === FULFILLED) &#123;      return onFulfilled(this.success)    &#125;    if (this.status === REJECTED) &#123;      return onRejected(this.error)    &#125;    if (this.status === PENDING) &#123;      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行      this.onResolvedCallbacks.push(() =&gt; &#123;        onFulfilled(this.success)      &#125;);      this.onRejectedCallbacks.push(() =&gt; &#123;        onRejected(this.error);      &#125;)    &#125;  &#125;&#125;//测试demolet promise = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(&#39;ok&#39;)  &#125;, 2000)&#125;).then((success) =&gt; &#123;  console.log(&#39;success&#39;, success)&#125;, (error) =&gt; &#123;  console.log(&#39;error&#39;)&#125;)// success ok</code></pre><h4 id="5-async-await"><a href="#5-async-await" class="headerlink" title="5. async/await"></a>5. async/await</h4><blockquote><p>一种相对Promise更为优雅的异步函数处理方案</p></blockquote><p>5.1    什么是async/await</p><ul><li><code>async</code>是异步的意思</li><li><code>await</code>有等待的意思</li><li><code>async</code>用于申明一个<code>function</code>是异步的，而<code>await</code> 用于等待一个异步方法执行完成。</li></ul><p>5.2     使用</p><pre><code>async getAjaxData()&#123;    let res = await sendAjax()&#125;</code></pre><p>5.3 注意事项</p><pre><code>- await操作符等的是一个返回的结果，那么如果是同步的情况，那就直接返回了。- 如果是异步的情况下，await会阻塞整一个流程，直到结果返回之后，才会继续下面的代码。阻塞代码是一个很可怕的事情，而async函数，会被包在一个promise中，异步去执行。所以await只能在async函数中使用，如果在正常程序中使用，会造成整个程序阻塞，得不偿失。</code></pre><h4 id="6-Promise-和-async-await区别"><a href="#6-Promise-和-async-await区别" class="headerlink" title="6.Promise 和 async/await区别"></a>6.Promise 和 async/await区别</h4><p>直接上代码</p><ul><li>Promise版本</li></ul><pre><code>function doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 = 300;    step1(time1)        .then(time2 =&gt; &#123;            return step2(time1, time2)                .then(time3 =&gt; [time1, time2, time3]);        &#125;)        .then(times =&gt; &#123;            const [time1, time2, time3] = times;            return step3(time1, time2, time3);        &#125;)        .then(result =&gt; &#123;            console.log(`result is $&#123;result&#125;`);            console.timeEnd(&quot;doIt&quot;);        &#125;);&#125;doIt();</code></pre><ul><li>async / await 版本</li></ul><pre><code>async function doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 = 300;    const time2 = await step1(time1);    const time3 = await step2(time1, time2);    const result = await step3(time1, time2, time3);    console.log(`result is $&#123;result&#125;`);    console.timeEnd(&quot;doIt&quot;);&#125;doIt();</code></pre><p>更详细的可以参考:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/288384170">&lt;&lt;你不知道的promise&gt;&gt;</a></li><li><a href="https://juejin.im/post/6844903843507994632">&lt;&lt;学习Promise基础及手写Promise&gt;&gt;</a></li><li><a href="https://juejin.im/post/6844903960910757902">&lt;&lt;理解async/await&gt;&gt;</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
前端异步处理之 - Promise vs async/await
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="Promise" scheme="https://juntengma.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝浅拷贝</title>
    <link href="https://juntengma.github.io/2020/11/15/JavaScript/JavaScript-%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://juntengma.github.io/2020/11/15/JavaScript/JavaScript-%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-11-14T16:00:00.000Z</published>
    <updated>2020-11-26T07:46:24.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  深拷贝浅拷贝</h4></blockquote><a id="more"></a><p><a href="https://juejin.im/post/6844903929705136141">https://juejin.im/post/6844903929705136141</a></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。</p><p>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><p>浅拷贝只拷贝一层属性,无法拷贝引用数据类型</p><ul><li><code>Object.assign(&#123;&#125;,obj)</code>浅拷贝object</li><li><code>newobj = &#123;...obj2&#125;</code>  展开运算符浅拷贝</li><li><code>Object.fromEntries( Object.entriens(obj) ) </code>通过生成迭代器,在通过迭代器生成对象</li><li><code>Object.create(&#123;&#125;,Object.getOwnPropertyDescriptors(obj))</code></li></ul><p><strong>简单浅拷贝:</strong></p><pre><code>function clone(target)&#123;    let cloneTarget=&#123;&#125;;    for(let key in target)&#123;        cloneTarget[key] = target[key]    &#125;    return cloneTarget&#125;</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><ul><li><code>JSON.parse(JSON.stringfy( obj ))</code>通过<strong>JSON的2次转换深拷贝obj</strong><ul><li>无法拷贝<code>undefined</code>与<code>symbol</code>属性</li><li>无法拷贝<strong>循环引用</strong>对象</li></ul></li><li>loadsh:<a href="http://lodash.think2011.net/cloneDeep"><em>.cloneDeep</em></a></li></ul><p>简单深拷贝(可以处理<strong>原始数据类型 + Object</strong>):</p><ul><li>如果是原始类型，无需继续拷贝，直接返回</li><li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行深拷贝后依次添加到新对象上。</li></ul><pre><code>function smpleDeepCopy(target) &#123;  let type = typeof target  if (type === &quot;object&quot;) &#123;    let copy = &#123;&#125;;    for (let key in target) &#123;      copy[key] = smpleDeepCopy(target[key])    &#125;    return copy  &#125;  return target&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 深拷贝浅拷贝
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="深拷贝浅拷贝" scheme="https://juntengma.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://juntengma.github.io/2020/11/12/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%89%91%E6%8C%87offer/"/>
    <id>https://juntengma.github.io/2020/11/12/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%89%91%E6%8C%87offer/</id>
    <published>2020-11-12T11:53:26.042Z</published>
    <updated>2020-11-16T02:14:57.811Z</updated>
    
    <content type="html"><![CDATA[<p>[1/二维数组中的查找](#1/ 二维数组中的查找)</p><p>[2/ 替换空格](#2/ 替换空格)</p><h4 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1/ 二维数组中的查找"></a>1/ 二维数组中的查找</h4><blockquote><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>demo:</p><ul><li><p>输入</p><pre><code>7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code></pre></li><li><p>输出</p><pre><code>true</code></pre></li></ul></blockquote><pre><code>function Find(target, array) &#123;  for(let i=0;i&lt;array.length;i++)&#123;    if(array[i].indexOf(target)!==-1)&#123;      return true    &#125;  &#125;  return false&#125;</code></pre><h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2/ 替换空格"></a>2/ 替换空格</h4><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><pre><code>function replaceSpace(str)&#123;  return str.replace(/ /g,&#39;%20&#39;)&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[1/二维数组中的查找](#1/ 二维数组中的查找)&lt;/p&gt;
&lt;p&gt;[2/ 替换空格](#2/ 替换空格)&lt;/p&gt;
&lt;h4 id=&quot;1-二维数组中的查找&quot;&gt;&lt;a href=&quot;#1-二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;1/ 二维数组中的查找</summary>
      
    
    
    
    <category term="算法" scheme="https://juntengma.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://juntengma.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>React学习</title>
    <link href="https://juntengma.github.io/2020/11/09/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://juntengma.github.io/2020/11/09/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-11-09T08:58:59.845Z</published>
    <updated>2020-11-20T08:28:28.997Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React基础知识汇总"><a href="#React基础知识汇总" class="headerlink" title="React基础知识汇总"></a>React基础知识汇总</h4><p>[TOC]</p><a id="more"></a><h4 id="01-生命周期"><a href="#01-生命周期" class="headerlink" title="01 / 生命周期"></a>01 / 生命周期</h4><p><strong>react15生命周期</strong><img src="https://s1.ax1x.com/2020/11/10/BLFB1P.png"></p><p>React的生命周期就是组件从初始化到卸载到全过程，可以分为以下几个阶段</p><ul><li>初始化阶段(<ul><li><strong>constructor()</strong>, </li><li><strong>componentWillMount</strong>(),</li><li><strong>render</strong>(), </li><li><strong>componentDidMount</strong>()</li></ul></li><li>更新阶段<ul><li><strong>componentWillReceiveProps</strong>(),</li><li><strong>shouldComponentUpdate</strong>(), </li><li><strong>componentWillUpdate</strong>(), </li><li><strong>render</strong>(), </li><li><strong>componentDidUpdate</strong>()</li></ul></li><li>卸载阶段<ul><li><strong>componentWillUnmont</strong>()</li></ul></li></ul><p>这里需要注意的是更新阶段，componentWillReceiveProps是由父组件触发的更新，只要父组件更新，子组件的该生命周期就会被执行，跟props无关。同是，shouldComponentUpdate可以用来做性能优化</p><p><strong>react16生命周期</strong></p><p><img src="https://s1.ax1x.com/2020/11/10/BLkabF.png"></p><p>在React16的生命周期中，去掉了曾经的<strong>componentWillMount</strong>和<strong>componentWillUpdate</strong>，使用<strong>getDerivedStateFromProps</strong>代替这两个方法。同时在更新阶段的render方法和componentDidUpdate之间，新增了一个<strong>getSnapshotBeforeUpdate</strong>方法。接下来就来详细了解一下React这么做的原理以及这些新增生命周期的具体使用</p><p><strong>react15和react16的区别</strong></p><ul><li><h6 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLu3c9.png"></p><ul><li><p><code>-</code>    componentWillMount()</p></li><li><p><code>+</code>    getDerivedStateFromProps()</p><ol><li><p>getDerivedStateFromProps() 主要用于替换 componentWillReceiveProps() 的</p></li><li><p>getDerivedStateFromProps是一个静态方法 , 需要使用static声明</p></li><li><p>getDerivedStateFromProps 接收两个参数, 父组件传递过来的props和自身state</p></li><li><p>必须返回一个对象格式的返回值，否则控制台会被警告</p></li><li><p>该返回值会被用来更新现有state(并不会覆盖原有State，只做定向更新，如果原来State中没有该属性，则新增)，如果没有需要更新的时候，请记得返回一个null</p><pre><code>static getDerivedStateFromProps(props,state)&#123;  return newState&#125;</code></pre></li></ol></li></ul></li><li><h6 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLMPMj.png"></p><ul><li><code>-</code>componentWillReceiveProps()</li><li><code>+</code>getDerivedStateFormProps()</li><li><code>-</code>componentWillupdate()</li><li><code>+</code>getSnapshotBetforeupdate()</li></ul></li></ul><p>React16中也去掉了componentWillUpdate方法，新增了getSnapshotBeforeUpdate方法，这个方法在render方法之后，componentDidUpdate之前被执行，即真实DOM更新之前（获取更新前的真实DOM和更新前后的State&amp;props信息）。该方法需要一个返回值，作为componentDidUpdate的第三个参数。</p><ul><li><h6 id="componentWillReceiveProps-和getDerivedStateFormProps-区别"><a href="#componentWillReceiveProps-和getDerivedStateFormProps-区别" class="headerlink" title="componentWillReceiveProps()和getDerivedStateFormProps()区别"></a>componentWillReceiveProps()和getDerivedStateFormProps()区别</h6></li></ul><table><thead><tr><th>getDerivedStateFormProps( props , state )</th><th>componentWillReceiveProps( nextPorps )</th></tr></thead><tbody><tr><td>使用static 声明: <code>static getDerivedStateFormProps( props , state )&#123;&#125;</code></td><td>直接声明: <code>componentWillReceiveProps( nextPorps )&#123;&#125;</code></td></tr><tr><td><strong>在组件挂载阶段即可执行,父组件更新执行</strong></td><td><strong>只在父组件更新的时候执行</strong></td></tr><tr><td>接收两个参数:  props  ,  state</td><td>接收一个参数( nextPorps )</td></tr><tr><td><strong>必须返回一个对象格式的返回值 或 null</strong></td><td><strong>可以直接更新state状态</strong></td></tr></tbody></table><p><strong>demo:</strong></p><pre><code>  static getDerivedStateFromProps(props, state) &#123;    if (props.age !== state.age) &#123;      return &#123; age: props.age &#125;      // 类似setStae      // this.setState(&#123;      //   age: props.age      // &#125;);    &#125;    return null  &#125;</code></pre><pre><code>  componentWillReceiveProps(nextporps) &#123;    if (nextporps.age !== this.state.age) &#123;      this.setState(&#123;        age: nextporps.age       &#125;);    &#125;  &#125;</code></pre><h4 id="02-Virtual-Dom"><a href="#02-Virtual-Dom" class="headerlink" title="02 / Virtual Dom"></a>02 / Virtual Dom</h4><ul><li><p>什么是Virtual Dom?</p><ul><li>在原生的<code>JavaScript</code>程序中，我们直接对<code>DOM</code>进行创建和更改，而<code>DOM</code>元素通过我们监听的事件和我们的应用程序进行通讯。</li><li><code>React</code>会先将你的代码转换成一个<code>JavaScript</code>对象，然后这个<code>JavaScript</code>对象再转换成真实<code>DOM</code>。这个<code>JavaScript</code>对象就是所谓的虚拟<code>DOM</code>。</li><li>当我们需要创建或更新元素时，<code>React</code>首先会让这个<code>VitrualDom</code>对象进行创建和更改，然后再将<code>VitrualDom</code>对象渲染成真实<code>DOM</code>；</li><li>当我们需要对<code>DOM</code>进行事件监听时，首先对<code>VitrualDom</code>进行事件监听，<code>VitrualDom</code>会代理原生的<code>DOM</code>事件从而做出响应。</li></ul></li><li><p>为什么使用虚拟dom?</p><ul><li><p>可以提高开发效率</p><pre><code>使用JavaScript，我们在编写应用程序时的关注点在于如何更新DOM。使用React，你只需要告诉React你想让视图处于什么状态，React则通过VitrualDom确保DOM与该状态相匹配。你不必自己去完成属性操作、事件处理、DOM更新，React会替你完成这一切。这让我们更关注我们的业务逻辑而非DOM操作，这一点即可大大提升我们的开发效率。</code></pre></li><li><p>性能提升?(有一些矛盾)</p><pre><code>- 直接说虚拟DOM可以提升性能这种说法是很片面的,直接操作dom非常耗费性能这一点毋庸置疑,但是react同样也无法避免操作dom-    如果是首次渲染,virtualDom不具有任何优势,甚至要进行更多的计算和耗费更多的内存- virtualDOm优势在于diff算法和批量处理策略,在react页面更新之前,已经提前计算好了如何更新和渲染dom,减少重绘回流,因此可以理解为提升了性能</code></pre></li><li><p>跨浏览器兼容</p><pre><code>virtualDom自己实现了一套事件机制,模拟了事件捕获和冒泡的过程,采用了事件代理和批量更新的方法,可以抹平各浏览器事件处理不兼容的问题</code></pre></li></ul></li><li><p>React组件的渲染流程</p><ul><li><p>使用<code>React.createElement</code>或<code>JSX</code>编写<code>React</code>组件，<code>Babel</code>帮助我们把所有的<code>JSX </code>代码最后都会转换成<code>React.createElement(...) </code>格式</p><ul><li><p>JSX编写</p><pre><code>class Hello extends Component &#123;  render() &#123;    return &lt;div&gt;Hello ConardLi&lt;/div&gt;;  &#125;&#125;</code></pre></li><li><p><code>React.createElement</code>编写</p><pre><code>class Hello extends Component &#123;  render() &#123;    return React.createElement(&#39;div&#39;, null, `Hello ConardLi`);  &#125;&#125;</code></pre></li><li><p><code>Babel</code>转化demo</p><pre><code>&lt;div&gt;  &lt;img src=&quot;avatar.png&quot; className=&quot;profile&quot; /&gt;  &lt;Hello /&gt;&lt;/div&gt;;</code></pre><pre><code>React.createElement(&quot;div&quot;, null,     React.createElement(&quot;img&quot;, &#123;      src: &quot;avatar.png&quot;,      className: &quot;profile&quot;    &#125;),     React.createElement(Hello, null));</code></pre></li></ul></li><li><p><code>createElement</code>函数对<code>key</code>和<code>ref</code>等特殊的<code>props</code>进行处理，并获取<code>defaultProps</code>对默认<code>props</code>进行赋值，并且对传入的孩子节点进行处理，最终构造成一个<code>ReactElement</code>对象（所谓的虚拟<code>DOM</code>）。</p></li><li><p><code>ReactDOM.render</code>将生成好的虚拟<code>DOM</code>渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实<code>DOM</code>。</p></li></ul></li></ul><p>​    </p><ul><li><p>virtualDom的组成</p><p>即<code>ReactElement</code>element对象，我们的组件最终会被渲染成下面的结构</p><ul><li><code>type</code>：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或<code>class</code>）</li><li><code>key</code>：组件的唯一标识，用于<code>Diff</code>算法</li><li><code>ref</code>：用于访问原生<code>dom</code>节点</li><li><code>props</code>：传入组件的<code>props</code>，<code>chidren</code>是<code>props</code>中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点）</li><li><code>owner</code>：当前正在构建的<code>Component</code>所属的<code>Component</code></li><li><code>self</code>：（非生产环境）指定当前位于哪个组件实例</li><li><code>_source</code>：（非生产环境）指定调试代码来自的文件(<code>fileName</code>)和代码行数(<code>lineNumber</code>)</li></ul><p>例如;</p><pre><code>&lt;div class=&quot;title&quot;&gt;      &lt;span&gt;Hello ConardLi&lt;/span&gt;      &lt;ul&gt;        &lt;li&gt;苹果&lt;/li&gt;        &lt;li&gt;橘子&lt;/li&gt;      &lt;/ul&gt;&lt;/div&gt;</code></pre><pre><code>const VitrualDom = &#123;  type: &#39;div&#39;,  props: &#123; class: &#39;title&#39; &#125;,  children: [    &#123;      type: &#39;span&#39;,      children: &#39;Hello ConardLi&#39;    &#125;,    &#123;      type: &#39;ul&#39;,      children: [        &#123; type: &#39;li&#39;, children: &#39;苹果&#39; &#125;,        &#123; type: &#39;li&#39;, children: &#39;橘子&#39; &#125;      ]    &#125;  ]&#125;</code></pre></li></ul><h4 id="03-diff算法"><a href="#03-diff算法" class="headerlink" title="03 / diff算法"></a>03 / diff算法</h4><ul><li>DIFF算法是DOM更新的一种算法,指页面被更新时,程序用哪种策略更新DOM</li><li>作用是用来计算出 <strong>Virtual DOM</strong> 中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面。</li></ul><p>DIFF算法策略:</p><ul><li><p>Tree Diff    对树每一层进行遍历，找出不同</p><p><img src="https://s3.ax1x.com/2020/11/17/DVYzW9.png"></p></li><li><p>Component Diff  是数据层面的差异比较</p></li><li><p>Element Diff  真实DOM渲染，结构差异的比较</p><ul><li>Diff提供三种DOM操作：<strong>删除</strong>、<strong>移动</strong>、<strong>插入</strong>。</li></ul></li></ul><p><img src="https://s3.ax1x.com/2020/11/17/DVYozn.png"></p><h4 id="04-fiber架构"><a href="#04-fiber架构" class="headerlink" title="04 / fiber架构"></a>04 / fiber架构</h4><blockquote><p>fiber架构是React16对核心算法的一次重构</p><p>Fiber使原本同步渲染变为异步</p></blockquote><p><strong>4.1 React历史算法的风险</strong></p><blockquote><p>React16之前,组件每次更新都会触发React去构建一棵新的虚拟DOM树,通过与上一次虚拟DOM的diff对比,实现DOM的定更新</p><p>该过程是是一个递归的过程,调用栈非常深,只有最低层的返回了,才能逐层返回.</p><p>这个过程漫长且不可打断,同步一旦开始,就会牢牢抓住线程,直到递归完成,这个过程浏览器除了渲染不会再做其他事情,无法处理用户</p><p>交互状态,页面可能会卡死</p></blockquote><p><strong>4.2 Fiber是怎样处理渲染的？</strong></p><blockquote><p>Fiber 会将一个大的更新任务拆解为许多个小任务。</p><p>每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。</p><p>在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”</p></blockquote><p><strong>4.3 说回生命周期</strong></p><p>在最开始给出生命周期图的时候，细心的同学会发现，在下面这张图的左边，React又将生命周期划分了如下三个阶段</p><p><img src="https://s1.ax1x.com/2020/11/10/BL0HNF.png"></p><ul><li>render：纯净且没有副作用，可能会被暂停或者终止，重新启动</li><li>Pre-commit阶段：可以读取DOM</li><li>commit阶段：可以使用DOM，运行副作用，安排更新</li></ul><p><strong>4.4为什么会这样分呢？</strong></p><blockquote><p>总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。</p><p>为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，再狂的框架也不敢在用户眼皮子底下胡乱更改视图，所以这个过程必须用同步渲染来求稳。</p></blockquote><p><strong>4.5废除的生命周期跟Fiber之间的联系</strong></p><pre><code>在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。这就导致 render 阶段的生命周期都是有可能被重复执行的。带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：componentWillMount；componentWillUpdate；componentWillReceiveProps。这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。</code></pre><h4 id="05-React数据传递方案"><a href="#05-React数据传递方案" class="headerlink" title="05 / React数据传递方案"></a>05 / React数据传递方案</h4><ul><li>组件传值</li><li>context</li><li>redux</li></ul><h4 id="06-setState之后发生什么"><a href="#06-setState之后发生什么" class="headerlink" title="06 / setState之后发生什么?"></a>06 / setState之后发生什么?</h4><p>一、React中setState后发生了什么</p><blockquote><p>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程(Reconciliation)。</p><p>经过调和过程，React 会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个Ul界面。</p><p>在React得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变,这就保证了按需更新，而不是全部重新渲染。</p></blockquote><p>二、setState 为什么默认是异步</p><blockquote><p>假如所有setState是同步的，意味着每执行一次setState时 (有可能一个同步代码中， 多次setState) 都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异 步，则可以把一一个同步代码中的多个setState合并成- -次组件更新。</p></blockquote><p>三、setState什么时候是同步</p><blockquote><p>在setTimeout或者原生事件中，setState是同步的。</p></blockquote><h4 id="7-componentWillUpdate可以直接修改state的值吗？"><a href="#7-componentWillUpdate可以直接修改state的值吗？" class="headerlink" title="7 / componentWillUpdate可以直接修改state的值吗？"></a>7 / componentWillUpdate可以直接修改state的值吗？</h4><blockquote><p>react组件在每次需要重新渲染时候都会调用<code>componentWillUpdate()</code>,</p><p>例如，我们调用 <code>this.setState()</code>时候</p><p>在这个函数中我们之所以不调用<code>this.setState()</code>是因为该方法会触发另一个<code>componentWillUpdate()</code>,如果我们<code>componentWillUpdate()</code>中触发状态更改,我们将以无限循环结束.</p></blockquote><h4 id="8-使用Hooks要遵守哪些原则？"><a href="#8-使用Hooks要遵守哪些原则？" class="headerlink" title="8 / 使用Hooks要遵守哪些原则？"></a>8 / 使用Hooks要遵守哪些原则？</h4><blockquote><ol><li>只在最顶层使用 Hook, 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</li><li>只在 React 函数中调用 Hook, 不要在普通的 JavaScript 函数中调用 Hook。</li><li>可以：<br>✅ 在 React 的函数组件中调用 Hook<br>✅ 在自定义 Hook 中调用其他 Hook</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;center&gt;“基于 XLSX 封装的  Excel 并解析为 JSON格式数据的组件”&lt;/center&gt;</summary>
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://juntengma.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期函数</title>
    <link href="https://juntengma.github.io/2020/11/06/React/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://juntengma.github.io/2020/11/06/React/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-11-06T07:28:31.113Z</published>
    <updated>2020-11-10T04:07:29.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​    温故而知新<del>~</del></p><p>​    越基础,越重要哦~</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/06/Bf52x1.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;​    温故而知新&lt;del&gt;~&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;​    越基础,越重要哦~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/06/Bf52x1.jpg&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://juntengma.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React-Hook学习</title>
    <link href="https://juntengma.github.io/2020/11/06/React/React-hooks/"/>
    <id>https://juntengma.github.io/2020/11/06/React/React-hooks/</id>
    <published>2020-11-06T06:49:51.445Z</published>
    <updated>2020-11-18T04:35:52.435Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直都知道Hook这个新技术,但是工作过程中几乎没有用到,最近刚好有时间来学习一下<del>~</del></p></blockquote><a id="more"></a><h3 id="01-什么是Hook"><a href="#01-什么是Hook" class="headerlink" title="01/什么是Hook?"></a>01/什么是Hook?</h3><p>Hook是react16.8新增特性,可以在不编写class的情况下使用state以及其他React特性</p><h3 id="02-什么是Hook"><a href="#02-什么是Hook" class="headerlink" title="02/什么是Hook?"></a>02/什么是Hook?</h3><ul><li>Hook顾名思义是钩子的意思,它可以使函数组件中可以勾入React-State以及生命周期特性等等.</li><li>Hook不能在class组件中使用</li></ul><h3 id="03-Hook内置组件"><a href="#03-Hook内置组件" class="headerlink" title="03/Hook内置组件"></a>03/Hook内置组件</h3><ul><li><p><strong>useState</strong>    (用于操控state)</p><ul><li><p><strong>使用:</strong></p><pre><code>const [stateName , stateChangeFun] = useState(初始值)</code></pre><pre><code>const [count , setCount] = useState(0)&lt;Button onClick=&#123;()=&gt;setCount(count++)&#125;&gt;Click&lt;/Button&gt;    </code></pre></li></ul></li><li><p><strong>useEffect</strong></p><p>Effect Hook 可以让我们在react中执行副作用操作</p><p><code>useEffect</code> 的第二个参数，有三种情况</p><ol><li>什么都不传，组件每次 <code>render</code> 之后 <code>useEffect</code> 都会调用，相当于 <code>componentDidMount</code> 和 <code>componentDidUpdate</code></li></ol></li></ul><ol start="2"><li>传入一个空数组 [], 只会调用一次，相当于 <code>componentDidMount</code> 和 <code>componentWillUnmount</code><ol start="3"><li>传入一个数组，其中包括变量，只有这些变量变动时，<code>useEffect</code> 才会执行</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一直都知道Hook这个新技术,但是工作过程中几乎没有用到,最近刚好有时间来学习一下&lt;del&gt;~&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="Hook" scheme="https://juntengma.github.io/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击</title>
    <link href="https://juntengma.github.io/2020/11/04/Safe/CSRF%E6%94%BB%E5%87%BB/"/>
    <id>https://juntengma.github.io/2020/11/04/Safe/CSRF%E6%94%BB%E5%87%BB/</id>
    <published>2020-11-04T07:53:26.651Z</published>
    <updated>2020-11-16T09:10:00.414Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="01-什么是CSRF攻击"><a href="#01-什么是CSRF攻击" class="headerlink" title="01/ 什么是CSRF攻击?"></a>01/ 什么是CSRF攻击?</h4><p>CSRF攻击指的是跨站请求伪造,攻击者诱导用户进入第三方网站,然后该网站向被攻击者网站发送跨站请求.</p><p>如果用户在被攻击者网站中保存了登录状态,攻击者就可以利用这个状态,绕过后台验证,冒充用户向服务器执行一些操作;</p><h4 id="02-CSRF攻击分类"><a href="#02-CSRF攻击分类" class="headerlink" title="02/ CSRF攻击分类"></a>02/ CSRF攻击分类</h4><ul><li>GET请求的CSRF攻击, 通常用img标签构建请求,用户打开网站的时候,自动发送请求</li><li>POST请求CSRF攻击,比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单</li><li>链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li></ul><h4 id="03-防御方法"><a href="#03-防御方法" class="headerlink" title="03/ 防御方法"></a>03/ 防御方法</h4><ul><li>第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</li><li>第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</li><li>第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li><li>第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li><li>验证码</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h4 id=&quot;01-什么是CSRF攻击&quot;&gt;&lt;a href=&quot;#01-什么是CSRF攻击&quot; class=&quot;headerlink&quot; title=&quot;01/ 什么是CSRF攻击?&quot;&gt;&lt;/a&gt;01/ 什么是CSRF攻击?&lt;/h4&gt;&lt;p&gt;CSRF攻击指</summary>
      
    
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击</title>
    <link href="https://juntengma.github.io/2020/11/04/Safe/XSS%E6%94%BB%E5%87%BB/"/>
    <id>https://juntengma.github.io/2020/11/04/Safe/XSS%E6%94%BB%E5%87%BB/</id>
    <published>2020-11-04T07:53:15.118Z</published>
    <updated>2020-11-18T02:36:10.688Z</updated>
    
    <content type="html"><![CDATA[<p>前端知识回顾之 - XSS攻击</p><a id="more"></a><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><h4 id="1-什么是xss攻击"><a href="#1-什么是xss攻击" class="headerlink" title="1.什么是xss攻击"></a>1.什么是xss攻击</h4><ul><li>xss攻击即跨站脚本攻击,是一种恶意代码注入攻击,攻击者通过在网站上面注入恶意代码,使之在浏览器上面运行,从而获取用户的敏感信息如cookie等</li><li>xss的本质是因为网站没有对恶意代码进行过滤, 与正常代码混在一起,但是浏览器不能识别代码哪些可信哪些不可信,从而导致了恶意代码的执行.</li></ul><h4 id="2-XSS攻击分类"><a href="#2-XSS攻击分类" class="headerlink" title="2.XSS攻击分类"></a>2.XSS攻击分类</h4><ul><li><p>存储型</p><blockquote><p>存储型XSS攻击是将恶意代码提交到网站服务器中,当用户请求数据的时候,服务器将恶意代码拼接到HTML里面后返回,导致恶意代码的执行</p></blockquote></li><li><p>反射型</p><blockquote><p>反射型指的是某些通过url参数获取数据的网站,攻击者构建特殊的url,当服务器收到请求之后,从url中获取数据,并将其拼接为html后返回,从而导致了恶意代码的执行</p></blockquote></li><li><p>DOM型</p><blockquote><p>DOM型XSS攻击指的是攻击者构建了特殊的URL,当用户打开了网站之后,js脚本从url中获取数据,从而导致了恶意代码的执行</p></blockquote></li></ul><h4 id="3-如何预防XSS攻击"><a href="#3-如何预防XSS攻击" class="headerlink" title="3.如何预防XSS攻击"></a>3.如何预防XSS攻击</h4><p>​    预防XSS攻击主要有两个方案</p><ul><li><p>恶意代码提交的时候(不可靠)</p><blockquote><p>当数据即将存入数据库的时候进行转义,但是数据库的数据可能在多个地方使用,有些地方不需要转义,由于我们无法判断这些数据最后的使用场景,所以该方法是<strong>不可靠的</strong></p></blockquote></li><li><p>浏览器执行之前</p><blockquote><ul><li>使用纯前端的方式,不用服务器拼接HTML返回    </li><li>对需要插入的HTML进行充分的转义</li></ul></blockquote></li><li><p>对于DOM性XSS攻击还有以下几种方式</p><blockquote><ul><li>CSP,CSP本质是简历一个白名单,告诉浏览器哪些外部资源是可以加载和执行,从而防止恶意代码的注入攻击</li><li>对敏感信息进行保护,比如cookie使用http-only,禁止脚本获取cookie</li><li>使用验证码,防止脚本伪装用户进行操作</li></ul></blockquote></li></ul><h4 id="4-什么是CSP"><a href="#4-什么是CSP" class="headerlink" title="4.什么是CSP"></a>4.什么是CSP</h4><p>​    CSP指的是内容安全侧策略</p><p>​    他的本质是建立一个白名单,告诉浏览器哪些外部资源可以加在和执行.</p><p>​    <strong>开启SCP方式:</strong></p><ul><li>一种是设置 HTTP 首部中的 <code>Content-Security-Policy</code></li><li>一种是设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ul><p>详细资料可以参考： <a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端知识回顾之 - XSS攻击&lt;/p&gt;</summary>
    
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>DOM事件 , 事件流</title>
    <link href="https://juntengma.github.io/2020/11/03/JavaScript/02%20-%20JavaScript-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <id>https://juntengma.github.io/2020/11/03/JavaScript/02%20-%20JavaScript-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</id>
    <published>2020-11-02T16:00:00.000Z</published>
    <updated>2020-11-26T07:49:01.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4> DOM事件, 事件流</h4></blockquote><a id="more"></a><h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><blockquote><p>事件是指JavaScript与HTML交互的基础.要实现用户与页面的交互,先要对目标元素绑定特定的事件,设置事件处理函数,用户触发事件,事件处理函数执行,产生交互效果</p></blockquote><h4 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h4><p>DOM 级别分为四个级别：DOM0 级、DOM1 级、DOM2 级、DOM3 级；<br><img src="https://s1.ax1x.com/2020/10/28/B1JoY4.md.jpg" alt="B1JoY4.md.jpg"></p><p>DOM事件分为三个级别:<br>DOM0 级事件: 给元素绑定事件</p><pre><code>&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;/button&gt;&lt;script&gt;    var btn = document.getElementById(&#39;btn&#39;)    btn.onclick = function() &#123;        console.log(&#39;Hello World&#39;)    &#125;    // btn.onclick = null // 解绑事件&lt;/script&gt;</code></pre><blockquote><p>   缺点：无法设置多个事件处理函数</p></blockquote><p>DOM2 级事件:用到了事件监听</p><pre><code>&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;/button&gt;&lt;script&gt;    var btn = document.getElementById(&#39;btn&#39;);        btn.addEventListener(&#39;click&#39;, showFn, false)    btn.addEventListener(&#39;click&#39;, showFn2, false)    // btn.removeEventListener(&#39;click&#39;, showFn, false) // 解绑事件     function showFn() &#123;        alert(&#39;Hello World&#39;);    &#125;     function showFn2() &#123;        alert(&#39;Hello World2&#39;);    &#125; &lt;/script&gt;</code></pre><blockquote><p>可以为事件设置多个事件处理函数，可以通过第三个参数 ( useCapture ) 设置在什么阶段执行事件处理函数，默认是 false， 即在事件冒泡阶段执行事件处理函数。</p></blockquote><blockquote><p>需要注意的是在 IE8 及以下版本需要用 attachEvent 和 detachEvent 实现，只有两个参数，事件名需要以 on 开头，只支持在事件冒泡阶段执行事件处理函数。</p></blockquote><p>DOM3 级事件</p><blockquote><p>DOM3 级事件是在 DOM2 级事件的基础上添加了更多的事件类型，允许自定义事件。</p></blockquote><p>UI事件，当用户与页面上的元素交互时触发，如：load、scroll<br>焦点事件，当元素获得或失去焦点时触发，如：blur、focus<br>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup<br>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel<br>文本事件，当在文档中输入文本时触发，如：textInput<br>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress<br>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart<br>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</p><pre><code>// 自定义事件var event = new Event(&#39;test&#39;)// 给元素绑定事件domElement.addEventListener(&#39;test&#39;, function() &#123;    console.log(&#39;event test&#39;)&#125;,)// 触发事件setTimeout(function() &#123;    domElement.dispatchEvent(event)&#125;, 1000)</code></pre><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><blockquote><p>事件流又称为事件传播，描述的是从<strong>页面中接收事件的顺序</strong>。</p><p>DOM2 级事件规定事件流包括三个阶段: </p><ul><li>事件捕获(capturing phase)</li><li>目标事件(target phase)</li><li>事件冒泡(bubbling phase)</li></ul><p>发生的顺序是：事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段</p></blockquote><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><blockquote><p>​    事件起始元素逐级向上传播</p></blockquote><pre><code>&lt;style&gt;  #parent &#123;      width: 200px;      height: 200px;      background-color: green;  &#125;  #child &#123;      width: 100px;      height: 100px;      background-color: yellow;  &#125;&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt;  &lt;div id=&quot;child&quot;&gt;目标元素&lt;/div&gt;  父级元素&lt;/div&gt;&lt;script&gt;  var parent = document.getElementById(&#39;parent&#39;)  var child = document.getElementById(&#39;child&#39;)  parent.addEventListener(&#39;click&#39;, function(e) &#123;      console.log(&#39;parent bubbling&#39;)  &#125;, false)  child.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;target bubbling&#39;)  &#125;, false)  document.body.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;body bubbling&#39;)  &#125;, false)  document.documentElement.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;html bubbling&#39;)  &#125;, false)  document.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;document bubbling&#39;)  &#125;, false)  window.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;window bubbling&#39;)  &#125;, false)&lt;/script&gt;</code></pre><p>运行结果：</p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><blockquote><p>​    事件按 window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素 的方向向下层元素传递。</p></blockquote><pre><code>&lt;style&gt;  #parent &#123;      width: 200px;      height: 200px;      background-color: green;  &#125;  #child &#123;      width: 100px;      height: 100px;      background-color: yellow;  &#125;&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt;  &lt;div id=&quot;child&quot;&gt;目标元素&lt;/div&gt;  父级元素&lt;/div&gt;&lt;script&gt;  var parent = document.getElementById(&#39;parent&#39;)  var child = document.getElementById(&#39;child&#39;)  parent.addEventListener(&#39;click&#39;, function(e) &#123;      console.log(&#39;parent capture&#39;)  &#125;, true)  child.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;target capture&#39;)  &#125;, true)  document.body.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;body capture&#39;)  &#125;, true)  document.documentElement.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;html capture&#39;)  &#125;, true)  document.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;document capture&#39;)  &#125;, true)  window.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;window capture&#39;)  &#125;, true)&lt;/script&gt;</code></pre><p>运行结果:</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
DOM事件, 事件流
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="DOM事件事件流" scheme="https://juntengma.github.io/tags/DOM%E4%BA%8B%E4%BB%B6%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>一段js代码在浏览器中是如何执行的</title>
    <link href="https://juntengma.github.io/2020/11/02/JavaScript/04%20-%20JavaScript-%E4%B8%80%E6%AE%B5js%E4%BB%A3%E7%A0%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://juntengma.github.io/2020/11/02/JavaScript/04%20-%20JavaScript-%E4%B8%80%E6%AE%B5js%E4%BB%A3%E7%A0%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</id>
    <published>2020-11-01T16:00:00.000Z</published>
    <updated>2020-11-26T07:48:40.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一段js代码在浏览器中是如何执行的"><a href="#一段js代码在浏览器中是如何执行的" class="headerlink" title="一段js代码在浏览器中是如何执行的?"></a>一段js代码在浏览器中是如何执行的?</h3><blockquote><p>   在了解代码执行流程之前 , 我们需要知道一点前置知识 , </p><ul><li>js解析顺序</li><li>可执行代码</li><li>执行上下文栈<br>当我们这些前置知识都捋清楚了 , js执行流程也就清楚了…..<a id="more"></a></li></ul></blockquote><h3 id="01-JS代码执行顺序是什么"><a href="#01-JS代码执行顺序是什么" class="headerlink" title="01 / JS代码执行顺序是什么"></a>01 / JS代码执行顺序是什么</h3><p>  JavaScript代码是逐行执行的 , 但是js引擎并非一行一行的<strong>解析</strong>执行程序,而是一段一段的分析执行,为什么是分段执行的呢?又按什么规则来分段的呢?这里我们需要再了解一下什么是<strong>可执行代码</strong></p><p>  (Js代码是逐行执行的,但是js引擎并非逐行解析程序执行的,而是判断是否可执行代码一段一段的执行的)</p><h3 id="02-可执行代码-amp-执行上下文"><a href="#02-可执行代码-amp-执行上下文" class="headerlink" title="02 / 可执行代码 &amp; 执行上下文"></a>02 / 可执行代码 &amp; 执行上下文</h3><p>  可执行代码有三种,全局代码,函数代码,eval代码,当执行到可执行代码的时候,就会进行准备一些工作 . 这个准备工作就是<strong>执行上下文</strong></p><ul><li><p>全局代码</p></li><li><p>函数代码</p></li><li><p>eval代码( evla()函数可以将传入的字符串当做 JavaScript 代码进行执行 )</p><h3 id="05-执行上下文栈"><a href="#05-执行上下文栈" class="headerlink" title="05 / 执行上下文栈"></a>05 / 执行上下文栈</h3><p>为了管理js中大量的可执行上下文,JavaScript引擎创建了<strong>执行上下文栈</strong>来管理可执行上下文</p></li><li><p>当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈(ECStack)压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext.</p><pre><code>const ECStack  = [      globalContext ]</code></pre></li></ul><ul><li><p>当函数开始执行的时候,同样生成一个可以执行上下文并压入可执行上下文栈,当函数执行完毕的时候,再从执行上下文栈中弹出</p><pre><code>const ECStack  = [  eval()  function()  globalContext ]</code></pre></li></ul><h3 id="06-总结"><a href="#06-总结" class="headerlink" title="06 / 总结:"></a>06 / 总结:</h3><ul><li>在执行一段代码时，JS 引擎会首先<strong>创建一个执行栈</strong>,然后JS引擎会创建一个<strong>全局执行上下文</strong>，并push到执行栈中</li></ul><ul><li>这个过程JS引擎会为这段代码中<strong>所有变量</strong>分配内存并赋一个初始值（undefined）</li></ul><ul><li>在创建完成后，JS引擎会进入<strong>执行阶段</strong>，这个<strong>过程JS引擎会逐行的执行代码</strong>，即为之前分配好内存的变量逐个赋值(真实值)。</li></ul><ul><li>如果这段代码中存在function的声明和调用，那么JS引擎会创建一个<strong>函数执行上下文</strong>，并push到执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文push到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。</li></ul><ul><li><p>还有一种特殊情况是，在子函数执行的过程中，父函数已经return了，这种情况下，JS引擎会将父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。</p><h3 id="JS引擎如何处理高并发"><a href="#JS引擎如何处理高并发" class="headerlink" title="JS引擎如何处理高并发?"></a>JS引擎如何处理高并发?</h3></li></ul><p>  <strong>JS引擎是单线程的</strong>，那么它是如何处理高并发的呢？即当代码中存在异步调用时JS是如何执行的?</p><p>  比如setTimeout或fetch请求都是non-blocking的，<br>  当异步调用代码触发时，JS引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push进任务队列中等待被调用，<br>  当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立刻将任务队列中的回调函数逐个push进调用栈并执行。这个过程我们也称之为<strong>事件循环</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一段js代码在浏览器中是如何执行的&quot;&gt;&lt;a href=&quot;#一段js代码在浏览器中是如何执行的&quot; class=&quot;headerlink&quot; title=&quot;一段js代码在浏览器中是如何执行的?&quot;&gt;&lt;/a&gt;一段js代码在浏览器中是如何执行的?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;   在了解代码执行流程之前 , 我们需要知道一点前置知识 , &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;js解析顺序&lt;/li&gt;
&lt;li&gt;可执行代码&lt;/li&gt;
&lt;li&gt;执行上下文栈&lt;br&gt;当我们这些前置知识都捋清楚了 , js执行流程也就清楚了…..</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript基础知识综合</title>
    <link href="https://juntengma.github.io/2020/11/01/JavaScript/01%20-%20JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://juntengma.github.io/2020/11/01/JavaScript/01%20-%20JavaScript%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-10-31T16:00:00.000Z</published>
    <updated>2020-11-26T07:49:06.619Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4> 整理一些js基础知识点和总结...</h4></blockquote><p>[TOC]</p><a id="more"></a><h4 id="01-JS数据类型-6-1"><a href="#01-JS数据类型-6-1" class="headerlink" title="01 / JS数据类型(6+1)"></a>01 / JS数据类型(6+1)</h4><ul><li><p><strong>基本数据类型:</strong></p><pre><code>- null- undefined- number- string- boolean- symbol:代表创建后独一无二且不可变的数据类型，它的出现我认为主要是为了解决可能出现的全局变量冲突的问题。</code></pre></li><li><p><strong>引用数据类型:</strong></p><p>引用数据类型指的是object类型,其他如Array,Date等数据类型都可以理解为Object的子类</p><pre><code>object =  [   Array,   Date,   Math,   ...]</code></pre></li><li><p><strong>基本数据类型和引用数据类型区别:</strong></p><ul><li>基本数据类型在内存中占固定大小的空间,因此被保存在栈中</li><li>引用类型值是对象，保存在 <strong>堆内存</strong> 中。包含引用类型值的变量实际包含并非对象本身，而是指向该对象的指针。一个变量从另一个变量复制引用类型的值时，复制的也是指向该对象的指针。</li></ul></li></ul><h4 id="02-什么是堆-栈"><a href="#02-什么是堆-栈" class="headerlink" title="02 / 什么是堆/栈?"></a>02 / 什么是堆/栈?</h4><pre><code>堆栈概念存在于数据结构和操作系统内存中- 在数据结构中:  - 栈中的数据存取方式为先进后出  - 堆是一个优先队列,按照优先级来进行排序的,优先级可以按照大小来规定- 操作系统中 ,内存被分为栈区和堆区:  - 栈区的内存由编译器自动分配释放,存放函数的参数值,局部变量值等    - 堆内存一般由程序员释放,若没有手动释放则程序结束时由垃圾回收机制回收</code></pre><h4 id="03-什么是JavaSctipt垃圾回收机制"><a href="#03-什么是JavaSctipt垃圾回收机制" class="headerlink" title="03 / 什么是JavaSctipt垃圾回收机制?"></a>03 / 什么是JavaSctipt垃圾回收机制?</h4><ul><li><p><strong>为什么要垃圾回收?</strong></p><pre><code class="html">随着前端业务需求的不断增多，相比以前，我们会占用更多的内存。但是内存并不是无限的，我们需要垃圾回收机制去处理那些我们不再需要的变量、对象 </code></pre></li><li><p><strong>垃圾回收机制的特点:</strong></p><p>垃圾回收机制会定期对那些我们不再使用的变量、对象所占用的内存释放     </p><pre><code>原理:    + 找出那些不再使用的变量，然后释放其占用的内存。    + 垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。</code></pre></li><li><p><strong>垃圾回收的方式有哪些?</strong></p><ul><li><p>标记清除</p><ul><li><p>当变量进入环境时,就将其标记为”进入环境”,此时”进入环境”的变量是不可以被回收的”</p></li><li><p>当变量离开环境时,就将其标记为”离开环境”,此时”离开环境”的变量可以被回收</p><pre><code>function func () &#123;      const a = 1    const b = 2      // 函数执行时，a b 分别被标记 进入环境&#125;func() // 函数执行结束，a b 被标记 离开环境，被回收</code></pre></li></ul></li><li><p>引用计数</p><ul><li><p>统计引用类型变量声明后被引用的次数，当次数为 0 时，该变量将被回收</p><pre><code>function func1 () &#123;      const c = &#123;&#125; // 引用类型变量 c的引用计数为 0      let d = c // c 被 d 引用 c的引用计数为 1      let e = c // c 被 e 引用 c的引用计数为 2      d = &#123;&#125; // d 不再引用c c的引用计数减为 1      e = null // e 不再引用 c c的引用计数减为 0 将被回收&#125;</code></pre></li><li><p>但是引用计数的方式，有一个相对明显的缺点——<strong>循环引用</strong></p><pre><code>function func5 () &#123;      let f = &#123;&#125;      let g = &#123;&#125;      f.prop = g      g.prop = f      // 由于 f 和 g 互相引用，计数永远不可能为 0&#125;</code></pre></li><li><p>像上面这种情况就需要<strong>手动将变量的内存释放</strong></p><pre><code>f.prop = nullg.prop = null</code></pre></li></ul></li></ul></li></ul><p>参考:<br>    <a href="https://juejin.im/post/6844903652331618312">&lt;&lt;javascript 垃圾回收机制&gt;&gt;</a><br>    <a href="https://juejin.im/post/6844903858972409869#heading-3">&lt;&lt;JavaScript 垃圾回收机制&gt;&gt;</a></p><h4 id="04-什么是循环引用"><a href="#04-什么是循环引用" class="headerlink" title="04 / 什么是循环引用 ?"></a>04 / 什么是循环引用 ?</h4><p>当对象 1 中的某个属性指向对象 2，对象 2 中的某个属性指向对象 1 就会出现循环引用(最简单的例子)</p><pre><code>  function circularReference() &#123;      let obj1 = &#123; &#125;;      let obj2 = &#123; &#125;;      obj1.a = obj2;      obj2.b = obj1;  &#125;</code></pre><h4 id="05-内存泄露"><a href="#05-内存泄露" class="headerlink" title="05 / 内存泄露"></a>05 / 内存泄露</h4><ul><li><p>什么是内存泄露?</p><pre><code>程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。</code></pre></li><li><p>常见的内存泄露有哪些?</p><ul><li><p>全局变量(在非严格模式下当引用未声明的变量时，会在全局对象中创建一个新变量。)</p></li><li><p>被遗忘的定时器和回调函数</p></li><li><p>DOM引用</p></li><li><p>闭包</p></li></ul></li></ul><h4 id="06-JavaScript可执行上下文"><a href="#06-JavaScript可执行上下文" class="headerlink" title="06 /  JavaScript可执行上下文"></a>06 /  JavaScript可执行上下文</h4><p><a href="/2020/11/03/JavaScript/03%20-%20JavaScript-作用域&可执行上下文/" target="_blank">&lt;&lt;JavaScript可执行上下文&gt;&gt;</a></p><h4 id="07-JavaScript在浏览器中如何执行的"><a href="#07-JavaScript在浏览器中如何执行的" class="headerlink" title="07 /  JavaScript在浏览器中如何执行的"></a>07 /  JavaScript在浏览器中如何执行的</h4><p><a href="/2020/09/22/JavaScript/04%20-%20JavaScript-一段js代码在浏览器中是如何执行的/" target="_blank">&lt;&lt;JavaScript在浏览器中如何执行的&gt;&gt;</a></p><h4 id="08-从输入url到页面加载过程"><a href="#08-从输入url到页面加载过程" class="headerlink" title="08 /  从输入url到页面加载过程"></a>08 /  从输入url到页面加载过程</h4><p><a href="/2020/10/26/JavaScript/06%20-%20从输入url到页面加载过程/" target="_blank">&lt;&lt;从输入url到页面加载过程&gt;&gt;</a></p><h4 id="09-内部属性-class-是什么"><a href="#09-内部属性-class-是什么" class="headerlink" title="09 / 内部属性[[class]]是什么"></a>09 / 内部属性[[class]]是什么</h4><p>所有<code>typeof</code>返回值为 <code>object</code> 的对象（如数组）都包含一个内部属性 [[Class]],这个属性无法直接访问，一般通过以下代码查看</p><pre><code>Object.prototype.toString.call(Array)  //&quot;[object Function]&quot;</code></pre><h4 id="10-Js内置对象都有哪些"><a href="#10-Js内置对象都有哪些" class="headerlink" title="10 / Js内置对象都有哪些"></a>10 / Js内置对象都有哪些</h4><pre><code>js内置对象主要是只在程序执行前存在全局作用域里面的由js定义的一些全局属性,函数和用来实例化其他对象的构造函数对象.一般我们经常用到的全局函数变量值: NaN , undefined ,全局函数: parseInt() , paeseFloat()用来实例化的全局构造函数: Date , Object 等</code></pre><h4 id="11-原型原型链"><a href="#11-原型原型链" class="headerlink" title="11 / 原型原型链"></a>11 / 原型原型链</h4><pre><code>01/ 原型:-    Js中我们使用构造函数来新建对象的-    每个构造函数内部都有一个prototype属性,这个属性值是一个对象,包含了可以由该构造函数共享的实例和方法- 我们使用构造函数新建一个对象后,这个对象内部有一个`__proto__`指针,可以指向构造函数prototype属性对应的值,es5中我们一般称他为对象的原型 浏览器可以通过`__proto__`值来获取,也可以用Object.getPrototypeOf()找到对象的原型02/ 原型链:- 当我们访问一个对象的属性时,如果这个对象里面不存在该属性的时候,那么就会到这个对象的原型对象中找这个属性,就这样一层层的找就构成了原型链,最后找到Object.proptotype,如果还没找到就会返回null.03/ 获取原型的办法:- `p.__proto__`- `p.constructor.prototype`- `Object.getPrototypeOf(p)`04/ 原型可以做什么?- 实现继承- 共享我们的一些实例和方法</code></pre><p><a href="">&lt;&lt;JavaScript原型原型链&gt;&gt;</a></p><h4 id="12-闭包"><a href="#12-闭包" class="headerlink" title="12 / 闭包"></a>12 / 闭包</h4><pre><code>闭包是指内部函数可以访问其所在的外部函数中声明的参数和变量;创建闭包最常用的方法是在一个函数内创建另外一个函数,创建的函数可以访问父级函数的局部变量;闭包主要有两个用途:1/ 使我们可以在函数外部访问到函数内部的变量,通过这个方法,我们可以在函数外部调用闭包函数,在函数外部访问到函数内部变量2/ 使已经运行过的函数上下文的变量对象继续保存在内存中,不被垃圾回收机制释放内存,但是操作不当可能会造成内存泄露</code></pre><h4 id="13-继承"><a href="#13-继承" class="headerlink" title="13 / 继承"></a>13 / 继承</h4><pre><code>继承实现方式:- 原型链继承- 构造函数继承- 组合继承(原型链+构造函数继承)- 原型式继承- 寄生式继承- 寄生组合式继承</code></pre><p><a href="https://github.com/mqyqingfeng/Blog/issues/16">&lt;&lt;JavaScript深入之继承的多种方式和优缺点&gt;&gt;</a></p><h4 id="14-什么是-pure-function"><a href="#14-什么是-pure-function" class="headerlink" title="14 / 什么是 pure function"></a>14 / 什么是 pure function</h4><p>如果一个函数没有任何副作用（side-effects)，不会影响任何外部状态，对于任何一个相同的输入（参数），无论何时调用这个函数总是返回同样的结果，这个函数就是一个 pure function。</p><h4 id="15-重绘回流"><a href="#15-重绘回流" class="headerlink" title="15 / 重绘回流"></a>15 / 重绘回流</h4><p><strong>01/ 前置知识:</strong></p><ol><li><p>浏览器使用流式布局模型 (Flow Based Layout)。</p></li><li><p>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了<code>Render Tree</code>。</p></li><li><p>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</p></li><li><p>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一。 </p></li></ol><p><strong>02/ 什么是回流:</strong></p><p>当<code>Render Tree</code>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p><p><strong>02.1/ 会导致回流的操作：</strong></p><ul><li>页面首次渲染</li><li>浏览器窗口大小发生改变</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</li><li>激活<code>CSS</code>伪类（例如：<code>:hover</code>）</li><li>查询某些属性或调用某些方法</li></ul><p><strong>02.2/ 一些常用且会导致回流的属性和方法：</strong></p><ul><li><code>clientWidth</code>、<code>clientHeight</code>、<code>clientTop</code>、<code>clientLeft</code></li><li><code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code></li><li><code>scrollWidth</code>、<code>scrollHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code></li><li><code>scrollIntoView()</code>、<code>scrollIntoViewIfNeeded()</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li><li><code>scrollTo()</code></li></ul><p><strong>03/ 什么是重绘:</strong></p><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><ul><li><strong>回流比重绘的代价要更高。</strong></li><li>有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</li></ul><p><strong>03.1/ 现代浏览器会对频繁的回流或重绘操作进行优化：</strong></p><ul><li><p>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p></li><li><p>当你访问以下属性或方法时，浏览器会立刻清空队列：</p><pre><code>- clientWidth、clientHeight、clientTop、clientLeft</code></pre></li></ul><ul><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li></ul><ul><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li></ul><ul><li>width、height</li></ul><ul><li>getComputedStyle()</li></ul><ul><li>getBoundingClientRect()<pre><code></code></pre></li></ul><p><strong>04/ 如何避免回流重绘?</strong></p><ul><li><p>CSS</p><ul><li>避免使用<code>table</code>布局。</li><li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li><li>避免设置多层内联样式。</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li><li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li></ul></li><li><p>JavaScript</p><ul><li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li><li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li><li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul></li></ul><p><strong>05 /总结:</strong></p><p> <strong>回流必将引起重绘，重绘不一定会引起回流。</strong></p><p>参考:<a href="https://juejin.im/post/6844903569087266823">&lt;&lt;浏览器的回流与重绘 (Reflow &amp; Repaint)&gt;&gt;</a></p><h4 id="16-http缓存"><a href="#16-http缓存" class="headerlink" title="16 / http缓存"></a>16 / http缓存</h4><p>http缓存按我自己的理解:</p><blockquote><p>我更愿意叫做浏览器缓存,缓存主要发生在浏览器端,而http起到的作用是告诉浏览器是否使用缓存资源,是否进行缓存…</p></blockquote><p>01/ 为什么要缓存呢?</p><blockquote><p>用于性能提升,减少延迟,提高网页加载速度;同时,由于缓存文件可以重复利用,还可以减少带宽,降低网络负荷</p></blockquote><p>02/ 浏览器怎么才能缓存?</p><blockquote><p>http缓存机制主要在http响应头中设定，响应头中相关字段为Expires、Cache-Control、Last-Modified、Etag。<br>可以控制浏览器是否使用缓存、缓存多久</p></blockquote><p>03/ 那么如何知晓浏览器是读取了缓存还是直接请求服务器？如下图网站来做个示例：</p><p><img src="https://s3.ax1x.com/2020/11/12/BzalAP.png"></p><p>第一次打开该网站后，如果再次刷新页面。会发现浏览器加载的众多资源中，有一部分size有具体数值，然而还有一部分请求，比如图片、css和js等文件并没有显示文件大小，而是显示了 from dis cache 或者 from memory cache 字样。这就说明了，该资源直接从本地硬盘或者浏览器内存读取，而并没有请求服务器。</p><p>04/ 浏览器缓存方式?<br>浏览器缓存分为两种:</p><ul><li>强制缓存</li><li>协商缓存</li></ul><p>05/ 浏览器缓存机制</p><blockquote><p>1\ 浏览器加载资源的时候,先根据资源的http header判断他是否命中强缓存,</p><pre><code>-    如果命中,浏览器就先从自己的缓存(先从内存中找,找不到再去磁盘中找)中读取资源,不会发送请求到服务器</code></pre><p>2\ 没有命中的时候,浏览器会发送一个请求给服务器,通过服务器端的另外的一些http header来验证这个资源是否命中协商缓存</p><ul><li>如果命中协商缓存,服务器会将这个请求返回,但是不会返回这个请求的数据,而是告诉客户端可以直接从缓存中加载资源,然后浏览器重新去缓存中读取数据</li></ul><p>3\强缓存和协商缓存相同点:</p><ul><li>命中都是从浏览器缓存中加载资源</li></ul><p>4\不同点</p><ul><li>强缓存不发请求到服务器</li><li>协商缓存会发请求给服务器</li></ul><p>05\协商缓存也没有命中的时候,浏览器直接去服务器获取数据</p></blockquote><p>06/ 判断缓存机制</p><p><img src="https://s3.ax1x.com/2020/11/12/BzB1bj.png"></p><p>参考:</p><ul><li><a href="https://juejin.im/post/6844903672556552205#heading-2">&lt;&lt;前端优化：浏览器缓存技术介绍&gt;&gt;</a></li><li><a href="https://juejin.im/post/6844903838768431118#heading-0">&lt;&lt;http面试必会的：强制缓存和协商缓存&gt;&gt;</a></li></ul><h4 id="17-SSR-BSR区别"><a href="#17-SSR-BSR区别" class="headerlink" title="17 / SSR/BSR区别"></a>17 / SSR/BSR区别</h4><ul><li><p>SSR:服务端渲染</p><p>对营销推广的要求比较高的产品,比如官网等</p><pre><code>- M+V发生在服务端,服务器压力较大- 页面访问和显示速度更快(DOM比较少)- 有利于SEO搜索引擎优化- 前后端不分离,后端开发压力大- 功能不能过于复杂,多用于功能交互都比较简单的产品</code></pre></li><li><p>BSR:客户端渲染</p><p>对营销推广要求没有那么搞的产品,例如后台管理系统</p><pre><code>- M+v过程发生在浏览器,浏览器压力较大- 页面访问和加载速度没有服务端渲染快- 不利于SEO优化- 前后端分离,便于代码调试和维护- 可以做更加复杂的产品</code></pre></li></ul><h4 id="18-SEO优化"><a href="#18-SEO优化" class="headerlink" title="18 / SEO优化"></a>18 / SEO优化</h4><p>………………</p><h4 id="19-MVC"><a href="#19-MVC" class="headerlink" title="19 / MVC"></a>19 / MVC</h4><p>MVC模式的意思是，软件可以分成三个部分。即Model模型、View视图、Controller控件器。</p><blockquote><ul><li><p>View：视图，为用户提供使用界面，与用户直接进行交互。</p></li><li><p>Model：模型，承载数据，并对用户提交请求进行计算的模块。其分为两类，一类称为数据承载Bean，一类称为业务处理Bean。所谓数据承载Bean是指实体类，专门承载业务数据的，如Student、User等。而业务处理Bean则是指Service或Dao对象，专门用于处理用户提交请求的。</p></li><li><p>Controller：控制器，用于将用户请求转发给相应的Model进行处理，并处理Model的计算结果向用户提供相应响应。</p></li></ul></blockquote><p>MVC架构程序的工作流程是这样的：</p><p><img src="https://s3.ax1x.com/2020/11/16/DAKqrd.png"></p><blockquote><p>（1）用户通过View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX请求等。</p><p>（2）服务端Controller控制器接收到请求后对请求进行解析，找到相应 的Model对用户请求进行处理。</p><p>（3）Model处理后，将处理结果再交给Controller。</p><p>（4）Controller在接到处理结果后，根据处理结果找到要作为向客户端发回的响应View页面。页面经渲染（数据填充）后，再发送给客户端。</p></blockquote><p>实际项目往往采用更灵活的方式</p><p><img src="https://s3.ax1x.com/2020/11/16/DAMGIx.png"></p><blockquote><p>\1. 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。</p><p>\2. 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。</p><p>\3. Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器） 。</p></blockquote><p>参考: </p><p><a href="https://juejin.im/post/6844903479568252935">&lt;&lt;MVC 与三层架构&gt;&gt;</a></p><p><a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">&lt;&lt;MVC，MVP 和 MVVM 的图示&gt;&gt;</a></p><h4 id="20-MVVM"><a href="#20-MVVM" class="headerlink" title="20 / MVVM"></a>20 / MVVM</h4><p><img src="https://s3.ax1x.com/2020/11/16/DAYfZF.png"></p><pre><code>1. 各部分之间的通信，都是双向的。2. View 与 Model 不发生联系，都通过 ViewModule 传递。3. View 非常薄，不部署任何业务逻辑，称为&quot;被动视图&quot;（Passive View），即没有任何主动性，而 ViewModule非常厚，所有逻辑都部署在那里。4. 它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然</code></pre><h4 id="21-SPA单页应用-amp-多页应用"><a href="#21-SPA单页应用-amp-多页应用" class="headerlink" title="21/ SPA单页应用 &amp; 多页应用"></a>21/ SPA单页应用 &amp; 多页应用</h4><p><a href="https://www.jianshu.com/p/a02eb15d2d70">&lt;&lt;&gt;&gt;</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
整理一些js基础知识点和总结...
&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
