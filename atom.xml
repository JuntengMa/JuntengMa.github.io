<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>June&#39;s Blog</title>
  
  
  <link href="https://juntengma.github.io/atom.xml" rel="self"/>
  
  <link href="https://juntengma.github.io/"/>
  <updated>2021-03-12T02:01:01.938Z</updated>
  <id>https://juntengma.github.io/</id>
  
  <author>
    <name>June</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ssh配置</title>
    <link href="https://juntengma.github.io/2021/03/12/%E5%B7%A5%E5%85%B7/ssh%E9%85%8D%E7%BD%AE/"/>
    <id>https://juntengma.github.io/2021/03/12/%E5%B7%A5%E5%85%B7/ssh%E9%85%8D%E7%BD%AE/</id>
    <published>2021-03-12T01:51:54.000Z</published>
    <updated>2021-03-12T02:01:01.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git-配置多个-SSH-Key-方法"><a href="#Git-配置多个-SSH-Key-方法" class="headerlink" title="Git 配置多个 SSH-Key 方法"></a>Git 配置多个 SSH-Key 方法</h3><a id="more"></a><p>一般情况下，当有多个 git 账号，如果没有咧，都去尝试一下，例如：</p><ul><li>gitee 账号，国产 github，码云值得拥有</li><li>github 账号，全球最大同性交友网站</li><li>gitlab 账号，公司内部的工作开发，至少我所在开发组使用的这个</li></ul><p><strong>解决方案</strong></p><p>解决办法很简单，新建一个 config 文件就可以了。</p><h4 id="1、本地生成-SSH-Key"><a href="#1、本地生成-SSH-Key" class="headerlink" title="1、本地生成 SSH-Key"></a>1、本地生成 SSH-Key</h4><p>生成一个 gitee 用的 SSH-Key</p><pre><code>$ ssh-keygen -t rsa -C &#39;xxxxx@163.com&#39; -f ~/.ssh/gitee_id_rsa</code></pre><p>生成一个 github 用的 SSH-Key</p><pre><code>$ ssh-keygen -t rsa -C &#39;xxxxx@163.com&#39; -f ~/.ssh/github_id_rsa</code></pre><p>生成一个公司用 gitlab 的 SSH-Key</p><pre><code>$ ssh-keygen -t rsa -C &#39;xxxxx@company.com&#39; -f ~/.ssh/gitlab_id_rsa</code></pre><p>在默认文档中就会生成如下这些文件：</p><h4 id="2、git-平台设置中"><a href="#2、git-平台设置中" class="headerlink" title="2、git 平台设置中"></a>2、git 平台设置中</h4><p>将 .pub 文件中内容复制到相应的平台 SSH 设置中，例如：</p><p>gitee_id_rsa.pub 中的文件内容复制到码云的 SSH 公钥中。</p><h4 id="3、新建-config-文件"><a href="#3、新建-config-文件" class="headerlink" title="3、新建 config 文件"></a>3、新建 config 文件</h4><p>在 ~/.ssh 目录下新建一个 config 文件，添加如下内容：</p><pre><code># giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitee_id_rsa# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github_id_rsa# gitlabHost xxxx.comHostName xxxx.comPreferredAuthentications publickeyIdentityFile ~/.ssh/gitlab_id_rsa</code></pre><p>其中 Host 和 HostName 填写 git 服务器的域名，IdentityFile 指定私钥的路径。<br>实在不晓得 Host 和 HostName 怎么填的呢，譬如不知道公司内部的服务器域名，可以在 known_hosts 文件中查看。</p><h4 id="4、测试是否联通"><a href="#4、测试是否联通" class="headerlink" title="4、测试是否联通"></a>4、测试是否联通</h4><p>用 ssh 命令分别测试，@后面跟着的是域名</p><pre><code>$ ssh -T git@gitee.com$ ssh -T git@github.com$ ssh -T git@xxxx.com</code></pre><p>You’ve successfully authenticated, but GitHub does not provide shell access.</p><p>当出现这句话的时候说明你已经配置完成啦</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Git-配置多个-SSH-Key-方法&quot;&gt;&lt;a href=&quot;#Git-配置多个-SSH-Key-方法&quot; class=&quot;headerlink&quot; title=&quot;Git 配置多个 SSH-Key 方法&quot;&gt;&lt;/a&gt;Git 配置多个 SSH-Key 方法&lt;/h3&gt;</summary>
    
    
    
    <category term="Git" scheme="https://juntengma.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="https://juntengma.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>玩转Gulp~~~</title>
    <link href="https://juntengma.github.io/2021/01/18/%E5%B7%A5%E5%85%B7/gulp/"/>
    <id>https://juntengma.github.io/2021/01/18/%E5%B7%A5%E5%85%B7/gulp/</id>
    <published>2021-01-18T12:56:34.000Z</published>
    <updated>2021-03-05T01:36:25.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="01、-Gulp-是什么？"><a href="#01、-Gulp-是什么？" class="headerlink" title="01、 Gulp 是什么？"></a>01、 Gulp 是什么？</h3><p>Gulp 则一种前端工作流的工具，帮忙实现业务过程的自动化。</p><a id="more"></a><h3 id="02、Gulp-用来做什么？"><a href="#02、Gulp-用来做什么？" class="headerlink" title="02、Gulp 用来做什么？"></a>02、Gulp 用来做什么？</h3><p>前端构建工具，代码压缩等功能</p><h3 id="03、Gulp-Demo？"><a href="#03、Gulp-Demo？" class="headerlink" title="03、Gulp Demo？"></a>03、Gulp Demo？</h3><pre><code>const gulp = require(&#39;gulp&#39;);const del = require(&#39;del&#39;);const zip = require(&#39;gulp-zip&#39;);const merge = require(&#39;merge2&#39;);const appName = require(&#39;./package.json&#39;).name;const appVersion = require(&#39;./package.json&#39;).version;gulp.task(&#39;copy-public&#39;, function () &#123;    return gulp.src(&#39;./public/**&#39;).pipe(gulp.dest(&#39;./build/static&#39;));&#125;);gulp.task(&#39;clear-prebuild&#39;, function () &#123;    return del([        &#39;./build/server/**&#39;,        &#39;./build/static/**&#39;,        &#39;./build/archive/**&#39;,        &#39;./build/*.zip&#39;,    ]);&#125;);gulp.task(&#39;move&#39;, function () &#123;    // const buildId = fs.readFileSync(&#39;build/BUILD_ID&#39;, &#39;utf8&#39;);    const archiveNodePath = &#39;build/archive/nodejs&#39;;    const archiveCDNPath = &#39;build/archive/cdn&#39;;    return merge(        // CDN        gulp            .src([&#39;./build/static/**&#39;, &#39;!./build/static/**/*.map&#39;])            .pipe(gulp.dest(`$&#123;archiveCDNPath&#125;/_next/static/`)),        gulp.src([&#39;./public/**&#39;]).pipe(gulp.dest(`$&#123;archiveCDNPath&#125;/`)),        // Node        gulp.src([&#39;.npmrc&#39;]).pipe(gulp.dest(`$&#123;archiveNodePath&#125;`)),        gulp            .src([                &#39;./**&#39;,                &#39;!./node_modules&#123;,/**&#125;&#39;,                &#39;!./build/static/**&#39;,                &#39;!./build/cache/**&#39;,                &#39;!./build/archive/**&#39;,                &#39;!logs&#123;,/**&#125;&#39;,                &#39;!docs&#123;,/**&#125;&#39;,                &#39;!sourcemaps&#123;,/**&#125;&#39;,                &#39;!config&#123;,/**&#125;&#39;,                &#39;!gulpfile.js&#39;,                &#39;!external&#123;,/**&#125;&#39;,                &#39;!*.lock&#39;,                &#39;!README.md&#39;,                &#39;!CHANGELOG.md&#39;,            ])            .pipe(gulp.dest(`$&#123;archiveNodePath&#125;`))    );&#125;);gulp.task(&#39;zip:cdn&#39;, function () &#123;    return gulp        .src(&#39;build/archive/cdn/**&#39;, &#123; base: &#39;./build/archive/cdn&#39;, dot: true &#125;)        .pipe(zip(`$&#123;appName&#125;-archive-cdn.zip`))        .pipe(gulp.dest(&#39;./build/archive&#39;));&#125;);gulp.task(&#39;zip:nodejs&#39;, function () &#123;    return gulp        .src(&#39;build/archive/nodejs/**&#39;, &#123;            base: &#39;./build/archive/nodejs&#39;,            dot: true,        &#125;)        .pipe(zip(`$&#123;appName&#125;-archive-nodejs.zip`))        .pipe(gulp.dest(&#39;./build/archive&#39;));&#125;);gulp.task(&#39;ci&#39;, gulp.series([&#39;copy-public&#39;, &#39;move&#39;, &#39;zip:cdn&#39;, &#39;zip:nodejs&#39;]));</code></pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;01、-Gulp-是什么？&quot;&gt;&lt;a href=&quot;#01、-Gulp-是什么？&quot; class=&quot;headerlink&quot; title=&quot;01、 Gulp 是什么？&quot;&gt;&lt;/a&gt;01、 Gulp 是什么？&lt;/h3&gt;&lt;p&gt;Gulp 则一种前端工作流的工具，帮忙实现业务过程的自动化。&lt;/p&gt;</summary>
    
    
    
    <category term="Gulp" scheme="https://juntengma.github.io/categories/Gulp/"/>
    
    
    <category term="Gulp" scheme="https://juntengma.github.io/tags/Gulp/"/>
    
  </entry>
  
  <entry>
    <title>JWT鉴权</title>
    <link href="https://juntengma.github.io/2020/11/27/Safe/JWT%E9%89%B4%E6%9D%83/"/>
    <id>https://juntengma.github.io/2020/11/27/Safe/JWT%E9%89%B4%E6%9D%83/</id>
    <published>2020-11-26T16:00:00.000Z</published>
    <updated>2020-11-27T02:26:38.424Z</updated>
    
    <content type="html"><![CDATA[<p>前端安全之 - JWT</p><a id="more"></a><h4 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT(JSON Web Token)"></a>JWT(JSON Web Token)</h4><h4 id="01-什么是JWT"><a href="#01-什么是JWT" class="headerlink" title="01/ 什么是JWT"></a>01/ 什么是JWT</h4><ul><li><p>JWT是JSON Web Token的缩写,是一种易用且无状态的鉴权方式</p></li><li><p>用于在各方之间以JSON对象安全传输信息。这些信息可以通过数字签名进行验证和信任。</p></li><li><p>简单来说就是server端把JSON数据经过加密做成Token,以授权给client端</p></li></ul><h4 id="02-栗子"><a href="#02-栗子" class="headerlink" title="02/ 栗子:"></a>02/ 栗子:</h4><p>当Client端登录完成以后，Server端要返回一个7天有效的token，那么对应的Python的样例代码会是这样的：<br>（<a href="https://link.zhihu.com/?target=https://github.com/jpadilla/pyjwt">使用了PyJWT包：pip install pyjwt</a>）</p><pre><code>import timeimport jwtexp = int(time.time()) + 86400 * 7  # 失效时间user = &#39;liriansu&#39;  # 用户表示key = &#39;hunter2&#39;  # 密钥payload = &#123;&#39;exp&#39;: exp, &#39;user&#39;: user&#125;  # JSON 数据token = jwt.encode(payload, key)print(token)# token可能会长这样子# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.EoKoMCjq_zGqUg5HDfqw4EN7EiG6gMjkUZle0uGJDGU</code></pre><p>然后Client端每次在authorization header或者是query string里带上token。<br>Server端收到请求的时候，<br>用<code>payload = jwt.decode(token, key)</code>验证权限就行了。<br>验证通过以后，payload中就是整个JSON数据。<br>理论上你可以往token payload里塞任何<strong>_非敏感</strong>_数据。</p><h4 id="03-使用场景"><a href="#03-使用场景" class="headerlink" title="03 / 使用场景"></a>03 / 使用场景</h4><ul><li><p>鉴权</p><p>用户一旦登录,后续的每个请求都需要携带jwt,允许该用户访问该令牌允许的路由,服务和资源.</p><p>单点登录是当前使用最广泛的JWT的一项功能,因为开销较小,并且能够跨域使用</p></li><li><p>信息交换</p><p>JWT是在各方之间安全传输信息的好方式,因为JWT可以签名：例如使用公钥/私钥对，所以可以确定发件人是他们自称的人。此外，由于使用标头和有效载荷计算签名，因此您还可以验证内容是否未被篡改。</p></li></ul><h4 id="04-JWT结构"><a href="#04-JWT结构" class="headerlink" title="04 /  JWT结构"></a>04 /  JWT结构</h4><p><code> eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.e30.EoKoMCjq_zGqUg5HDfqw4EN7EiG6gMjkUZle0uGJDGU</code></p><p>如上所示,JWT输出的是三个由点分隔的<code>xxxx.yyyy.zzzz</code>Base64-URL字符串，可以在HTML和HTTP环境中轻松传递，</p><p>他们分别代表:</p><ul><li>Header<ul><li>Header通常由两部分组成：令牌的类型，即JWT。和常用的散列算法</li><li>Header部分的JSON被Base64Url编码，形成JWT的第一部分。</li></ul></li><li>Payload<ul><li>存放沟通讯息的地方</li><li>Registered claims（注册声明）</li><li>Public claims（公开声明）</li><li>Private claims（私有声明）</li></ul></li><li>Signature<ul><li>用来验证发送请求者身份，由前两部分加密形成。</li></ul></li></ul><h4 id="04-所以综合来说，"><a href="#04-所以综合来说，" class="headerlink" title="04/ 所以综合来说，"></a>04/ 所以综合来说，</h4><p>假如使用JWT作为鉴权方式，<br>有以下几个特性：</p><ol><li>Client端不用管任何加密/解密，只用存token，在请求里面带上就行了。</li><li>Server端可以实现不依赖外部存储鉴权，所有的数据都丢在token里。</li><li>也就是说鉴权这一步不需要File/MySQL/Redis之类的数据库，也能知道用户身份。</li><li>因为token带失效时间，所以需要在失效前/后再刷新token。</li></ol><h4 id="05-常见问题"><a href="#05-常见问题" class="headerlink" title="05/ 常见问题"></a>05/ 常见问题</h4><h5 id="①-JWT-安全嗎"><a href="#①-JWT-安全嗎" class="headerlink" title="① JWT 安全嗎?"></a>① JWT 安全嗎?</h5><p>Base64编码方式是可逆的，也就是透过编码后发放的Token内容是可以被解析的。一般而言，我们都不建议在有效载荷内放敏感讯息，比如使用者的密码。</p><h5 id="②-JWT-Payload-內容可以被伪造嗎？"><a href="#②-JWT-Payload-內容可以被伪造嗎？" class="headerlink" title="② JWT Payload 內容可以被伪造嗎？"></a>② JWT Payload 內容可以被伪造嗎？</h5><p>JWT其中的一个组成内容为Signature，可以防止通过Base64可逆方法回推有效载荷内容并将其修改。因为Signature是经由Header跟Payload一起Base64组成的。</p><h5 id="③-如果我的-Cookie-被窃取了，那不就表示第三方可以做-CSRF-攻击"><a href="#③-如果我的-Cookie-被窃取了，那不就表示第三方可以做-CSRF-攻击" class="headerlink" title="③ 如果我的 Cookie 被窃取了，那不就表示第三方可以做 CSRF 攻击?"></a>③ 如果我的 Cookie 被窃取了，那不就表示第三方可以做 CSRF 攻击?</h5><p>是的，Cookie丢失，就表示身份就可以被伪造。故官方建议的使用方式是存放在LocalStorage中，并放在请求头中发送。</p><h5 id="④-空间及长度问题？"><a href="#④-空间及长度问题？" class="headerlink" title="④ 空间及长度问题？"></a>④ 空间及长度问题？</h5><p>JWT Token通常长度不会太小，特别是Stateless JWT Token，把所有的数据都编在Token里，很快的就会超过Cookie的大小（4K）或者是URL长度限制。</p><h5 id="⑤-Token失效问题？"><a href="#⑤-Token失效问题？" class="headerlink" title="⑤ Token失效问题？"></a>⑤ Token失效问题？</h5><p>无状态JWT令牌（Stateless JWT Token）发放出去之后，不能通过服务器端让令牌失效，必须等到过期时间过才会失去效用。</p><p>假设在这之间Token被拦截，或者有权限管理身份的差异造成授权Scope修改，都不能阻止发出去的Token失效并要求使用者重新请求新的Token。</p><h4 id="06-JWT使用建议"><a href="#06-JWT使用建议" class="headerlink" title="06/ JWT使用建议"></a>06/ JWT使用建议</h4><ul><li>不要存放敏感信息在Token里。</li><li>Payload中的exp时效不要设定太长。</li><li>开启Only Http预防XSS攻击。</li><li>如果担心重播攻击（replay attacks ）可以增加jti（JWT ID），exp（有效时间） Claim。</li><li>在你的应用程序应用层中增加黑名单机制，必要的时候可以进行Block做阻挡（这是针对掉令牌被第三方使用窃取的手动防御）。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端安全之 - JWT&lt;/p&gt;</summary>
    
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>a标签的url怎么会乱码嘞？？？？</title>
    <link href="https://juntengma.github.io/2020/11/26/JavaScript/JavaScript-a%E6%A0%87%E7%AD%BE%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://juntengma.github.io/2020/11/26/JavaScript/JavaScript-a%E6%A0%87%E7%AD%BE%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-11-25T16:00:00.000Z</published>
    <updated>2021-03-11T12:57:36.660Z</updated>
    
    <content type="html"><![CDATA[<p>最近写博客发现自己博客链接经常是一堆乱码 ，查了下资料发现是浏览器会将特殊字符转义，想要变回我们需要的样子需要对这个字符串解码~</p><a id="more"></a><p>类似下面这样 👿👿👿👿👿：<br><img src="https://s3.ax1x.com/2020/11/26/D0M9N8.png"></p><p>具体百度过程 😁 和调试过程 🙄（调试个棒槌）就不细说了 ， 这里是我得到的解决方案 ：<br>通过<code>decodeURI()</code>对链接进行解码 ， 我是这么写的</p><pre><code class="ejs"> &lt;a href=&quot;&lt;%= decodeURI(page.permalink) %&gt;&quot; target=&quot;_blank&quot;&gt;    &lt;%= decodeURI(page.permalink) %&gt;  &lt;/a&gt;</code></pre><p>所以最后我的链接就可以变回我需要的样子：<br><img src="https://s3.ax1x.com/2020/11/26/D0QdZq.png"></p><p>诶 ，说到这里就有人问我了：马老湿 ， 你这个 <code>decodeURI</code> 是干肾么用的呀？</p><p>我就啪的一下，很快啊~ ，给你甩出一个闪电五连鞭：</p><ul><li><a href="https://segmentfault.com/a/1190000013236956">《JS 对 url 进行编码和解码（三种方式）》</a></li><li><a href="https://segmentfault.com/a/1190000013236956">《JS 对 url 进行编码和解码（三种方式）》</a></li><li><a href="https://segmentfault.com/a/1190000013236956">《JS 对 url 进行编码和解码（三种方式）》</a></li><li><a href="https://segmentfault.com/a/1190000013236956">《JS 对 url 进行编码和解码（三种方式）》</a></li><li><a href="https://segmentfault.com/a/1190000013236956">《JS 对 url 进行编码和解码（三种方式）》</a></li></ul><p>并告诉你这个知识点我也是刚学从他这边学的 ， 而且年轻人一定要讲武德 <del>~</del></p><p>🤠👹🧐👻😼😽🙀😿😾🐱‍👤🐱‍🏍🐱‍💻🐱‍🐉🐱‍👓🐱‍🚀🙈🙉🙊🐵🐶🐺🐱🦁🦁🦒🦊</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近写博客发现自己博客链接经常是一堆乱码 ，查了下资料发现是浏览器会将特殊字符转义，想要变回我们需要的样子需要对这个字符串解码~&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>博客内容重新整理中~~~</title>
    <link href="https://juntengma.github.io/2020/11/23/React/%E8%87%AA%E5%AE%9A%E4%B9%89webpack%E9%85%8D%E7%BD%AE/"/>
    <id>https://juntengma.github.io/2020/11/23/React/%E8%87%AA%E5%AE%9A%E4%B9%89webpack%E9%85%8D%E7%BD%AE/</id>
    <published>2020-11-23T07:29:16.622Z</published>
    <updated>2021-03-11T13:03:50.026Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有写博客了，现在回头来看发现写的很烂，最近这段时间开始重新整理一下~</p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;好久没有写博客了，现在回头来看发现写的很烂，最近这段时间开始重新整理一下~&lt;/p&gt;</summary>
    
    
    
    <category term="tools" scheme="https://juntengma.github.io/categories/tools/"/>
    
    
    <category term="Git" scheme="https://juntengma.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>原型,原型链</title>
    <link href="https://juntengma.github.io/2020/11/20/JavaScript/07%20-%20JavaScript-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://juntengma.github.io/2020/11/20/JavaScript/07%20-%20JavaScript-%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2020-11-26T07:47:58.947Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  原型,原型链</h4></blockquote><a id="more"></a><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识:"></a>前置知识:</h3><ul><li><p>js分为函数对象和普通对象,,每个对象都有<code>_proto_</code>属性,但是只有函数对象才有<code>prototype</code>属性</p></li><li><p>Object,Function都是js内置函数,类似的还有Array , RegExp , Date , Boolean , Nuber , String </p></li><li><p><code>_porto_</code>,<code>constructor</code>属性是<strong>对象</strong>所独有的</p></li><li><p><code>prototype</code>属性是<strong>函数</strong>所独有的</p></li><li><p>函数也是对象的一种,所以函数中也有<code>_protot_</code>和<code>constructor</code></p></li></ul><h3 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h3><pre><code>function Peron() &#123; &#125;var person = new Person()person.name = &#39;kevin&#39;console.log(person.name)</code></pre><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>每个函数都有<code>prototype</code>属性</p><pre><code>function Person() &#123; &#125;Person.prototype.name = &#39;kavin&#39;var person1 = new Person()var person2 = new Person()console.log(person1.name); //kavinconsole.log(person2.name); //kavin</code></pre><ul><li>函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。</li><li>那什么是原型呢？每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型中继承属性</li></ul><p><strong>构造函数和实例原型之间的关系</strong></p><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype1.png"></p><h3 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a><code>_proto_</code></h3><p>每一个js对象都有一个属性,就是<code>_Proto_</code>,这个属性会指向该对象的原型</p><pre><code>function Person() &#123; &#125;var person = new Person()console.log(person.__proto__ === Person.prototype); //true</code></pre><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype2.png"></p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>consttructor指向该构造函数本身,即</p><pre><code>Person.prototype.constructor = Person</code></pre><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype3.png"></p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a><a href="https://segmentfault.com/a/1190000008959943">原型链</a></h3><p><img src="https://github.com/mqyqingfeng/Blog/raw/master/Images/prototype5.png"></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 原型,原型链
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="原型原型链" scheme="https://juntengma.github.io/tags/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>防抖节流及其应用场景</title>
    <link href="https://juntengma.github.io/2020/11/20/JavaScript/08.1%20-%20JavaScript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    <id>https://juntengma.github.io/2020/11/20/JavaScript/08.1%20-%20JavaScript-%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/</id>
    <published>2020-11-19T16:00:00.000Z</published>
    <updated>2020-11-26T07:47:41.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  复习一下防抖节流及其应用场景</h4></blockquote><a id="more"></a><h3 id="函数防抖"><a href="#函数防抖" class="headerlink" title="函数防抖"></a>函数防抖</h3><p>在事件被触发的n秒后再执行回调,如果在这n秒内又被触发,则重新计时</p><pre><code>function debounse(fun, delay) &#123;    let timer;    // 设置一个 timer    return function (args) &#123;      let _this = this      let _args = args      clearTimeout(timer)      timer = setTimeout(function () &#123;        fun.call(_this, _args);      &#125;, delay);    &#125;  &#125;</code></pre><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p><pre><code>function throttle(fun, delay) &#123;    let last, timer    return function (args) &#123;      let _this = this      let _args = args      let now = +new Date()      if (last &amp;&amp; now &lt; last + delay) &#123;        clearTimeout(timer)        timer = setTimeout(function () &#123;          last = now          fun.apply(_this, _args)        &#125;, delay)      &#125; else &#123;        last = now        fun.apply(_this, _args)      &#125;    &#125;  &#125;</code></pre><h3 id="demo"><a href="#demo" class="headerlink" title="demo:"></a>demo:</h3><h5 id="模拟ajax请求"><a href="#模拟ajax请求" class="headerlink" title="模拟ajax请求"></a>模拟ajax请求</h5><pre><code>function ajax(params) &#123;    console.log(&#39;ajax request : &#39; + params)&#125;</code></pre><h5 id="普通input"><a href="#普通input" class="headerlink" title="普通input:"></a>普通input:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252be5c94d6b?imageslim"></p><h5 id="加入防抖"><a href="#加入防抖" class="headerlink" title="加入防抖:"></a>加入防抖:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4b429b56?imageslim"></p><h5 id="加入节流"><a href="#加入节流" class="headerlink" title="加入节流:"></a>加入节流:</h5><p><img src="https://user-gold-cdn.xitu.io/2018/9/4/165a252b4c1a9686?imageslim"></p><h3 id="demo代码"><a href="#demo代码" class="headerlink" title="demo代码"></a>demo代码</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  没有防抖的Input &lt;input type=&quot;text&quot; class=&quot;unDebounce&quot;&gt;  &lt;br&gt;  加入防抖的Input &lt;input type=&quot;text&quot; class=&quot;debounce&quot;&gt;  &lt;br&gt;  加入截留的Input &lt;input type=&quot;text&quot; class=&quot;htrottle&quot;&gt;&lt;/body&gt;&lt;script&gt;  function ajax(params) &#123;    console.log(&#39;ajax request : &#39; + params)  &#125;  let inputValue0 = document.querySelector(&#39;.unDebounce&#39;)  inputValue0.addEventListener(&#39;keyup&#39;, function (e) &#123;    ajax(e.target.value)  &#125;)  /**********************防抖********************************/  function debounse(fun, delay) &#123;    let timer;    // 设置一个 timer    return function (args) &#123;      let _this = this      // 取debounce执行作用域的this      let _args = args      clearTimeout(timer)      timer = setTimeout(function () &#123;        fun.call(_this, args);      &#125;, delay);    &#125;  &#125;  let inputValue1 = document.querySelector(&#39;.debounce&#39;)  let debounse_ajax = debounse(ajax, 500)  inputValue1.addEventListener(&#39;keyup&#39;, function (e) &#123;    debounse_ajax(e.target.value)  &#125;)  /**********************节流********************************/  function throttle(fun, delay) &#123;    let last, timer    return function (args) &#123;      let _this = this      let _args = args      let now = +new Date()      if (last &amp;&amp; now &lt; last + delay) &#123;        clearTimeout(timer)        timer = setTimeout(function () &#123;          last = now          fun.apply(_this, _args)        &#125;, delay)      &#125; else &#123;        last = now        fun.apply(_this, _args)      &#125;    &#125;  &#125;  let inputValue2 = document.querySelector(&#39;.htrottle&#39;)  let htrottle_ajax = throttle(ajax, 2000)  inputValue2.addEventListener(&#39;keyup&#39;, function (e) &#123;    htrottle_ajax(e.target.value)  &#125;)&lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 复习一下防抖节流及其应用场景
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="防抖节流" scheme="https://juntengma.github.io/tags/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript作用域&amp;可执行上下文</title>
    <link href="https://juntengma.github.io/2020/11/16/JavaScript/03%20-%20JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://juntengma.github.io/2020/11/16/JavaScript/03%20-%20JavaScript-%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2020-11-15T16:00:00.000Z</published>
    <updated>2020-11-26T07:48:45.076Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>JavaScript深入 - 作用域相关问题</p></blockquote><a id="more"></a><h3 id="01-什么是作用域"><a href="#01-什么是作用域" class="headerlink" title="01 / 什么是作用域?"></a>01 / 什么是作用域?</h3><p><strong>作用域是指程序源代码中定义变量的区域:</strong></p><ul><li>作用域规定了当前执行代码对变量的访问权限</li><li>JavaScript采用词法作用域(静态作用域)</li></ul><h3 id="02-词法作用域和静态作用域的区别"><a href="#02-词法作用域和静态作用域的区别" class="headerlink" title="02 / 词法作用域和静态作用域的区别?"></a>02 / 词法作用域和静态作用域的区别?</h3><ul><li>静态作用域:    函数的作用域在函数定义的时候就已经决定了</li><li>动态作用域: 函数的作用域在函数调用的时候才决定</li></ul><h3 id="03-作用域包含两种"><a href="#03-作用域包含两种" class="headerlink" title="03 / 作用域包含两种:"></a>03 / 作用域包含两种:</h3><ul><li>全局作用域<ul><li>最外层函数和在最外层函数外面定义的变量拥有全局作用域</li><li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li><li>所有 window 对象的属性拥有全局作用域</li></ul></li><li>函数作用域<ul><li>指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到</li></ul></li><li>块级作用域<ul><li>块级作用域可通过新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;JavaScript深入 - 作用域相关问题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="作用域&amp;可执行上下文" scheme="https://juntengma.github.io/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>浏览器解析js流程</title>
    <link href="https://juntengma.github.io/2020/11/16/JavaScript/05%20-%20JavaScript-%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF(Event%20Loop)/"/>
    <id>https://juntengma.github.io/2020/11/16/JavaScript/05%20-%20JavaScript-%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF(Event%20Loop)/</id>
    <published>2020-11-15T16:00:00.000Z</published>
    <updated>2020-11-26T07:48:25.503Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  浏览器解析js流程</h4></blockquote><a id="more"></a><h4 id="JS解析"><a href="#JS解析" class="headerlink" title="JS解析"></a>JS解析</h4><p><a href="https://imgchr.com/i/BufjDe"><img src="https://s1.ax1x.com/2020/10/26/BufjDe.png" alt="BufjDe.png"></a></p><p>js解析是由浏览器    </p><p>js是单线程运行,也就是说同时只能做一件事,所有任务都需要排队,</p><p>为了解决某些任务比较耗时,需要一种机制来使其可以执行排在后面的任务,就出现了同步任务和异步任务</p><p>JS执行机制可以看做一个主线程加上一个任务队列.</p><p>同步任务就是主线程上面执行的任务 , 异步任务就是放在任务队列的任务</p><p>所有的同步任务都在主线程上面执行,形成一个执行栈</p><p>异步任务有了运行结果就会在任务队列中放置一个事件,脚本运行时依次运行执行栈,然后会从任务队列中提取事件,</p><p>运行任务队列中的任务,该过程是不断重复的,所以又叫<strong>做事件循环</strong>(Event loop)</p><ul><li>浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。</li><li>请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。</li><li>原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。</li><li>CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 浏览器解析js流程
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="浏览器解析js流程" scheme="https://juntengma.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90js%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面加载发生了什么</title>
    <link href="https://juntengma.github.io/2020/11/16/JavaScript/06%20-%20%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>https://juntengma.github.io/2020/11/16/JavaScript/06%20-%20%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2020-11-15T16:00:00.000Z</published>
    <updated>2020-11-26T07:48:12.967Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  从输入URL到页面加载发生了什么???</h4></blockquote><a id="more"></a><p>总体来说分为以下几个过程:</p><ul><li><a href="#01-dns%E8%A7%A3%E6%9E%90">01/ DNS解析</a><ul><li><a href="#dns%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B">DNS解析过程</a></li></ul></li><li><a href="#02-tcp%E8%BF%9E%E6%8E%A5">02 /TCP连接</a></li><li><a href="#03-%E5%8F%91%E9%80%81http%E8%AF%B7%E6%B1%82">03 /发送HTTP请求</a></li><li><a href="#04-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E5%B9%B6%E8%BF%94%E5%9B%9Ehttp%E6%8A%A5%E6%96%87">04 /服务器处理请求并返回HTTP报文</a></li><li><a href="#05-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2">05 /浏览器解析渲染页面</a></li></ul><h3 id="01-DNS解析"><a href="#01-DNS解析" class="headerlink" title="01/ DNS解析"></a>01/ DNS解析</h3><p>DNS解析的过程就是在寻找哪台机器上有你需要的资源的全过程.<br>当你在浏览器中输入一个地址时,将网址转换为IP的过程叫做DNS解析</p><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS解析本质上是一个递归查询的过程</p><p><img src="https://s3.ax1x.com/2020/11/16/DAFZeU.png"></p><p>上图是查找<code>www.google.com</code>这个网址的过程</p><ol><li>在<code>本地域名服务器</code>中查询IP地址–&gt;无</li><li><code>本地域名服务器</code>向<code>根域名服务器</code>发送请求–&gt;无</li><li><code>本地域名服务器</code> 向<code>COM顶级域名服务器</code>发送请求–&gt;无</li><li>……</li><li>最后本地服务器得到Google的IP的字号并缓存到本地,功下次使用</li></ol><p>由上可以看出网址解析是一个 从右到左的过程:<br><code>com</code> –&gt; <code>google.com</code> –&gt; <code>www.google.com</code><br>根域名服务器呢?<br>默认情况下所有网址最后一位都是. , 即<code>www.google.com.</code>,方便用户一般都会省略,浏览器在请求DNS的时候会自动加上,<br>即NDS解析流程:<br><code>.</code>–&gt;<code>com.</code>–&gt;<code>google.com.</code>–&gt;<code>www.google.com.</code></p><h3 id="02-TCP连接"><a href="#02-TCP连接" class="headerlink" title="02 /TCP连接"></a>02 /TCP连接</h3><p>HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。</p><p>三次握手:</p><ul><li>主机A向主机B发送TCP连接请求数据包</li><li>主机B收到请求后，会发回连接确认数据包。 </li><li>第三次，主机A收到主机B的确认报文后，还需作出确认，即发送一个序列号seq(A)=x+1；确认号为ack(A)=y+1的报文；</li></ul><p>四次挥手:(假设主机A为客户端，主机B为服务器，其释放TCP连接的过程如下)</p><ul><li>客户端向服务端发送关闭链接的请求</li><li>服务器收到请求之后,回复这个请求并确认</li><li>服务端也发送一个关闭链接的请求给客户端</li><li>客户端收到请求之后确认关闭然后断开tcp链接</li></ul><h3 id="03-发送HTTP请求"><a href="#03-发送HTTP请求" class="headerlink" title="03 /发送HTTP请求"></a>03 /发送HTTP请求</h3><ul><li>HTTP报文是包裹在tcp报文中发送的,服务端收到TCP报文时会解包提取出HTTP报文,但是该过程存在一定风险,HTTP报文是明文,如果中间被截取的话会存在一些信息泄露的风险</li><li>HTTPS协议本质就是HTTP+SSL,在HTTP报文进入TCP报文之前,先使用SSL报文进行加密.从网络层的结构看它位于HTTP协议与TCP协议之间<br><a href="https://imgchr.com/i/BunpMn"><img src="https://s1.ax1x.com/2020/10/26/BunpMn.png" alt="BunpMn.png"></a></li></ul><p><strong>HTTPS过程:</strong></p><p>HTTPS在传输数据之前需要客户端与服务器进行一个握手(TSL/SSL握手),在握手的过程中将确立对方家里传输数据的密码信息.TLS/SSL使用了非对称加密,对称加密以及hash等.</p><p>HTTPS相对于HTTP,虽然提供了安全保证,但势必会造成一些时间上的损耗,如握手和加密等过程,使用前需要做好安全和性能方面的权衡</p><p><strong>HTTP请求:</strong></p><p>http请求主要发生在客户端.发送http请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080,HTTPS协议443)<br>http请求报文由三部分组成</p><ul><li><p>请求行 ( 常用方法有get,post,put,delete…等)</p></li><li><p>请求报头(请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息)</p><p><img src="https://s3.ax1x.com/2020/11/16/DAklNQ.png"></p><blockquote><p>上图是使用Chrome开发者工具截取的对百度的HTTP请求以及响应报文，从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</p></blockquote></li><li><p>请求正文(客户端向服务端传递的数据)</p><blockquote><p>上图是使用Chrome开发者工具截取的对百度的HTTP请求以及响应报文，从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</p></blockquote><h3 id="04-服务器处理请求并返回HTTP报文"><a href="#04-服务器处理请求并返回HTTP报文" class="headerlink" title="04 /服务器处理请求并返回HTTP报文"></a>04 /服务器处理请求并返回HTTP报文</h3><p>HTTP响应报文也是由三部分组成: <strong>状态码</strong>, <strong>响应报头</strong>和<strong>响应报文</strong>。</p></li></ul><p><strong>状态码</strong><br>状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p><ul><li>1xx:指示信息 - 表示请求已接收,继续处理</li><li>2xx:成功 - 表示请求已被成功接收,理解,处理</li><li>3xx:重定向 -  要完成请求必须进行更进一步的操作</li><li>4xx:客户端错误 - 请求有语法错误或请求无法实现.</li><li>5xx:服务端错误 - 服务器未能实现合法请求</li></ul><p><strong>常见错误码:</strong></p><ul><li>200:请求成功</li><li>204:无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</li><li>301:永久移动。请求的资源已被永久的重定向到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</li><li>302:临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</li><li>304:未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</li><li>400:客户端请求的语法错误，服务器无法理解</li><li>401:请求要求用户的身份认证</li><li>403:服务器理解请求客户端的请求，但是拒绝执行此请求</li><li>404:服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</li><li>422:请求格式正确，但是由于含有语义错误，无法响应。</li><li>500:服务器内部错误，无法完成请求</li></ul><h3 id="05-浏览器解析渲染页面"><a href="#05-浏览器解析渲染页面" class="headerlink" title="05 /浏览器解析渲染页面"></a>05 /浏览器解析渲染页面</h3><p>浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。</p><p><img src="https://s3.ax1x.com/2020/11/16/DAAsIg.png"></p><p>浏览器是一个边解析边渲染的过程。</p><ul><li>首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</li><li>这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;</li><li>当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。</li><li>页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。</li></ul><p>该过程涉及到两个概念 : <strong>重绘</strong>,<strong>回流</strong></p><ul><li>**回流:**DOM节点中的各个元素都是以盒模型的形式存在,需要浏览器来计算其位置和大小等,该过程叫做回流</li><li>**重绘:**当盒模型的位置,大小以及其他属性,如颜色,字体等确定下来之后,浏览器就开始绘制内容,该过程叫做重绘</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 从输入URL到页面加载发生了什么???
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="从输入URL到页面加载发生了什么" scheme="https://juntengma.github.io/tags/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://juntengma.github.io/2020/11/15/JavaScript/09%20-%20JavaScript-Promise/"/>
    <id>https://juntengma.github.io/2020/11/15/JavaScript/09%20-%20JavaScript-Promise/</id>
    <published>2020-11-14T16:00:00.000Z</published>
    <updated>2020-11-26T07:47:33.254Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4> 前端异步处理之 - Promise vs async/await</h4></blockquote><a id="more"></a><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="1-js回调地狱"><a href="#1-js回调地狱" class="headerlink" title="1/ js回调地狱"></a>1/ js回调地狱</h4><blockquote><p>在开发过程中我们经常遇到这种情况: </p><p>异步js或使用回调的js很难直观地得到正确的结果 , 一个异步函数的输出是另外一个异步函数的输入,如果嵌套层数过多，可读性和可以维护性都会变得很差，产生所谓的“回调地狱</p></blockquote><pre><code>let fs = require(&#39;fs&#39;)fs.readFile(&#39;./name.txt&#39;,&#39;utf8&#39;,function(err,data)&#123;  fs.readFile(data, &#39;utf8&#39;,function(err,data)&#123;    fs.readFile(data,&#39;utf8&#39;,function(err,data)&#123;      console.log(data);    &#125;)  &#125;)&#125;)</code></pre><p>总结一下回调地狱出现的原因:</p><ul><li><strong>嵌套调用</strong>，第一个函数的输出往往是第二个函数的输入；<ul><li><strong>处理多个异步请求并发</strong>，开发时往往需要同步请求最终的结果;</li></ul></li></ul><h4 id="2-怎么处理回调地狱"><a href="#2-怎么处理回调地狱" class="headerlink" title="2/ 怎么处理回调地狱"></a>2/ 怎么处理回调地狱</h4><ul><li><strong>消灭嵌套调用</strong>：通过 Promise 的链式调用可以解决(.then())；</li><li><strong>合并多个任务的请求结果</strong>：使用 Promise.all 获取合并多个任务的错误处理。</li></ul><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="1-什么是promise"><a href="#1-什么是promise" class="headerlink" title="1.什么是promise?"></a>1.什么是promise?</h4><p><img src="https://s3.ax1x.com/2020/11/13/DS4cZt.png"><br> 如上图所示,Promise是一个构造函数,身上有</p><ul><li><p>all()</p></li><li><p>reject()</p></li><li><p>resolve()几个方法,</p></li></ul><p>prototype上有</p><ul><li>then()</li><li>catch()等方法</li></ul><h4 id="2-Promise的特征"><a href="#2-Promise的特征" class="headerlink" title="2.Promise的特征"></a>2.Promise的特征</h4><ul><li>对象的状态不受外界影响,<code>Promise</code>对象代表一个异步操作，有下面这三种状态,只有异步操作可以决定当前是哪种状态<ul><li>pending(进行中)</li><li>fulfilled(成功)</li><li>rejected(失败)</li></ul></li><li>状态一旦改变, 结果就不再变化,Promise状态只可能会出现下面两种情况<ul><li>pending —&gt; fulfilled</li><li>pending —&gt; rejected</li></ul></li></ul><p><strong><code>Promise</code>的优点：</strong></p><p><strong>可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</strong></p><h4 id="3-Promise怎么创建"><a href="#3-Promise怎么创建" class="headerlink" title="3.Promise怎么创建?"></a>3.Promise怎么创建?</h4><ul><li><code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 <code>JavaScript</code> 引擎提供，不用自己部署</li><li><code>resolve</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；</li><li><code>reject</code>函数的作用是，将<code>Promise</code>对象的状态从“未完成”变为“失败”（即从 <code>pending</code>变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li></ul><pre><code class="js">let promise = new Promise((resolve, reject) =&gt; &#123;  //此处执行一些异步操作（调用后台API，定时器等）  if (/*异步操作成功*/) &#123;    resolve(value);  &#125; else &#123;    reject(error)  &#125;&#125;)</code></pre><ul><li><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。</li><li>其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</li></ul><pre><code>promise.then(res=&gt;&#123;    //对于成功回调接受的数据做处理&#125;,err=&gt;&#123;    //对于失败的回调数据做处理&#125;)</code></pre><h4 id="4-实现一个符合PromiseA-规范的Promise"><a href="#4-实现一个符合PromiseA-规范的Promise" class="headerlink" title="4. 实现一个符合PromiseA+规范的Promise"></a>4. 实现一个符合PromiseA+规范的Promise</h4><p>该版本只能简单实现处理同步/异步函数, then的链式调用并没有真正实现…需要再做研究</p><pre><code>//1.先定义三个状态const PENDING = &quot;PENDING&quot;;const FULFILLED = &quot;FULFILLED&quot;;const REJECTED = &quot;REJECTED&quot;;//2.clss实例化一个promiseclass Promise &#123;  constructor(executor) &#123;    this.status = PENDING;    //存放成功状态    this.success = undefined;    //存放失败状态    this.error = undefined;    // 存放成功的回调    this.onResolvedCallbacks = [];    // 存放失败的回调    this.onRejectedCallbacks = [];        //3.实现resolve , reject    let resolve = (value) =&gt; &#123;      if (this.status === PENDING) &#123;        this.status = FULFILLED;        this.success = value;        //这句话的意思是把存储起来的异步回调也执行掉        this.onResolvedCallbacks.forEach(fn =&gt; fn());      &#125;    &#125;    let reject = (error) =&gt; &#123;      if (this.status === PENDING) &#123;        this.status = REJECTED;        this.error = error;        this.onRejectedCallbacks.forEach(fn =&gt; fn());      &#125;    &#125;     //异常捕获    try &#123;      executor(resolve, reject)    &#125; catch (error) &#123;      reject(error)    &#125;  &#125;    //4.实现then方法  then(onFulfilled, onRejected) &#123;    if (this.status === FULFILLED) &#123;      return onFulfilled(this.success)    &#125;    if (this.status === REJECTED) &#123;      return onRejected(this.error)    &#125;    if (this.status === PENDING) &#123;      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行      this.onResolvedCallbacks.push(() =&gt; &#123;        onFulfilled(this.success)      &#125;);      this.onRejectedCallbacks.push(() =&gt; &#123;        onRejected(this.error);      &#125;)    &#125;  &#125;&#125;//测试demolet promise = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(&#39;ok&#39;)  &#125;, 2000)&#125;).then((success) =&gt; &#123;  console.log(&#39;success&#39;, success)&#125;, (error) =&gt; &#123;  console.log(&#39;error&#39;)&#125;)// success ok</code></pre><h4 id="5-async-await"><a href="#5-async-await" class="headerlink" title="5. async/await"></a>5. async/await</h4><blockquote><p>一种相对Promise更为优雅的异步函数处理方案</p></blockquote><p>5.1    什么是async/await</p><ul><li><code>async</code>是异步的意思</li><li><code>await</code>有等待的意思</li><li><code>async</code>用于申明一个<code>function</code>是异步的，而<code>await</code> 用于等待一个异步方法执行完成。</li></ul><p>5.2     使用</p><pre><code>async getAjaxData()&#123;    let res = await sendAjax()&#125;</code></pre><p>5.3 注意事项</p><pre><code>- await操作符等的是一个返回的结果，那么如果是同步的情况，那就直接返回了。- 如果是异步的情况下，await会阻塞整一个流程，直到结果返回之后，才会继续下面的代码。阻塞代码是一个很可怕的事情，而async函数，会被包在一个promise中，异步去执行。所以await只能在async函数中使用，如果在正常程序中使用，会造成整个程序阻塞，得不偿失。</code></pre><h4 id="6-Promise-和-async-await区别"><a href="#6-Promise-和-async-await区别" class="headerlink" title="6.Promise 和 async/await区别"></a>6.Promise 和 async/await区别</h4><p>直接上代码</p><ul><li>Promise版本</li></ul><pre><code>function doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 = 300;    step1(time1)        .then(time2 =&gt; &#123;            return step2(time1, time2)                .then(time3 =&gt; [time1, time2, time3]);        &#125;)        .then(times =&gt; &#123;            const [time1, time2, time3] = times;            return step3(time1, time2, time3);        &#125;)        .then(result =&gt; &#123;            console.log(`result is $&#123;result&#125;`);            console.timeEnd(&quot;doIt&quot;);        &#125;);&#125;doIt();</code></pre><ul><li>async / await 版本</li></ul><pre><code>async function doIt() &#123;    console.time(&quot;doIt&quot;);    const time1 = 300;    const time2 = await step1(time1);    const time3 = await step2(time1, time2);    const result = await step3(time1, time2, time3);    console.log(`result is $&#123;result&#125;`);    console.timeEnd(&quot;doIt&quot;);&#125;doIt();</code></pre><p>更详细的可以参考:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/288384170">&lt;&lt;你不知道的promise&gt;&gt;</a></li><li><a href="https://juejin.im/post/6844903843507994632">&lt;&lt;学习Promise基础及手写Promise&gt;&gt;</a></li><li><a href="https://juejin.im/post/6844903960910757902">&lt;&lt;理解async/await&gt;&gt;</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
前端异步处理之 - Promise vs async/await
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="Promise" scheme="https://juntengma.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>深拷贝浅拷贝</title>
    <link href="https://juntengma.github.io/2020/11/15/JavaScript/JavaScript-%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>https://juntengma.github.io/2020/11/15/JavaScript/JavaScript-%E6%B5%85%E6%8B%B7%E8%B4%9D%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-11-14T16:00:00.000Z</published>
    <updated>2020-11-26T07:46:24.433Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4>  深拷贝浅拷贝</h4></blockquote><a id="more"></a><p><a href="https://juejin.im/post/6844903929705136141">https://juejin.im/post/6844903929705136141</a></p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。</p><p>如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><p>浅拷贝只拷贝一层属性,无法拷贝引用数据类型</p><ul><li><code>Object.assign(&#123;&#125;,obj)</code>浅拷贝object</li><li><code>newobj = &#123;...obj2&#125;</code>  展开运算符浅拷贝</li><li><code>Object.fromEntries( Object.entriens(obj) ) </code>通过生成迭代器,在通过迭代器生成对象</li><li><code>Object.create(&#123;&#125;,Object.getOwnPropertyDescriptors(obj))</code></li></ul><p><strong>简单浅拷贝:</strong></p><pre><code>function clone(target)&#123;    let cloneTarget=&#123;&#125;;    for(let key in target)&#123;        cloneTarget[key] = target[key]    &#125;    return cloneTarget&#125;</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><ul><li><code>JSON.parse(JSON.stringfy( obj ))</code>通过<strong>JSON的2次转换深拷贝obj</strong><ul><li>无法拷贝<code>undefined</code>与<code>symbol</code>属性</li><li>无法拷贝<strong>循环引用</strong>对象</li></ul></li><li>loadsh:<a href="http://lodash.think2011.net/cloneDeep"><em>.cloneDeep</em></a></li></ul><p>简单深拷贝(可以处理<strong>原始数据类型 + Object</strong>):</p><ul><li>如果是原始类型，无需继续拷贝，直接返回</li><li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行深拷贝后依次添加到新对象上。</li></ul><pre><code>function smpleDeepCopy(target) &#123;  let type = typeof target  if (type === &quot;object&quot;) &#123;    let copy = &#123;&#125;;    for (let key in target) &#123;      copy[key] = smpleDeepCopy(target[key])    &#125;    return copy  &#125;  return target&#125;</code></pre>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
 深拷贝浅拷贝
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="深拷贝浅拷贝" scheme="https://juntengma.github.io/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="https://juntengma.github.io/2020/11/12/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%89%91%E6%8C%87offer/"/>
    <id>https://juntengma.github.io/2020/11/12/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%89%91%E6%8C%87offer/</id>
    <published>2020-11-12T11:53:26.042Z</published>
    <updated>2020-11-16T02:14:57.811Z</updated>
    
    <content type="html"><![CDATA[<p>[1/二维数组中的查找](#1/ 二维数组中的查找)</p><p>[2/ 替换空格](#2/ 替换空格)</p><h4 id="1-二维数组中的查找"><a href="#1-二维数组中的查找" class="headerlink" title="1/ 二维数组中的查找"></a>1/ 二维数组中的查找</h4><blockquote><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>demo:</p><ul><li><p>输入</p><pre><code>7,[[1,2,8,9],[2,4,9,12],[4,7,10,13],[6,8,11,15]]</code></pre></li><li><p>输出</p><pre><code>true</code></pre></li></ul></blockquote><pre><code>function Find(target, array) &#123;  for(let i=0;i&lt;array.length;i++)&#123;    if(array[i].indexOf(target)!==-1)&#123;      return true    &#125;  &#125;  return false&#125;</code></pre><h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2/ 替换空格"></a>2/ 替换空格</h4><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><pre><code>function replaceSpace(str)&#123;  return str.replace(/ /g,&#39;%20&#39;)&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[1/二维数组中的查找](#1/ 二维数组中的查找)&lt;/p&gt;
&lt;p&gt;[2/ 替换空格](#2/ 替换空格)&lt;/p&gt;
&lt;h4 id=&quot;1-二维数组中的查找&quot;&gt;&lt;a href=&quot;#1-二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;1/ 二维数组中的查找</summary>
      
    
    
    
    <category term="算法" scheme="https://juntengma.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://juntengma.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>React学习</title>
    <link href="https://juntengma.github.io/2020/11/09/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://juntengma.github.io/2020/11/09/React/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-11-09T08:58:59.845Z</published>
    <updated>2020-11-20T08:28:28.997Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React基础知识汇总"><a href="#React基础知识汇总" class="headerlink" title="React基础知识汇总"></a>React基础知识汇总</h4><p>[TOC]</p><a id="more"></a><h4 id="01-生命周期"><a href="#01-生命周期" class="headerlink" title="01 / 生命周期"></a>01 / 生命周期</h4><p><strong>react15生命周期</strong><img src="https://s1.ax1x.com/2020/11/10/BLFB1P.png"></p><p>React的生命周期就是组件从初始化到卸载到全过程，可以分为以下几个阶段</p><ul><li>初始化阶段(<ul><li><strong>constructor()</strong>, </li><li><strong>componentWillMount</strong>(),</li><li><strong>render</strong>(), </li><li><strong>componentDidMount</strong>()</li></ul></li><li>更新阶段<ul><li><strong>componentWillReceiveProps</strong>(),</li><li><strong>shouldComponentUpdate</strong>(), </li><li><strong>componentWillUpdate</strong>(), </li><li><strong>render</strong>(), </li><li><strong>componentDidUpdate</strong>()</li></ul></li><li>卸载阶段<ul><li><strong>componentWillUnmont</strong>()</li></ul></li></ul><p>这里需要注意的是更新阶段，componentWillReceiveProps是由父组件触发的更新，只要父组件更新，子组件的该生命周期就会被执行，跟props无关。同是，shouldComponentUpdate可以用来做性能优化</p><p><strong>react16生命周期</strong></p><p><img src="https://s1.ax1x.com/2020/11/10/BLkabF.png"></p><p>在React16的生命周期中，去掉了曾经的<strong>componentWillMount</strong>和<strong>componentWillUpdate</strong>，使用<strong>getDerivedStateFromProps</strong>代替这两个方法。同时在更新阶段的render方法和componentDidUpdate之间，新增了一个<strong>getSnapshotBeforeUpdate</strong>方法。接下来就来详细了解一下React这么做的原理以及这些新增生命周期的具体使用</p><p><strong>react15和react16的区别</strong></p><ul><li><h6 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLu3c9.png"></p><ul><li><p><code>-</code>    componentWillMount()</p></li><li><p><code>+</code>    getDerivedStateFromProps()</p><ol><li><p>getDerivedStateFromProps() 主要用于替换 componentWillReceiveProps() 的</p></li><li><p>getDerivedStateFromProps是一个静态方法 , 需要使用static声明</p></li><li><p>getDerivedStateFromProps 接收两个参数, 父组件传递过来的props和自身state</p></li><li><p>必须返回一个对象格式的返回值，否则控制台会被警告</p></li><li><p>该返回值会被用来更新现有state(并不会覆盖原有State，只做定向更新，如果原来State中没有该属性，则新增)，如果没有需要更新的时候，请记得返回一个null</p><pre><code>static getDerivedStateFromProps(props,state)&#123;  return newState&#125;</code></pre></li></ol></li></ul></li><li><h6 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h6><p><img src="https://s1.ax1x.com/2020/11/10/BLMPMj.png"></p><ul><li><code>-</code>componentWillReceiveProps()</li><li><code>+</code>getDerivedStateFormProps()</li><li><code>-</code>componentWillupdate()</li><li><code>+</code>getSnapshotBetforeupdate()</li></ul></li></ul><p>React16中也去掉了componentWillUpdate方法，新增了getSnapshotBeforeUpdate方法，这个方法在render方法之后，componentDidUpdate之前被执行，即真实DOM更新之前（获取更新前的真实DOM和更新前后的State&amp;props信息）。该方法需要一个返回值，作为componentDidUpdate的第三个参数。</p><ul><li><h6 id="componentWillReceiveProps-和getDerivedStateFormProps-区别"><a href="#componentWillReceiveProps-和getDerivedStateFormProps-区别" class="headerlink" title="componentWillReceiveProps()和getDerivedStateFormProps()区别"></a>componentWillReceiveProps()和getDerivedStateFormProps()区别</h6></li></ul><table><thead><tr><th>getDerivedStateFormProps( props , state )</th><th>componentWillReceiveProps( nextPorps )</th></tr></thead><tbody><tr><td>使用static 声明: <code>static getDerivedStateFormProps( props , state )&#123;&#125;</code></td><td>直接声明: <code>componentWillReceiveProps( nextPorps )&#123;&#125;</code></td></tr><tr><td><strong>在组件挂载阶段即可执行,父组件更新执行</strong></td><td><strong>只在父组件更新的时候执行</strong></td></tr><tr><td>接收两个参数:  props  ,  state</td><td>接收一个参数( nextPorps )</td></tr><tr><td><strong>必须返回一个对象格式的返回值 或 null</strong></td><td><strong>可以直接更新state状态</strong></td></tr></tbody></table><p><strong>demo:</strong></p><pre><code>  static getDerivedStateFromProps(props, state) &#123;    if (props.age !== state.age) &#123;      return &#123; age: props.age &#125;      // 类似setStae      // this.setState(&#123;      //   age: props.age      // &#125;);    &#125;    return null  &#125;</code></pre><pre><code>  componentWillReceiveProps(nextporps) &#123;    if (nextporps.age !== this.state.age) &#123;      this.setState(&#123;        age: nextporps.age       &#125;);    &#125;  &#125;</code></pre><h4 id="02-Virtual-Dom"><a href="#02-Virtual-Dom" class="headerlink" title="02 / Virtual Dom"></a>02 / Virtual Dom</h4><ul><li><p>什么是Virtual Dom?</p><ul><li>在原生的<code>JavaScript</code>程序中，我们直接对<code>DOM</code>进行创建和更改，而<code>DOM</code>元素通过我们监听的事件和我们的应用程序进行通讯。</li><li><code>React</code>会先将你的代码转换成一个<code>JavaScript</code>对象，然后这个<code>JavaScript</code>对象再转换成真实<code>DOM</code>。这个<code>JavaScript</code>对象就是所谓的虚拟<code>DOM</code>。</li><li>当我们需要创建或更新元素时，<code>React</code>首先会让这个<code>VitrualDom</code>对象进行创建和更改，然后再将<code>VitrualDom</code>对象渲染成真实<code>DOM</code>；</li><li>当我们需要对<code>DOM</code>进行事件监听时，首先对<code>VitrualDom</code>进行事件监听，<code>VitrualDom</code>会代理原生的<code>DOM</code>事件从而做出响应。</li></ul></li><li><p>为什么使用虚拟dom?</p><ul><li><p>可以提高开发效率</p><pre><code>使用JavaScript，我们在编写应用程序时的关注点在于如何更新DOM。使用React，你只需要告诉React你想让视图处于什么状态，React则通过VitrualDom确保DOM与该状态相匹配。你不必自己去完成属性操作、事件处理、DOM更新，React会替你完成这一切。这让我们更关注我们的业务逻辑而非DOM操作，这一点即可大大提升我们的开发效率。</code></pre></li><li><p>性能提升?(有一些矛盾)</p><pre><code>- 直接说虚拟DOM可以提升性能这种说法是很片面的,直接操作dom非常耗费性能这一点毋庸置疑,但是react同样也无法避免操作dom-    如果是首次渲染,virtualDom不具有任何优势,甚至要进行更多的计算和耗费更多的内存- virtualDOm优势在于diff算法和批量处理策略,在react页面更新之前,已经提前计算好了如何更新和渲染dom,减少重绘回流,因此可以理解为提升了性能</code></pre></li><li><p>跨浏览器兼容</p><pre><code>virtualDom自己实现了一套事件机制,模拟了事件捕获和冒泡的过程,采用了事件代理和批量更新的方法,可以抹平各浏览器事件处理不兼容的问题</code></pre></li></ul></li><li><p>React组件的渲染流程</p><ul><li><p>使用<code>React.createElement</code>或<code>JSX</code>编写<code>React</code>组件，<code>Babel</code>帮助我们把所有的<code>JSX </code>代码最后都会转换成<code>React.createElement(...) </code>格式</p><ul><li><p>JSX编写</p><pre><code>class Hello extends Component &#123;  render() &#123;    return &lt;div&gt;Hello ConardLi&lt;/div&gt;;  &#125;&#125;</code></pre></li><li><p><code>React.createElement</code>编写</p><pre><code>class Hello extends Component &#123;  render() &#123;    return React.createElement(&#39;div&#39;, null, `Hello ConardLi`);  &#125;&#125;</code></pre></li><li><p><code>Babel</code>转化demo</p><pre><code>&lt;div&gt;  &lt;img src=&quot;avatar.png&quot; className=&quot;profile&quot; /&gt;  &lt;Hello /&gt;&lt;/div&gt;;</code></pre><pre><code>React.createElement(&quot;div&quot;, null,     React.createElement(&quot;img&quot;, &#123;      src: &quot;avatar.png&quot;,      className: &quot;profile&quot;    &#125;),     React.createElement(Hello, null));</code></pre></li></ul></li><li><p><code>createElement</code>函数对<code>key</code>和<code>ref</code>等特殊的<code>props</code>进行处理，并获取<code>defaultProps</code>对默认<code>props</code>进行赋值，并且对传入的孩子节点进行处理，最终构造成一个<code>ReactElement</code>对象（所谓的虚拟<code>DOM</code>）。</p></li><li><p><code>ReactDOM.render</code>将生成好的虚拟<code>DOM</code>渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实<code>DOM</code>。</p></li></ul></li></ul><p>​    </p><ul><li><p>virtualDom的组成</p><p>即<code>ReactElement</code>element对象，我们的组件最终会被渲染成下面的结构</p><ul><li><code>type</code>：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或<code>class</code>）</li><li><code>key</code>：组件的唯一标识，用于<code>Diff</code>算法</li><li><code>ref</code>：用于访问原生<code>dom</code>节点</li><li><code>props</code>：传入组件的<code>props</code>，<code>chidren</code>是<code>props</code>中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点）</li><li><code>owner</code>：当前正在构建的<code>Component</code>所属的<code>Component</code></li><li><code>self</code>：（非生产环境）指定当前位于哪个组件实例</li><li><code>_source</code>：（非生产环境）指定调试代码来自的文件(<code>fileName</code>)和代码行数(<code>lineNumber</code>)</li></ul><p>例如;</p><pre><code>&lt;div class=&quot;title&quot;&gt;      &lt;span&gt;Hello ConardLi&lt;/span&gt;      &lt;ul&gt;        &lt;li&gt;苹果&lt;/li&gt;        &lt;li&gt;橘子&lt;/li&gt;      &lt;/ul&gt;&lt;/div&gt;</code></pre><pre><code>const VitrualDom = &#123;  type: &#39;div&#39;,  props: &#123; class: &#39;title&#39; &#125;,  children: [    &#123;      type: &#39;span&#39;,      children: &#39;Hello ConardLi&#39;    &#125;,    &#123;      type: &#39;ul&#39;,      children: [        &#123; type: &#39;li&#39;, children: &#39;苹果&#39; &#125;,        &#123; type: &#39;li&#39;, children: &#39;橘子&#39; &#125;      ]    &#125;  ]&#125;</code></pre></li></ul><h4 id="03-diff算法"><a href="#03-diff算法" class="headerlink" title="03 / diff算法"></a>03 / diff算法</h4><ul><li>DIFF算法是DOM更新的一种算法,指页面被更新时,程序用哪种策略更新DOM</li><li>作用是用来计算出 <strong>Virtual DOM</strong> 中被改变的部分，然后针对该部分进行原生DOM操作，而不用重新渲染整个页面。</li></ul><p>DIFF算法策略:</p><ul><li><p>Tree Diff    对树每一层进行遍历，找出不同</p><p><img src="https://s3.ax1x.com/2020/11/17/DVYzW9.png"></p></li><li><p>Component Diff  是数据层面的差异比较</p></li><li><p>Element Diff  真实DOM渲染，结构差异的比较</p><ul><li>Diff提供三种DOM操作：<strong>删除</strong>、<strong>移动</strong>、<strong>插入</strong>。</li></ul></li></ul><p><img src="https://s3.ax1x.com/2020/11/17/DVYozn.png"></p><h4 id="04-fiber架构"><a href="#04-fiber架构" class="headerlink" title="04 / fiber架构"></a>04 / fiber架构</h4><blockquote><p>fiber架构是React16对核心算法的一次重构</p><p>Fiber使原本同步渲染变为异步</p></blockquote><p><strong>4.1 React历史算法的风险</strong></p><blockquote><p>React16之前,组件每次更新都会触发React去构建一棵新的虚拟DOM树,通过与上一次虚拟DOM的diff对比,实现DOM的定更新</p><p>该过程是是一个递归的过程,调用栈非常深,只有最低层的返回了,才能逐层返回.</p><p>这个过程漫长且不可打断,同步一旦开始,就会牢牢抓住线程,直到递归完成,这个过程浏览器除了渲染不会再做其他事情,无法处理用户</p><p>交互状态,页面可能会卡死</p></blockquote><p><strong>4.2 Fiber是怎样处理渲染的？</strong></p><blockquote><p>Fiber 会将一个大的更新任务拆解为许多个小任务。</p><p>每当执行完一个小任务时，渲染线程都会把主线程交回去，看看有没有优先级更高的工作要处理，确保不会出现其他任务被“饿死”的情况，进而避免同步渲染带来的卡顿。</p><p>在这个过程中，渲染线程不再“一去不回头”，而是可以被打断的，这就是所谓的“异步渲染”</p></blockquote><p><strong>4.3 说回生命周期</strong></p><p>在最开始给出生命周期图的时候，细心的同学会发现，在下面这张图的左边，React又将生命周期划分了如下三个阶段</p><p><img src="https://s1.ax1x.com/2020/11/10/BL0HNF.png"></p><ul><li>render：纯净且没有副作用，可能会被暂停或者终止，重新启动</li><li>Pre-commit阶段：可以读取DOM</li><li>commit阶段：可以使用DOM，运行副作用，安排更新</li></ul><p><strong>4.4为什么会这样分呢？</strong></p><blockquote><p>总的来说，render 阶段在执行过程中允许被打断，而 commit 阶段则总是同步执行的。</p><p>为什么这样设计呢？简单来说，由于 render 阶段的操作对用户来说其实是“不可见”的，所以就算打断再重启，对用户来说也是零感知。而 commit 阶段的操作则涉及真实 DOM 的渲染，再狂的框架也不敢在用户眼皮子底下胡乱更改视图，所以这个过程必须用同步渲染来求稳。</p></blockquote><p><strong>4.5废除的生命周期跟Fiber之间的联系</strong></p><pre><code>在 Fiber 机制下，render 阶段是允许暂停、终止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务被重启的形式是“重复执行一遍整个任务”而非“接着上次执行到的那行代码往下走”。这就导致 render 阶段的生命周期都是有可能被重复执行的。带着这个结论，我们再来看看 React 16 打算废弃的是哪些生命周期：componentWillMount；componentWillUpdate；componentWillReceiveProps。这些生命周期的共性，就是它们都处于 render 阶段，都可能重复被执行，而且由于这些 API 常年被滥用，它们在重复执行的过程中都存在着不可小觑的风险。</code></pre><h4 id="05-React数据传递方案"><a href="#05-React数据传递方案" class="headerlink" title="05 / React数据传递方案"></a>05 / React数据传递方案</h4><ul><li>组件传值</li><li>context</li><li>redux</li></ul><h4 id="06-setState之后发生什么"><a href="#06-setState之后发生什么" class="headerlink" title="06 / setState之后发生什么?"></a>06 / setState之后发生什么?</h4><p>一、React中setState后发生了什么</p><blockquote><p>在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程(Reconciliation)。</p><p>经过调和过程，React 会以相对高效的方式根据新的状态构建React元素树并且着手重新渲染整个Ul界面。</p><p>在React得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。 在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变,这就保证了按需更新，而不是全部重新渲染。</p></blockquote><p>二、setState 为什么默认是异步</p><blockquote><p>假如所有setState是同步的，意味着每执行一次setState时 (有可能一个同步代码中， 多次setState) 都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异 步，则可以把一一个同步代码中的多个setState合并成- -次组件更新。</p></blockquote><p>三、setState什么时候是同步</p><blockquote><p>在setTimeout或者原生事件中，setState是同步的。</p></blockquote><h4 id="7-componentWillUpdate可以直接修改state的值吗？"><a href="#7-componentWillUpdate可以直接修改state的值吗？" class="headerlink" title="7 / componentWillUpdate可以直接修改state的值吗？"></a>7 / componentWillUpdate可以直接修改state的值吗？</h4><blockquote><p>react组件在每次需要重新渲染时候都会调用<code>componentWillUpdate()</code>,</p><p>例如，我们调用 <code>this.setState()</code>时候</p><p>在这个函数中我们之所以不调用<code>this.setState()</code>是因为该方法会触发另一个<code>componentWillUpdate()</code>,如果我们<code>componentWillUpdate()</code>中触发状态更改,我们将以无限循环结束.</p></blockquote><h4 id="8-使用Hooks要遵守哪些原则？"><a href="#8-使用Hooks要遵守哪些原则？" class="headerlink" title="8 / 使用Hooks要遵守哪些原则？"></a>8 / 使用Hooks要遵守哪些原则？</h4><blockquote><ol><li>只在最顶层使用 Hook, 不要在循环，条件或嵌套函数中调用 Hook， 确保总是在你的 React 函数的最顶层调用他们。</li><li>只在 React 函数中调用 Hook, 不要在普通的 JavaScript 函数中调用 Hook。</li><li>可以：<br>✅ 在 React 的函数组件中调用 Hook<br>✅ 在自定义 Hook 中调用其他 Hook</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;center&gt;“基于 XLSX 封装的  Excel 并解析为 JSON格式数据的组件”&lt;/center&gt;</summary>
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://juntengma.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React生命周期函数</title>
    <link href="https://juntengma.github.io/2020/11/06/React/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://juntengma.github.io/2020/11/06/React/React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-11-06T07:28:31.113Z</published>
    <updated>2020-11-10T04:07:29.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>​    温故而知新<del>~</del></p><p>​    越基础,越重要哦~</p></blockquote><p><img src="https://s1.ax1x.com/2020/11/06/Bf52x1.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;​    温故而知新&lt;del&gt;~&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;​    越基础,越重要哦~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/11/06/Bf52x1.jpg&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://juntengma.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React-Hook学习</title>
    <link href="https://juntengma.github.io/2020/11/06/React/React-hooks/"/>
    <id>https://juntengma.github.io/2020/11/06/React/React-hooks/</id>
    <published>2020-11-06T06:49:51.445Z</published>
    <updated>2020-11-18T04:35:52.435Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直都知道Hook这个新技术,但是工作过程中几乎没有用到,最近刚好有时间来学习一下<del>~</del></p></blockquote><a id="more"></a><h3 id="01-什么是Hook"><a href="#01-什么是Hook" class="headerlink" title="01/什么是Hook?"></a>01/什么是Hook?</h3><p>Hook是react16.8新增特性,可以在不编写class的情况下使用state以及其他React特性</p><h3 id="02-什么是Hook"><a href="#02-什么是Hook" class="headerlink" title="02/什么是Hook?"></a>02/什么是Hook?</h3><ul><li>Hook顾名思义是钩子的意思,它可以使函数组件中可以勾入React-State以及生命周期特性等等.</li><li>Hook不能在class组件中使用</li></ul><h3 id="03-Hook内置组件"><a href="#03-Hook内置组件" class="headerlink" title="03/Hook内置组件"></a>03/Hook内置组件</h3><ul><li><p><strong>useState</strong>    (用于操控state)</p><ul><li><p><strong>使用:</strong></p><pre><code>const [stateName , stateChangeFun] = useState(初始值)</code></pre><pre><code>const [count , setCount] = useState(0)&lt;Button onClick=&#123;()=&gt;setCount(count++)&#125;&gt;Click&lt;/Button&gt;    </code></pre></li></ul></li><li><p><strong>useEffect</strong></p><p>Effect Hook 可以让我们在react中执行副作用操作</p><p><code>useEffect</code> 的第二个参数，有三种情况</p><ol><li>什么都不传，组件每次 <code>render</code> 之后 <code>useEffect</code> 都会调用，相当于 <code>componentDidMount</code> 和 <code>componentDidUpdate</code></li></ol></li></ul><ol start="2"><li>传入一个空数组 [], 只会调用一次，相当于 <code>componentDidMount</code> 和 <code>componentWillUnmount</code><ol start="3"><li>传入一个数组，其中包括变量，只有这些变量变动时，<code>useEffect</code> 才会执行</li></ol></li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一直都知道Hook这个新技术,但是工作过程中几乎没有用到,最近刚好有时间来学习一下&lt;del&gt;~&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="React" scheme="https://juntengma.github.io/categories/React/"/>
    
    
    <category term="Hook" scheme="https://juntengma.github.io/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击</title>
    <link href="https://juntengma.github.io/2020/11/04/Safe/CSRF%E6%94%BB%E5%87%BB/"/>
    <id>https://juntengma.github.io/2020/11/04/Safe/CSRF%E6%94%BB%E5%87%BB/</id>
    <published>2020-11-04T07:53:26.651Z</published>
    <updated>2020-11-16T09:10:00.414Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="01-什么是CSRF攻击"><a href="#01-什么是CSRF攻击" class="headerlink" title="01/ 什么是CSRF攻击?"></a>01/ 什么是CSRF攻击?</h4><p>CSRF攻击指的是跨站请求伪造,攻击者诱导用户进入第三方网站,然后该网站向被攻击者网站发送跨站请求.</p><p>如果用户在被攻击者网站中保存了登录状态,攻击者就可以利用这个状态,绕过后台验证,冒充用户向服务器执行一些操作;</p><h4 id="02-CSRF攻击分类"><a href="#02-CSRF攻击分类" class="headerlink" title="02/ CSRF攻击分类"></a>02/ CSRF攻击分类</h4><ul><li>GET请求的CSRF攻击, 通常用img标签构建请求,用户打开网站的时候,自动发送请求</li><li>POST请求CSRF攻击,比如说构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单</li><li>链接类型的 CSRF 攻击，比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li></ul><h4 id="03-防御方法"><a href="#03-防御方法" class="headerlink" title="03/ 防御方法"></a>03/ 防御方法</h4><ul><li>第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。</li><li>第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们可以通过改变 token 的构建方式来解决。</li><li>第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li><li>第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li><li>验证码</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h4 id=&quot;01-什么是CSRF攻击&quot;&gt;&lt;a href=&quot;#01-什么是CSRF攻击&quot; class=&quot;headerlink&quot; title=&quot;01/ 什么是CSRF攻击?&quot;&gt;&lt;/a&gt;01/ 什么是CSRF攻击?&lt;/h4&gt;&lt;p&gt;CSRF攻击指</summary>
      
    
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击</title>
    <link href="https://juntengma.github.io/2020/11/04/Safe/XSS%E6%94%BB%E5%87%BB/"/>
    <id>https://juntengma.github.io/2020/11/04/Safe/XSS%E6%94%BB%E5%87%BB/</id>
    <published>2020-11-04T07:53:15.118Z</published>
    <updated>2020-11-18T02:36:10.688Z</updated>
    
    <content type="html"><![CDATA[<p>前端知识回顾之 - XSS攻击</p><a id="more"></a><h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><h4 id="1-什么是xss攻击"><a href="#1-什么是xss攻击" class="headerlink" title="1.什么是xss攻击"></a>1.什么是xss攻击</h4><ul><li>xss攻击即跨站脚本攻击,是一种恶意代码注入攻击,攻击者通过在网站上面注入恶意代码,使之在浏览器上面运行,从而获取用户的敏感信息如cookie等</li><li>xss的本质是因为网站没有对恶意代码进行过滤, 与正常代码混在一起,但是浏览器不能识别代码哪些可信哪些不可信,从而导致了恶意代码的执行.</li></ul><h4 id="2-XSS攻击分类"><a href="#2-XSS攻击分类" class="headerlink" title="2.XSS攻击分类"></a>2.XSS攻击分类</h4><ul><li><p>存储型</p><blockquote><p>存储型XSS攻击是将恶意代码提交到网站服务器中,当用户请求数据的时候,服务器将恶意代码拼接到HTML里面后返回,导致恶意代码的执行</p></blockquote></li><li><p>反射型</p><blockquote><p>反射型指的是某些通过url参数获取数据的网站,攻击者构建特殊的url,当服务器收到请求之后,从url中获取数据,并将其拼接为html后返回,从而导致了恶意代码的执行</p></blockquote></li><li><p>DOM型</p><blockquote><p>DOM型XSS攻击指的是攻击者构建了特殊的URL,当用户打开了网站之后,js脚本从url中获取数据,从而导致了恶意代码的执行</p></blockquote></li></ul><h4 id="3-如何预防XSS攻击"><a href="#3-如何预防XSS攻击" class="headerlink" title="3.如何预防XSS攻击"></a>3.如何预防XSS攻击</h4><p>​    预防XSS攻击主要有两个方案</p><ul><li><p>恶意代码提交的时候(不可靠)</p><blockquote><p>当数据即将存入数据库的时候进行转义,但是数据库的数据可能在多个地方使用,有些地方不需要转义,由于我们无法判断这些数据最后的使用场景,所以该方法是<strong>不可靠的</strong></p></blockquote></li><li><p>浏览器执行之前</p><blockquote><ul><li>使用纯前端的方式,不用服务器拼接HTML返回    </li><li>对需要插入的HTML进行充分的转义</li></ul></blockquote></li><li><p>对于DOM性XSS攻击还有以下几种方式</p><blockquote><ul><li>CSP,CSP本质是简历一个白名单,告诉浏览器哪些外部资源是可以加载和执行,从而防止恶意代码的注入攻击</li><li>对敏感信息进行保护,比如cookie使用http-only,禁止脚本获取cookie</li><li>使用验证码,防止脚本伪装用户进行操作</li></ul></blockquote></li></ul><h4 id="4-什么是CSP"><a href="#4-什么是CSP" class="headerlink" title="4.什么是CSP"></a>4.什么是CSP</h4><p>​    CSP指的是内容安全侧策略</p><p>​    他的本质是建立一个白名单,告诉浏览器哪些外部资源可以加在和执行.</p><p>​    <strong>开启SCP方式:</strong></p><ul><li>一种是设置 HTTP 首部中的 <code>Content-Security-Policy</code></li><li>一种是设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ul><p>详细资料可以参考： <a href="https://juejin.im/post/5bad9140e51d450e935c6d64">《前端安全系列（一）：如何防止 XSS 攻击？》</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前端知识回顾之 - XSS攻击&lt;/p&gt;</summary>
    
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/categories/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="前端安全" scheme="https://juntengma.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>DOM事件 , 事件流</title>
    <link href="https://juntengma.github.io/2020/11/03/JavaScript/02%20-%20JavaScript-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <id>https://juntengma.github.io/2020/11/03/JavaScript/02%20-%20JavaScript-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</id>
    <published>2020-11-02T16:00:00.000Z</published>
    <updated>2020-11-26T07:49:01.240Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4> DOM事件, 事件流</h4></blockquote><a id="more"></a><h3 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h3><blockquote><p>事件是指JavaScript与HTML交互的基础.要实现用户与页面的交互,先要对目标元素绑定特定的事件,设置事件处理函数,用户触发事件,事件处理函数执行,产生交互效果</p></blockquote><h4 id="DOM事件级别"><a href="#DOM事件级别" class="headerlink" title="DOM事件级别"></a>DOM事件级别</h4><p>DOM 级别分为四个级别：DOM0 级、DOM1 级、DOM2 级、DOM3 级；<br><img src="https://s1.ax1x.com/2020/10/28/B1JoY4.md.jpg" alt="B1JoY4.md.jpg"></p><p>DOM事件分为三个级别:<br>DOM0 级事件: 给元素绑定事件</p><pre><code>&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;/button&gt;&lt;script&gt;    var btn = document.getElementById(&#39;btn&#39;)    btn.onclick = function() &#123;        console.log(&#39;Hello World&#39;)    &#125;    // btn.onclick = null // 解绑事件&lt;/script&gt;</code></pre><blockquote><p>   缺点：无法设置多个事件处理函数</p></blockquote><p>DOM2 级事件:用到了事件监听</p><pre><code>&lt;button id=&quot;btn&quot; type=&quot;button&quot;&gt;&lt;/button&gt;&lt;script&gt;    var btn = document.getElementById(&#39;btn&#39;);        btn.addEventListener(&#39;click&#39;, showFn, false)    btn.addEventListener(&#39;click&#39;, showFn2, false)    // btn.removeEventListener(&#39;click&#39;, showFn, false) // 解绑事件     function showFn() &#123;        alert(&#39;Hello World&#39;);    &#125;     function showFn2() &#123;        alert(&#39;Hello World2&#39;);    &#125; &lt;/script&gt;</code></pre><blockquote><p>可以为事件设置多个事件处理函数，可以通过第三个参数 ( useCapture ) 设置在什么阶段执行事件处理函数，默认是 false， 即在事件冒泡阶段执行事件处理函数。</p></blockquote><blockquote><p>需要注意的是在 IE8 及以下版本需要用 attachEvent 和 detachEvent 实现，只有两个参数，事件名需要以 on 开头，只支持在事件冒泡阶段执行事件处理函数。</p></blockquote><p>DOM3 级事件</p><blockquote><p>DOM3 级事件是在 DOM2 级事件的基础上添加了更多的事件类型，允许自定义事件。</p></blockquote><p>UI事件，当用户与页面上的元素交互时触发，如：load、scroll<br>焦点事件，当元素获得或失去焦点时触发，如：blur、focus<br>鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup<br>滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel<br>文本事件，当在文档中输入文本时触发，如：textInput<br>键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress<br>合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart<br>变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified</p><pre><code>// 自定义事件var event = new Event(&#39;test&#39;)// 给元素绑定事件domElement.addEventListener(&#39;test&#39;, function() &#123;    console.log(&#39;event test&#39;)&#125;,)// 触发事件setTimeout(function() &#123;    domElement.dispatchEvent(event)&#125;, 1000)</code></pre><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><blockquote><p>事件流又称为事件传播，描述的是从<strong>页面中接收事件的顺序</strong>。</p><p>DOM2 级事件规定事件流包括三个阶段: </p><ul><li>事件捕获(capturing phase)</li><li>目标事件(target phase)</li><li>事件冒泡(bubbling phase)</li></ul><p>发生的顺序是：事件捕获阶段 –&gt; 目标事件阶段 –&gt; 事件冒泡阶段</p></blockquote><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><blockquote><p>​    事件起始元素逐级向上传播</p></blockquote><pre><code>&lt;style&gt;  #parent &#123;      width: 200px;      height: 200px;      background-color: green;  &#125;  #child &#123;      width: 100px;      height: 100px;      background-color: yellow;  &#125;&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt;  &lt;div id=&quot;child&quot;&gt;目标元素&lt;/div&gt;  父级元素&lt;/div&gt;&lt;script&gt;  var parent = document.getElementById(&#39;parent&#39;)  var child = document.getElementById(&#39;child&#39;)  parent.addEventListener(&#39;click&#39;, function(e) &#123;      console.log(&#39;parent bubbling&#39;)  &#125;, false)  child.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;target bubbling&#39;)  &#125;, false)  document.body.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;body bubbling&#39;)  &#125;, false)  document.documentElement.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;html bubbling&#39;)  &#125;, false)  document.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;document bubbling&#39;)  &#125;, false)  window.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;window bubbling&#39;)  &#125;, false)&lt;/script&gt;</code></pre><p>运行结果：</p><h4 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h4><blockquote><p>​    事件按 window -&gt; document -&gt; html -&gt; body -&gt; … -&gt; 目标元素 的方向向下层元素传递。</p></blockquote><pre><code>&lt;style&gt;  #parent &#123;      width: 200px;      height: 200px;      background-color: green;  &#125;  #child &#123;      width: 100px;      height: 100px;      background-color: yellow;  &#125;&lt;/style&gt;&lt;div id=&quot;parent&quot;&gt;  &lt;div id=&quot;child&quot;&gt;目标元素&lt;/div&gt;  父级元素&lt;/div&gt;&lt;script&gt;  var parent = document.getElementById(&#39;parent&#39;)  var child = document.getElementById(&#39;child&#39;)  parent.addEventListener(&#39;click&#39;, function(e) &#123;      console.log(&#39;parent capture&#39;)  &#125;, true)  child.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;target capture&#39;)  &#125;, true)  document.body.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;body capture&#39;)  &#125;, true)  document.documentElement.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;html capture&#39;)  &#125;, true)  document.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;document capture&#39;)  &#125;, true)  window.addEventListener(&#39;click&#39;, function() &#123;      console.log(&#39;window capture&#39;)  &#125;, true)&lt;/script&gt;</code></pre><p>运行结果:</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;h4&gt; 
DOM事件, 事件流
&lt;/h4&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="DOM事件事件流" scheme="https://juntengma.github.io/tags/DOM%E4%BA%8B%E4%BB%B6%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>一段js代码在浏览器中是如何执行的</title>
    <link href="https://juntengma.github.io/2020/11/02/JavaScript/04%20-%20JavaScript-%E4%B8%80%E6%AE%B5js%E4%BB%A3%E7%A0%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <id>https://juntengma.github.io/2020/11/02/JavaScript/04%20-%20JavaScript-%E4%B8%80%E6%AE%B5js%E4%BB%A3%E7%A0%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</id>
    <published>2020-11-01T16:00:00.000Z</published>
    <updated>2020-11-26T07:48:40.226Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一段js代码在浏览器中是如何执行的"><a href="#一段js代码在浏览器中是如何执行的" class="headerlink" title="一段js代码在浏览器中是如何执行的?"></a>一段js代码在浏览器中是如何执行的?</h3><blockquote><p>   在了解代码执行流程之前 , 我们需要知道一点前置知识 , </p><ul><li>js解析顺序</li><li>可执行代码</li><li>执行上下文栈<br>当我们这些前置知识都捋清楚了 , js执行流程也就清楚了…..<a id="more"></a></li></ul></blockquote><h3 id="01-JS代码执行顺序是什么"><a href="#01-JS代码执行顺序是什么" class="headerlink" title="01 / JS代码执行顺序是什么"></a>01 / JS代码执行顺序是什么</h3><p>  JavaScript代码是逐行执行的 , 但是js引擎并非一行一行的<strong>解析</strong>执行程序,而是一段一段的分析执行,为什么是分段执行的呢?又按什么规则来分段的呢?这里我们需要再了解一下什么是<strong>可执行代码</strong></p><p>  (Js代码是逐行执行的,但是js引擎并非逐行解析程序执行的,而是判断是否可执行代码一段一段的执行的)</p><h3 id="02-可执行代码-amp-执行上下文"><a href="#02-可执行代码-amp-执行上下文" class="headerlink" title="02 / 可执行代码 &amp; 执行上下文"></a>02 / 可执行代码 &amp; 执行上下文</h3><p>  可执行代码有三种,全局代码,函数代码,eval代码,当执行到可执行代码的时候,就会进行准备一些工作 . 这个准备工作就是<strong>执行上下文</strong></p><ul><li><p>全局代码</p></li><li><p>函数代码</p></li><li><p>eval代码( evla()函数可以将传入的字符串当做 JavaScript 代码进行执行 )</p><h3 id="05-执行上下文栈"><a href="#05-执行上下文栈" class="headerlink" title="05 / 执行上下文栈"></a>05 / 执行上下文栈</h3><p>为了管理js中大量的可执行上下文,JavaScript引擎创建了<strong>执行上下文栈</strong>来管理可执行上下文</p></li><li><p>当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈(ECStack)压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext.</p><pre><code>const ECStack  = [      globalContext ]</code></pre></li></ul><ul><li><p>当函数开始执行的时候,同样生成一个可以执行上下文并压入可执行上下文栈,当函数执行完毕的时候,再从执行上下文栈中弹出</p><pre><code>const ECStack  = [  eval()  function()  globalContext ]</code></pre></li></ul><h3 id="06-总结"><a href="#06-总结" class="headerlink" title="06 / 总结:"></a>06 / 总结:</h3><ul><li>在执行一段代码时，JS 引擎会首先<strong>创建一个执行栈</strong>,然后JS引擎会创建一个<strong>全局执行上下文</strong>，并push到执行栈中</li></ul><ul><li>这个过程JS引擎会为这段代码中<strong>所有变量</strong>分配内存并赋一个初始值（undefined）</li></ul><ul><li>在创建完成后，JS引擎会进入<strong>执行阶段</strong>，这个<strong>过程JS引擎会逐行的执行代码</strong>，即为之前分配好内存的变量逐个赋值(真实值)。</li></ul><ul><li>如果这段代码中存在function的声明和调用，那么JS引擎会创建一个<strong>函数执行上下文</strong>，并push到执行栈中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS引擎会在父函数执行的过程中，将子函数的全局执行上下文push到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。</li></ul><ul><li><p>还有一种特殊情况是，在子函数执行的过程中，父函数已经return了，这种情况下，JS引擎会将父函数的上下文从执行栈中移除，与此同时，JS引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS引擎才会将子函数的上下文及闭包一并从执行栈中移除。</p><h3 id="JS引擎如何处理高并发"><a href="#JS引擎如何处理高并发" class="headerlink" title="JS引擎如何处理高并发?"></a>JS引擎如何处理高并发?</h3></li></ul><p>  <strong>JS引擎是单线程的</strong>，那么它是如何处理高并发的呢？即当代码中存在异步调用时JS是如何执行的?</p><p>  比如setTimeout或fetch请求都是non-blocking的，<br>  当异步调用代码触发时，JS引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS引擎会立即将与之对应的回调函数push进任务队列中等待被调用，<br>  当调用(执行)栈中已经没有需要被执行的代码时，JS引擎会立刻将任务队列中的回调函数逐个push进调用栈并执行。这个过程我们也称之为<strong>事件循环</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;一段js代码在浏览器中是如何执行的&quot;&gt;&lt;a href=&quot;#一段js代码在浏览器中是如何执行的&quot; class=&quot;headerlink&quot; title=&quot;一段js代码在浏览器中是如何执行的?&quot;&gt;&lt;/a&gt;一段js代码在浏览器中是如何执行的?&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;   在了解代码执行流程之前 , 我们需要知道一点前置知识 , &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;js解析顺序&lt;/li&gt;
&lt;li&gt;可执行代码&lt;/li&gt;
&lt;li&gt;执行上下文栈&lt;br&gt;当我们这些前置知识都捋清楚了 , js执行流程也就清楚了…..</summary>
    
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://juntengma.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
